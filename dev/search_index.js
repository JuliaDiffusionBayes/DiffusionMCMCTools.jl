var documenterSearchIndex = {"docs":
[{"location":"module_index/#","page":"Index","title":"Index","text":"CurrentModule = DiffusionMCMCTools","category":"page"},{"location":"module_index/#DiffusionMCMCTools-1","page":"Index","title":"DiffusionMCMCTools","text":"","category":"section"},{"location":"module_index/#","page":"Index","title":"Index","text":"","category":"page"},{"location":"module_index/#","page":"Index","title":"Index","text":"Modules = [DiffusionMCMCTools]","category":"page"},{"location":"module_index/#DiffusionMCMCTools.init_paths!-NTuple{5,Any}","page":"Index","title":"DiffusionMCMCTools.init_paths!","text":"init_paths!(P, WW, Wnr, XX, x0_prior)\n\nSample paths of guided proposals without using the preconditioned Crank–Nicolson scheme.\n\n\n\n\n\n","category":"method"},{"location":"manual/block/#Block-1","page":"Block","title":"Block","text":"","category":"section"},{"location":"manual/block/#","page":"Block","title":"Block","text":"","category":"page"},{"location":"manual/block/#","page":"Block","title":"Block","text":"A smallest unit that is needed for blocking.","category":"page"},{"location":"manual/block/#","page":"Block","title":"Block","text":"DiffusionMCMCTools.Block","category":"page"},{"location":"manual/block/#DiffusionMCMCTools.Block","page":"Block","title":"DiffusionMCMCTools.Block","text":"mutable struct Block{L,TGP,TGPl,TW,TWn,TX}\n    PP::TVIEW{TGP}\n    P_last::TVIEW{TGPl} # view into a single element\n    WW::TVIEW{TW}\n    Wnr::TWn\n    XX::TVIEW{TX}\n    ll::Float64\n    ll_history::Vector{Float64}\nend\n\nThe smallest \"containerless\" unit that provides a view into SamplingUnit restricted to a range i:j of a block. L is an important flag that indicates whether it is a terminal block or not.\n\nFields\n\n\n\nPP: a vector of views into relevant GuidProp\nP_last: a view into a single (or none) GuidProp corresponding to the           terminal sub-interval.\nWW: a vector of views into containers for sampled Wiener process\nWnr: a flag for sampling Wiener processes\nXX: a vector of views into containers for a sampled process\nll: a placeholder for computed log-likelihood\nll_history: a history of computed log-likelihoods (useful for MCMC)\n\nfunction Block(\n    u::SamplingUnit,\n    range::UnitRange{Int64},\n    last_block=false,\n    ll_hist_len=0\n)\n\nBase constructor.\n\n\n\n\n\n","category":"type"},{"location":"manual/block/#","page":"Block","title":"Block","text":"It is rarely used on its own. Instead, it is used mainly as a building block of other, composite units. Nevertheless, there are a couple of useful functions implemented for it:","category":"page"},{"location":"manual/block/#","page":"Block","title":"Block","text":"DiffusionMCMCTools.set_ll!(b::DiffusionMCMCTools.Block, i::Int, v)\nDiffusionMCMCTools.save_ll!(b::DiffusionMCMCTools.Block, i::Int)\nDiffusionMCMCTools.recompute_guiding_term!(b::DiffusionMCMCTools.Block)\nDiffusionMCMCTools.find_W_for_X!(b::DiffusionMCMCTools.Block)\nDiffusionMCMCTools.loglikhd(b::DiffusionMCMCTools.Block)\nDiffusionMCMCTools.recompute_path!(b::DiffusionMCMCTools.Block, WW=b.WW; skip=0)","category":"page"},{"location":"manual/block/#DiffusionMCMCTools.set_ll!-Tuple{Block,Int64,Any}","page":"Block","title":"DiffusionMCMCTools.set_ll!","text":"set_ll!(b::Block, i::Int, v)\n\nSet the internal log-likelihood history field b.ll_history[i] with a value v\n\n\n\n\n\n","category":"method"},{"location":"manual/block/#DiffusionMCMCTools.save_ll!-Tuple{Block,Int64}","page":"Block","title":"DiffusionMCMCTools.save_ll!","text":"save_ll!(b::Block, i::Int)\n\nCommit the current log-likelihood field ll to history b.ll_history at index i.\n\n\n\n\n\n","category":"method"},{"location":"manual/block/#GuidedProposals.recompute_guiding_term!-Tuple{Block}","page":"Block","title":"GuidedProposals.recompute_guiding_term!","text":"GP.recompute_guiding_term!(b::Block)\n\nRecompute the guiding term.\n\n\n\n\n\n","category":"method"},{"location":"manual/block/#DiffusionMCMCTools.find_W_for_X!-Tuple{Block}","page":"Block","title":"DiffusionMCMCTools.find_W_for_X!","text":"find_W_for_X!(b::Block)\n\nCompute the Wiener process b.WW that is needed for obtaining path b.XX under the law stored in b.\n\n\n\n\n\n","category":"method"},{"location":"manual/block/#GuidedProposals.loglikhd-Tuple{Block}","page":"Block","title":"GuidedProposals.loglikhd","text":"GP.loglikhd(b::Block)\n\nCompute the log-likelihood evaluated at a sampled path.\n\n\n\n\n\n","category":"method"},{"location":"manual/block/#DiffusionMCMCTools.recompute_path!","page":"Block","title":"DiffusionMCMCTools.recompute_path!","text":"recompute_path!(b::Block, WW=b.WW; skip=0)\n\nRecompute the path b.XX for a given wiener process WW.\n\n\n\n\n\n","category":"function"},{"location":"manual/biblock/#BiBlock-1","page":"BiBlock","title":"BiBlock","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"","category":"page"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"A composite unit that represents a block. It can be used for sampling on a block in a setting of smoothing or inference.","category":"page"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"DiffusionMCMCTools.BiBlock","category":"page"},{"location":"manual/biblock/#DiffusionMCMCTools.BiBlock","page":"BiBlock","title":"DiffusionMCMCTools.BiBlock","text":"mutable struct BiBlock{L,TGP,TGPl,TW,TWn,TX}\n    b::Block{L,TGP,TGPl,TW,TWn,TX}\n    b°::Block{L,TGP,TGPl,TW,TWn,TX}\n    ρ::Float64\n    accpt_history::Vector{Bool}\nend\n\nComposite unit that allows for sampling of a single block. It provides two Blocks: one proposal b°, one accepted b that can be used for smoothing or inference problems. ρ is a memory parameter of the preconditioned Crank-Nicolson scheme and accpt_history stores the history of accept/reject decisions (useful for MCMC).\n\nfunction BiBlock(\n    sp::SamplingPair,\n    range::UnitRange{Int64},\n    ρ=0.0,\n    last_block=false,\n    ll_hist_len=0\n)\n\nBase constructor.\n\n\n\n\n\n","category":"type"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"There are many functions implemented for it.","category":"page"},{"location":"manual/biblock/#Imputation-of-paths-1","page":"BiBlock","title":"Imputation of paths","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"","category":"page"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"DiffusionMCMCTools.draw_proposal_path!(bb::DiffusionMCMCTools.BiBlock)","category":"page"},{"location":"manual/biblock/#DiffusionMCMCTools.draw_proposal_path!-Tuple{BiBlock}","page":"BiBlock","title":"DiffusionMCMCTools.draw_proposal_path!","text":"draw_proposal_path!(bb::BiBlock)\n\nSample a proposal path, compute log-likelihood along the way. Assumes bb.b.XX[1].x[1] is a starting point. Uses preconditioned Crank-Nicolson scheme with memory parameter set as bb.ρ.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#Accept/reject-decision-in-an-MCMC-setting-1","page":"BiBlock","title":"Accept/reject decision in an MCMC setting","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"","category":"page"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"DiffusionMCMCTools.accept_reject_proposal_path!(bb::DiffusionMCMCTools.BiBlock, mcmciter)","category":"page"},{"location":"manual/biblock/#DiffusionMCMCTools.accept_reject_proposal_path!-Tuple{BiBlock,Any}","page":"BiBlock","title":"DiffusionMCMCTools.accept_reject_proposal_path!","text":"accept_reject_proposal_path!(bb::BiBlock, mcmciter)\n\nAccept/reject decision of the Metropolis-Hastings algorithm for the step of path imputation.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#Adjustments-made-after-the-accept-reject-decision-(regardless-of-what-it-was)-1","page":"BiBlock","title":"Adjustments made after the accept-reject decision (regardless of what it was)","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"","category":"page"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"DiffusionMCMCTools.set_accepted!(bb::DiffusionMCMCTools.BiBlock, i::Int, v)","category":"page"},{"location":"manual/biblock/#DiffusionMCMCTools.set_accepted!-Tuple{BiBlock,Int64,Any}","page":"BiBlock","title":"DiffusionMCMCTools.set_accepted!","text":"set_accepted!(bb::BiBlock, i::Int, v)\n\nCommit the accept/reject decision v to acceptance history of BiBlock b at the position i.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#Adjustments-to-the-containers-in-case-of-**acceptance**-of-proposals:-1","page":"BiBlock","title":"Adjustments to the containers in case of acceptance of proposals:","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"","category":"page"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"DiffusionMCMCTools.swap_paths!(bb::DiffusionMCMCTools.BiBlock)\nDiffusionMCMCTools.swap_XX!(bb::DiffusionMCMCTools.BiBlock)\nDiffusionMCMCTools.swap_WW!(bb::DiffusionMCMCTools.BiBlock)\nDiffusionMCMCTools.swap_PP!(bb::DiffusionMCMCTools.BiBlock)\nDiffusionMCMCTools.swap_ll!(bb::DiffusionMCMCTools.BiBlock)","category":"page"},{"location":"manual/biblock/#DiffusionMCMCTools.swap_paths!-Tuple{BiBlock}","page":"BiBlock","title":"DiffusionMCMCTools.swap_paths!","text":"swap_paths!(bb::BiBlock)\n\nSwap XX and WW containers between proposal-acceptance pair.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#DiffusionMCMCTools.swap_XX!-Tuple{BiBlock}","page":"BiBlock","title":"DiffusionMCMCTools.swap_XX!","text":"swap_XX!(bb::BiBlock)\n\nSwap XX containers between proposal-acceptance pair.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#DiffusionMCMCTools.swap_WW!-Tuple{BiBlock}","page":"BiBlock","title":"DiffusionMCMCTools.swap_WW!","text":"swap_WW!(bb::BiBlock)\n\nSwap WW containers between proposal-acceptance pair.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#DiffusionMCMCTools.swap_PP!-Tuple{BiBlock}","page":"BiBlock","title":"DiffusionMCMCTools.swap_PP!","text":"swap_PP!(bb::BiBlock)\n\nSwap PP containers (including PP_last) between proposal-acceptance pair.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#DiffusionMCMCTools.swap_ll!-Tuple{BiBlock}","page":"BiBlock","title":"DiffusionMCMCTools.swap_ll!","text":"swap_ll!(bb::BiBlock)\n\nSwap ll containers between proposal-acceptance pair.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#Setting-up-a-block-1","page":"BiBlock","title":"Setting up a block","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"","category":"page"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"DiffusionMCMCTools.set_obs!(bb::DiffusionMCMCTools.BiBlock)\nDiffusionMCMCTools.recompute_guiding_term!(bb::DiffusionMCMCTools.BiBlock)\nDiffusionMCMCTools.find_W_for_X!(bb::DiffusionMCMCTools.BiBlock)","category":"page"},{"location":"manual/biblock/#GuidedProposals.set_obs!-Tuple{BiBlock}","page":"BiBlock","title":"GuidedProposals.set_obs!","text":"GP.set_obs!(bb::BiBlock)\n\nFreeze an artificial observation at the terminal point of the block. For a terminal block nothing is done.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#GuidedProposals.recompute_guiding_term!-Tuple{BiBlock}","page":"BiBlock","title":"GuidedProposals.recompute_guiding_term!","text":"GP.recompute_guiding_term!(bb::BiBlock)\n\nRecompute the guiding terms of both the proposal and the accepted laws.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#DiffusionMCMCTools.find_W_for_X!-Tuple{BiBlock}","page":"BiBlock","title":"DiffusionMCMCTools.find_W_for_X!","text":"find_W_for_X!(bb::BiBlock)\n\nFind the Wiener process bb.b.WW that reconstructs path bb.b.XX under the accepted law bb.b.PP (possibly including bb.b.P_last).\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#Utility-1","page":"BiBlock","title":"Utility","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"","category":"page"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"DiffusionMCMCTools.ll_of_accepted(bb::DiffusionMCMCTools.BiBlock, i)\nDiffusionMCMCTools.accpt_rate(bb::DiffusionMCMCTools.BiBlock, range)","category":"page"},{"location":"manual/biblock/#DiffusionMCMCTools.ll_of_accepted-Tuple{BiBlock,Any}","page":"BiBlock","title":"DiffusionMCMCTools.ll_of_accepted","text":"ll_of_accepted(bb::BiBlock, i)\n\nReturn the log-likelihood of the path that was accepted at the ith iteration.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#DiffusionMCMCTools.accpt_rate-Tuple{BiBlock,Any}","page":"BiBlock","title":"DiffusionMCMCTools.accpt_rate","text":"accpt_rate(bb::BiBlock, range)\n\nCompute the acceptance rate over the range of MCMC accept/reject history.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#Example:-smoothing-with-no-blocking-1","page":"BiBlock","title":"Example: smoothing with no blocking","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"","category":"page"},{"location":"manual/biblock/#Set-up-1","page":"BiBlock","title":"Set-up","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"using GuidedProposals, DiffusionDefinition, ObservationSchemes, DiffusionMCMCTools\nconst GP = GuidedProposals\nconst DD = DiffusionDefinition\nconst OBS = ObservationSchemes\nconst dMCMCt = DiffusionMCMCTools\n\nusing StaticArrays, Random, Plots\n\n# seed used for this tutorial\nRandom.seed!(100)\n\n@load_diffusion FitzHughNagumo\nθ = [0.1, -0.8, 1.5, 0.0, 0.3]\nP = FitzHughNagumo(θ...)\ntt, y1 = 0.0:0.0001:10.0, @SVector [-0.9, -1.0]\nX = rand(P, tt, y1)\nobs_scheme = ObsScheme(\n    LinearGsnObs(\n        0.0, (@SVector [0.0]);\n        L=(@SMatrix [1.0 0.0]),\n        Σ=(@SMatrix [0.01])\n    )\n)\ndata = collect(obs_scheme, X, 1000)\nrecording = build_recording(P, data, 0.0, KnownStartingPt(y1))\n\nplot(X, Val(:vs_time), size=(800, 300))\nscatter!(map(x->x.t, data), map(x->x.obs[1], data), label=\"data\")","category":"page"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"(Image: data)","category":"page"},{"location":"manual/biblock/#The-algorithm-1","page":"BiBlock","title":"The algorithm","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"function simple_smoothing(AuxLaw, recording, dt; ρ=0.5, num_steps=10^4)\n    tts = OBS.setup_time_grids(recording, dt, standard_guid_prop_time_transf)\n    # this object contains containers\n    sp = SamplingPair(AuxLaw, recording, tts)\n    # and this has pointers to containers and facilitates actual sampling\n    bb = BiBlock(sp, 1:length(recording.obs), ρ, true, num_steps)\n    bb.b.ll = loglikhd(bb.b)\n    paths = []\n\n    # MCMC\n    for i in 1:num_steps\n        # impute a path\n        draw_proposal_path!(bb)\n        # Metropolis–Hastings accept/reject step\n        accept_reject_proposal_path!(bb, i)\n\n        # progress message\n        if i % 100 == 0\n            println(\n                \"$i. ll=$(ll_of_accepted(bb, i)), acceptance rate: \",\n                \"$(sum(bb.accpt_history[(i-99):i])/100)\"\n            )\n        end\n\n        # save intermediate path for plotting\n        i % 400 == 0 && append!(paths, [deepcopy(bb.b.XX)])\n    end\n    paths\nend\n\n@load_diffusion FitzHughNagumoAux\npaths = simple_smoothing(\n    FitzHughNagumoAux, recording, 0.001; ρ=0.96, num_steps=10^4\n)","category":"page"},{"location":"manual/biblock/#Results-1","page":"BiBlock","title":"Results","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"function glue_paths(XX)\n    XX_glued = trajectory(\n        glue_containers( map(x->x.t, XX) ),\n        glue_containers( map(x->x.x, XX) ),\n    )\nend\n\nfunction glue_containers(xs)\n    glued_xs = collect(Iterators.flatten(map(x->x[1:end-1], xs)))\n    append!(glued_xs, [xs[end][end]])\n    glued_xs\nend\n\nconvenient_paths = glue_paths.(paths)\n\ncol = [\"#581845\", \"#900C3F\", \"#C70039\", \"#FF5733\", \"#FFC300\"]\n\np = plot(size=(1000, 500))\nfor path in convenient_paths\n\tplot!(p, path, Val(:vs_time), alpha=0.4, label=\"\", color=[col[3] col[1]])\nend\nplot!(X, Val(:vs_time), color=[col[5] col[4]], linewidth=[3 0.5], label=[\"underlying X₁\" \"underlying X₂\"])\nscatter!(p, map(x->x.t, data), map(x->x.obs[1], data), label=\"data\", markercolor=col[5])\ndisplay(p)","category":"page"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"(Image: smoothing)","category":"page"},{"location":"manual/biblock/#Example:-smoothing-with-blocking-1","page":"BiBlock","title":"Example: smoothing with blocking","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"","category":"page"},{"location":"manual/biblock/#Set-up-2","page":"BiBlock","title":"Set-up","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"Same as above","category":"page"},{"location":"manual/biblock/#The-algorithm-2","page":"BiBlock","title":"The algorithm","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"function simple_smoothing_with_blocking(\n        AuxLaw, recording, dt, AuxLawBlocking, block_layout;\n        ρ=0.5, num_steps=10^4\n    )\n    tts = OBS.setup_time_grids(recording, dt, standard_guid_prop_time_transf)\n    # this object contains containers\n    sp = SamplingPair(AuxLaw, recording, tts)\n    # and this has pointers to containers and facilitates actual sampling\n    blocks = [\n        [\n            BiBlock(sp, br, ρ, i==length(block_ranges), num_steps)\n            for (i,br) in enumerate(block_ranges)\n        ] for block_ranges in block_layout\n    ]\n\n    paths = []\n\n    N = length(blocks)\n    # MCMC\n    for i in 1:num_steps\n        for B in blocks\n            # freeze terminal points of blocks to be artificial observations\n            GP.set_obs!.(B)\n            # recompute the guiding term only on the \"accepted\" laws `bb.b.PP`\n            (bb->recompute_guiding_term!(bb.b)).(B)\n            # recompute the Wiener path\n            find_W_for_X!.(B)\n            # re-evaluate the log-likelihood\n            ( bb->(bb.b.ll = loglikhd(bb.b)) ).(B)\n            # impute a path\n            draw_proposal_path!.(B)\n            # Metropolis–Hastings accept/reject step\n            accept_reject_proposal_path!.(B, i)\n\n            # progress message\n            if i % 100 == 0\n                println(\n                    \"$i. ll=$(ll_of_accepted.(B, i)), acceptance rate: \",\n                    \"$( map(bb->accpt_rate(bb, (i-99):i), B) )\"\n                )\n            end\n        end\n\n        # save intermediate path for plotting\n        i % 400 == 0 && append!(paths, [deepcopy(sp.u.XX)])\n    end\n    paths\nend","category":"page"},{"location":"manual/biblock/#Results-2","page":"BiBlock","title":"Results","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"@inline DD.nonhypo(x, P::FitzHughNagumo) = x[SVector{1,Int64}(2)]\n@inline DD.nonhypo_σ(t::Float64, x, P::FitzHughNagumo) = SMatrix{1,1,Float64}(P.σ)\npaths = simple_smoothing_with_blocking(\n    FitzHughNagumoAux, recording, 0.001, FitzHughNagumoAux,\n    [[1:25,26:75,76:100],[1:50, 51:100]];\n    ρ=0.96, num_steps=10^4\n)","category":"page"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"Same plotting routines as above yield: (Image: smoothing_with_blocking_results)","category":"page"},{"location":"manual/biblock/#Example:-inference-with-no-blocking-1","page":"BiBlock","title":"Example: inference with no blocking","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"","category":"page"},{"location":"manual/biblock/#Example:-inference-with-blocking-1","page":"BiBlock","title":"Example: inference with blocking","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"","category":"page"},{"location":"manual/sampling_unit/#The-smallest-sampling-unit:-SamplingUnit-1","page":"SamplingUnit","title":"The smallest sampling unit: SamplingUnit","text":"","category":"section"},{"location":"manual/sampling_unit/#","page":"SamplingUnit","title":"SamplingUnit","text":"","category":"page"},{"location":"manual/sampling_unit/#","page":"SamplingUnit","title":"SamplingUnit","text":"The struct","category":"page"},{"location":"manual/sampling_unit/#","page":"SamplingUnit","title":"SamplingUnit","text":"DiffusionMCMCTools.SamplingUnit","category":"page"},{"location":"manual/sampling_unit/#DiffusionMCMCTools.SamplingUnit","page":"SamplingUnit","title":"DiffusionMCMCTools.SamplingUnit","text":"struct SamplingUnit{TGP,TGPb,TW,TWn,TX}\n    PP::Vector{TGP}\n    PPb::Vector{TGPb}\n    WW::Vector{TW}\n    Wnr::TWn\n    XX::Vector{TX}\nend\n\nSmallest composite unit with containers needed for sampling of conditioned diffusions via Guided Proposals.\n\nFields\n\n\n\nPP: a vector of GuidProp\nPPb: a vector of GuidProp that can be used in a blocking schemes as        GuidProps on terminal subintervals\nWW: a vector of containers for sampled Wiener process\nWnr: a flag for sampling Wiener processes\nXX: a vector of containers for a sampled process\nSamplingUnit(       auxlaws, recording, tts, args=tuple();       auxlawsblocking=auxlaws, artificialnoise=1e-11,       solverchoice_blocking=args   )\n\nBase constructor.\n\nArguments\n\n\n\naux_laws:\nrecording:\ntts:\nargs:\naux_laws_blocking:\nartificial_noise:\nsolver_choice_blocking:\n\n\n\n\n\n","category":"type"},{"location":"manual/sampling_unit/#","page":"SamplingUnit","title":"SamplingUnit","text":"is the main building block of all remaining units implemented in this package. It has a couple of methods implemented for it:","category":"page"},{"location":"manual/sampling_unit/#","page":"SamplingUnit","title":"SamplingUnit","text":"DiffusionMCMCTools.recompute_guiding_term!(u::DiffusionMCMCTools.SamplingUnit)\nDiffusionMCMCTools.loglikhd(u::DiffusionMCMCTools.SamplingUnit)\nDiffusionMCMCTools.draw_proposal_path!(u::DiffusionMCMCTools.SamplingUnit)","category":"page"},{"location":"manual/sampling_unit/#GuidedProposals.recompute_guiding_term!-Tuple{SamplingUnit}","page":"SamplingUnit","title":"GuidedProposals.recompute_guiding_term!","text":"GP.recompute_guiding_term!(u::SamplingUnit)\n\nRecompute the guiding term assuming u.PP is a vector with guided proposal laws\n\n\n\n\n\n","category":"method"},{"location":"manual/sampling_unit/#GuidedProposals.loglikhd-Tuple{SamplingUnit}","page":"SamplingUnit","title":"GuidedProposals.loglikhd","text":"GP.loglikhd(u::SamplingUnit)\n\nReturn log-likelihood evaluated at a sampled path\n\n\n\n\n\n","category":"method"},{"location":"manual/sampling_unit/#DiffusionMCMCTools.draw_proposal_path!-Tuple{SamplingUnit}","page":"SamplingUnit","title":"DiffusionMCMCTools.draw_proposal_path!","text":"draw_proposal_path!(u::SamplingUnit)\n\nSample a proposal path, compute log-likelihood along the way. Assumes u.XX[1].x[1] is a starting point. No preconditioned Crank-Nicolson scheme is used.\n\n\n\n\n\n","category":"method"},{"location":"manual/sampling_unit/#","page":"SamplingUnit","title":"SamplingUnit","text":"However, because it does not contain proposal-accepted pair it is rarely used on its own for sampling. Instead, it most often appears as a member of other struct.","category":"page"},{"location":"manual/sampling_pair/#A-pairing-of-two-SamplingUnits-1","page":"SamplingPair","title":"A pairing of two SamplingUnits","text":"","category":"section"},{"location":"manual/sampling_pair/#","page":"SamplingPair","title":"SamplingPair","text":"","category":"page"},{"location":"manual/sampling_pair/#","page":"SamplingPair","title":"SamplingPair","text":"Defines all main containers for an entire single recording for a smoothing or inference problem.","category":"page"},{"location":"manual/sampling_pair/#","page":"SamplingPair","title":"SamplingPair","text":"DiffusionMCMCTools.SamplingPair","category":"page"},{"location":"manual/sampling_pair/#DiffusionMCMCTools.SamplingPair","page":"SamplingPair","title":"DiffusionMCMCTools.SamplingPair","text":"struct SamplingPair{TGP,TGPb,TW,TWn,TX}\n    u::SamplingUnit{TGP,TGPb,TW,TWn,TX}\n    u°::SamplingUnit{TGP,TGPb,TW,TWn,TX}\nend\n\nA pairing of two SamplingUnits and can be used for smoothing or inference problems.\n\nSamplingPair(\n    aux_laws, recording, tts, args=tuple();\n    aux_laws_blocking=aux_laws, artificial_noise=1e-11,\n    solver_choice_blocking=args\n)\n\nBase constructor.\n\nArguments\n\n\n\naux_laws:\nrecording:\ntts:\nargs:\naux_laws_blocking:\nartificial_noise:\nsolver_choice_blocking:\n\n\n\n\n\n","category":"type"},{"location":"manual/sampling_pair/#","page":"SamplingPair","title":"SamplingPair","text":"note: Note\nIn practice all sampling is done with a BiBlock that looks at sections of a SamplingPair and never through SamplingPair directly. Even when no blocking is needed, it should still be done by defining a BiBlock that simply looks at the entire SamplingPair.","category":"page"},{"location":"#DiffusionMCMCTools-1","page":"Home","title":"DiffusionMCMCTools","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Utility package for performing MCMC sampling for diffusion processes.","category":"page"}]
}
