var documenterSearchIndex = {"docs":
[{"location":"module_index/#","page":"Index","title":"Index","text":"CurrentModule = DiffusionMCMCTools","category":"page"},{"location":"module_index/#DiffusionMCMCTools-1","page":"Index","title":"DiffusionMCMCTools","text":"","category":"section"},{"location":"module_index/#","page":"Index","title":"Index","text":"","category":"page"},{"location":"module_index/#","page":"Index","title":"Index","text":"Modules = [DiffusionMCMCTools]","category":"page"},{"location":"module_index/#DiffusionDefinition.set_parameters!","page":"Index","title":"DiffusionDefinition.set_parameters!","text":"DD.set_parameters!(\n    bb::BiBlock,\n    θ°,\n    pnames,\n    critical_change=is_critical_update(bb, pnames)\n)\n\nSet the parameters in bb.b°.PP and bb.b°.P_last to θ° and make sure that all other parameters are shared with bb.b.PP and bb.b.P_last.\n\n\n\n\n\n","category":"function"},{"location":"module_index/#DiffusionMCMCTools._eql_PP!-NTuple{4,Any}","page":"Index","title":"DiffusionMCMCTools._eql_PP!","text":"_eql_PP!(PP, PP°, var_p_names, var_p_aux_names)\n\nGo through all GuidProp structs in  PP and PP° and make sure that the parameters listed in var_p_names and var_p_aux_names agree. Equalize them if they do not. var_p_names should list all parameter names from the target law and var_p_aux_names should list all parameters from the auxiliary law.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#DiffusionMCMCTools.init_paths!-NTuple{5,Any}","page":"Index","title":"DiffusionMCMCTools.init_paths!","text":"init_paths!(P, WW, Wnr, XX, x0_prior)\n\nSample paths of guided proposals without using the preconditioned Crank–Nicolson scheme.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.equalize_law_params!-Tuple{BiBlock,Any}","page":"Index","title":"GuidedProposals.equalize_law_params!","text":"GP.equalize_law_params!(bb::BiBlock, pnames)\n\nMake sure that in the corresponding pairs of GuidProp structs of both bb.b and bb.b°, the variable parameters of each law are the same. If not, then set the ones in bb.b° to be the same as the ones in bb.b.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.equalize_obs_params!-Tuple{BiBlock}","page":"Index","title":"GuidedProposals.equalize_obs_params!","text":"GP.equalize_obs_params!(bb::BiBlock)\n\nMake sure that in the corresponding pairs of GuidProp structs of both bb.b and bb.b°, the parameters θ of the obs fields are the same. If not, then set the ones in bb.b° to be the same as the ones in bb.b.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.is_critical_update-Tuple{BiBlock,Any}","page":"Index","title":"GuidedProposals.is_critical_update","text":"is_critical_update(bb::BiBlock, pnames)\n\nVerify whether the update characterized by a list of parameter names stored in pnames is critical in a sense of prompting for recomputation of the guiding term.\n\n\n\n\n\n","category":"method"},{"location":"manual/block/#Block-1","page":"Block","title":"Block","text":"","category":"section"},{"location":"manual/block/#","page":"Block","title":"Block","text":"","category":"page"},{"location":"manual/block/#","page":"Block","title":"Block","text":"A smallest unit that is needed for blocking.","category":"page"},{"location":"manual/block/#","page":"Block","title":"Block","text":"DiffusionMCMCTools.Block","category":"page"},{"location":"manual/block/#DiffusionMCMCTools.Block","page":"Block","title":"DiffusionMCMCTools.Block","text":"mutable struct Block{L,TGP,TGPl,TW,TWn,TX}\n    PP::TVIEW{TGP}\n    P_last::TVIEW{TGPl} # view into a single element\n    WW::TVIEW{TW}\n    Wnr::TWn\n    XX::TVIEW{TX}\n    ll::Float64\n    ll_history::Vector{Float64}\nend\n\nThe smallest \"containerless\" unit that provides a view into SamplingUnit restricted to a range i:j of a block. L is an important flag that indicates whether it is a terminal block or not.\n\nFields\n\n\n\nPP: a vector of views into relevant GuidProp\nP_last: a view into a single (or none) GuidProp corresponding to the           terminal sub-interval.\nWW: a vector of views into containers for sampled Wiener process\nWnr: a flag for sampling Wiener processes\nXX: a vector of views into containers for a sampled process\nll: a placeholder for computed log-likelihood\nll_history: a history of computed log-likelihoods (useful for MCMC)\n\nfunction Block(\n    u::SamplingUnit,\n    range::UnitRange{Int64},\n    last_block=false,\n    ll_hist_len=0\n)\n\nBase constructor.\n\n\n\n\n\n","category":"type"},{"location":"manual/block/#","page":"Block","title":"Block","text":"It is rarely used on its own. Instead, it is used mainly as a building block of other, composite units. Nevertheless, there are a couple of useful functions implemented for it:","category":"page"},{"location":"manual/block/#","page":"Block","title":"Block","text":"DiffusionMCMCTools.set_ll!(b::DiffusionMCMCTools.Block, i::Int, v)\nDiffusionMCMCTools.save_ll!(b::DiffusionMCMCTools.Block, i::Int)\nDiffusionMCMCTools.recompute_guiding_term!(b::DiffusionMCMCTools.Block)\nDiffusionMCMCTools.find_W_for_X!(b::DiffusionMCMCTools.Block)\nDiffusionMCMCTools.loglikhd(b::DiffusionMCMCTools.Block)\nDiffusionMCMCTools.recompute_path!(b::DiffusionMCMCTools.Block, WW=b.WW; skip=0)","category":"page"},{"location":"manual/block/#DiffusionMCMCTools.set_ll!-Tuple{Block,Int64,Any}","page":"Block","title":"DiffusionMCMCTools.set_ll!","text":"set_ll!(b::Block, i::Int, v)\n\nSet the internal log-likelihood history field b.ll_history[i] with a value v\n\n\n\n\n\n","category":"method"},{"location":"manual/block/#DiffusionMCMCTools.save_ll!-Tuple{Block,Int64}","page":"Block","title":"DiffusionMCMCTools.save_ll!","text":"save_ll!(b::Block, i::Int)\n\nCommit the current log-likelihood field ll to history b.ll_history at index i.\n\n\n\n\n\n","category":"method"},{"location":"manual/block/#GuidedProposals.recompute_guiding_term!-Tuple{Block}","page":"Block","title":"GuidedProposals.recompute_guiding_term!","text":"GP.recompute_guiding_term!(b::Block)\n\nRecompute the guiding term.\n\n\n\n\n\n","category":"method"},{"location":"manual/block/#DiffusionMCMCTools.find_W_for_X!-Tuple{Block}","page":"Block","title":"DiffusionMCMCTools.find_W_for_X!","text":"find_W_for_X!(b::Block)\n\nCompute the Wiener process b.WW that is needed for obtaining path b.XX under the law stored in b.\n\n\n\n\n\n","category":"method"},{"location":"manual/block/#GuidedProposals.loglikhd-Tuple{Block}","page":"Block","title":"GuidedProposals.loglikhd","text":"GP.loglikhd(b::Block)\n\nCompute the log-likelihood evaluated at a sampled path.\n\n\n\n\n\n","category":"method"},{"location":"manual/block/#DiffusionMCMCTools.recompute_path!","page":"Block","title":"DiffusionMCMCTools.recompute_path!","text":"recompute_path!(b::Block, WW=b.WW; skip=0)\n\nRecompute the path b.XX for a given wiener process WW.\n\n\n\n\n\n","category":"function"},{"location":"manual/biblock/#BiBlock-1","page":"BiBlock","title":"BiBlock","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"","category":"page"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"A composite unit that represents a block. It can be used for sampling on a block in a setting of smoothing or inference.","category":"page"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"DiffusionMCMCTools.BiBlock","category":"page"},{"location":"manual/biblock/#DiffusionMCMCTools.BiBlock","page":"BiBlock","title":"DiffusionMCMCTools.BiBlock","text":"mutable struct BiBlock{L,TGP,TGPl,TW,TWn,TX}\n    b::Block{L,TGP,TGPl,TW,TWn,TX}\n    b°::Block{L,TGP,TGPl,TW,TWn,TX}\n    ρ::Float64\n    accpt_history::Vector{Bool}\nend\n\nComposite unit that allows for sampling of a single block. It provides two Blocks: one proposal b°, one accepted b that can be used for smoothing or inference problems. ρ is a memory parameter of the preconditioned Crank-Nicolson scheme and accpt_history stores the history of accept/reject decisions (useful for MCMC).\n\nfunction BiBlock(\n    sp::SamplingPair,\n    range::UnitRange{Int64},\n    ρ=0.0,\n    last_block=false,\n    ll_hist_len=0\n)\n\nBase constructor.\n\n\n\n\n\n","category":"type"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"There are many functions implemented for it.","category":"page"},{"location":"manual/biblock/#Imputation-of-paths-1","page":"BiBlock","title":"Imputation of paths","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"","category":"page"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"DiffusionMCMCTools.draw_proposal_path!(bb::DiffusionMCMCTools.BiBlock)","category":"page"},{"location":"manual/biblock/#DiffusionMCMCTools.draw_proposal_path!-Tuple{BiBlock}","page":"BiBlock","title":"DiffusionMCMCTools.draw_proposal_path!","text":"draw_proposal_path!(bb::BiBlock)\n\nSample a proposal path, compute log-likelihood along the way. Assumes bb.b.XX[1].x[1] is a starting point. Uses preconditioned Crank-Nicolson scheme with memory parameter set as bb.ρ.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#Accept/reject-decision-in-an-MCMC-setting-1","page":"BiBlock","title":"Accept/reject decision in an MCMC setting","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"","category":"page"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"DiffusionMCMCTools.accept_reject_proposal_path!(bb::DiffusionMCMCTools.BiBlock, mcmciter)","category":"page"},{"location":"manual/biblock/#DiffusionMCMCTools.accept_reject_proposal_path!-Tuple{BiBlock,Any}","page":"BiBlock","title":"DiffusionMCMCTools.accept_reject_proposal_path!","text":"accept_reject_proposal_path!(bb::BiBlock, mcmciter)\n\nAccept/reject decision of the Metropolis-Hastings algorithm for the step of path imputation.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#Adjustments-made-after-the-accept-reject-decision-(regardless-of-what-it-was)-1","page":"BiBlock","title":"Adjustments made after the accept-reject decision (regardless of what it was)","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"","category":"page"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"DiffusionMCMCTools.set_accepted!(bb::DiffusionMCMCTools.BiBlock, i::Int, v)","category":"page"},{"location":"manual/biblock/#DiffusionMCMCTools.set_accepted!-Tuple{BiBlock,Int64,Any}","page":"BiBlock","title":"DiffusionMCMCTools.set_accepted!","text":"set_accepted!(bb::BiBlock, i::Int, v)\n\nCommit the accept/reject decision v to acceptance history of BiBlock b at the position i.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#Adjustments-to-the-containers-in-case-of-**acceptance**-of-proposals:-1","page":"BiBlock","title":"Adjustments to the containers in case of acceptance of proposals:","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"","category":"page"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"DiffusionMCMCTools.swap_paths!(bb::DiffusionMCMCTools.BiBlock)\nDiffusionMCMCTools.swap_XX!(bb::DiffusionMCMCTools.BiBlock)\nDiffusionMCMCTools.swap_WW!(bb::DiffusionMCMCTools.BiBlock)\nDiffusionMCMCTools.swap_PP!(bb::DiffusionMCMCTools.BiBlock)\nDiffusionMCMCTools.swap_ll!(bb::DiffusionMCMCTools.BiBlock)","category":"page"},{"location":"manual/biblock/#DiffusionMCMCTools.swap_paths!-Tuple{BiBlock}","page":"BiBlock","title":"DiffusionMCMCTools.swap_paths!","text":"swap_paths!(bb::BiBlock)\n\nSwap XX and WW containers between proposal-acceptance pair.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#DiffusionMCMCTools.swap_XX!-Tuple{BiBlock}","page":"BiBlock","title":"DiffusionMCMCTools.swap_XX!","text":"swap_XX!(bb::BiBlock)\n\nSwap XX containers between proposal-acceptance pair.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#DiffusionMCMCTools.swap_WW!-Tuple{BiBlock}","page":"BiBlock","title":"DiffusionMCMCTools.swap_WW!","text":"swap_WW!(bb::BiBlock)\n\nSwap WW containers between proposal-acceptance pair.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#DiffusionMCMCTools.swap_PP!-Tuple{BiBlock}","page":"BiBlock","title":"DiffusionMCMCTools.swap_PP!","text":"swap_PP!(bb::BiBlock)\n\nSwap PP containers (including PP_last) between proposal-acceptance pair.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#DiffusionMCMCTools.swap_ll!-Tuple{BiBlock}","page":"BiBlock","title":"DiffusionMCMCTools.swap_ll!","text":"swap_ll!(bb::BiBlock)\n\nSwap ll containers between proposal-acceptance pair.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#Setting-up-a-block-1","page":"BiBlock","title":"Setting up a block","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"","category":"page"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"DiffusionMCMCTools.set_obs!(bb::DiffusionMCMCTools.BiBlock)\nDiffusionMCMCTools.recompute_guiding_term!(bb::DiffusionMCMCTools.BiBlock)\nDiffusionMCMCTools.find_W_for_X!(bb::DiffusionMCMCTools.BiBlock)","category":"page"},{"location":"manual/biblock/#GuidedProposals.set_obs!-Tuple{BiBlock}","page":"BiBlock","title":"GuidedProposals.set_obs!","text":"GP.set_obs!(bb::BiBlock)\n\nFreeze an artificial observation at the terminal point of the block. For a terminal block nothing is done.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#GuidedProposals.recompute_guiding_term!-Tuple{BiBlock}","page":"BiBlock","title":"GuidedProposals.recompute_guiding_term!","text":"GP.recompute_guiding_term!(bb::BiBlock)\n\nRecompute the guiding terms of both the proposal and the accepted laws.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#DiffusionMCMCTools.find_W_for_X!-Tuple{BiBlock}","page":"BiBlock","title":"DiffusionMCMCTools.find_W_for_X!","text":"find_W_for_X!(bb::BiBlock)\n\nFind the Wiener process bb.b.WW that reconstructs path bb.b.XX under the accepted law bb.b.PP (possibly including bb.b.P_last).\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#Utility-1","page":"BiBlock","title":"Utility","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"","category":"page"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"DiffusionMCMCTools.ll_of_accepted(bb::DiffusionMCMCTools.BiBlock, i)\nDiffusionMCMCTools.accpt_rate(bb::DiffusionMCMCTools.BiBlock, range)","category":"page"},{"location":"manual/biblock/#DiffusionMCMCTools.ll_of_accepted-Tuple{BiBlock,Any}","page":"BiBlock","title":"DiffusionMCMCTools.ll_of_accepted","text":"ll_of_accepted(bb::BiBlock, i)\n\nReturn the log-likelihood of the path that was accepted at the ith iteration.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#DiffusionMCMCTools.accpt_rate-Tuple{BiBlock,Any}","page":"BiBlock","title":"DiffusionMCMCTools.accpt_rate","text":"accpt_rate(bb::BiBlock, range)\n\nCompute the acceptance rate over the range of MCMC accept/reject history.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#Setting-parameters-1","page":"BiBlock","title":"Setting parameters","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"","category":"page"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"DiffusionMCMCTools.set_proposal_law!(\n      bb::DiffusionMCMCTools.BiBlock,\n      θ°,\n      pnames,\n      critical_change=DiffusionMCMCTools.is_critical_update(bb, pnames),\n      skip=0\n  )","category":"page"},{"location":"manual/biblock/#DiffusionMCMCTools.set_proposal_law!","page":"BiBlock","title":"DiffusionMCMCTools.set_proposal_law!","text":"set_proposal_law!(\n    bb::BiBlock,\n    θ°,\n    pnames,\n    critical_change=GP.is_critical_update(bb, pnames),\n    skip=0\n)\n\nSet the parameters in bb.b°.PP and bb.b°.P_last to θ° and make sure that all other parameters are shared with bb.b.PP and bb.b.P_last. Recompute the guiding term if needed, and then, compute the proposal trajectory bb.b°.XX for the proposal point θ°.\n\n\n\n\n\n","category":"function"},{"location":"manual/biblock/#Example:-smoothing-with-no-blocking-1","page":"BiBlock","title":"Example: smoothing with no blocking","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"","category":"page"},{"location":"manual/biblock/#Set-up-1","page":"BiBlock","title":"Set-up","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"using GuidedProposals, DiffusionDefinition, ObservationSchemes, DiffusionMCMCTools\nconst GP = GuidedProposals\nconst DD = DiffusionDefinition\nconst OBS = ObservationSchemes\nconst dMCMCt = DiffusionMCMCTools\n\nusing StaticArrays, Random, Plots\n\n# seed used for this tutorial\nRandom.seed!(100)\n\n@load_diffusion FitzHughNagumo\nθ = [0.1, -0.8, 1.5, 0.0, 0.3]\nP = FitzHughNagumo(θ...)\ntt, y1 = 0.0:0.0001:10.0, @SVector [-0.9, -1.0]\nX = rand(P, tt, y1)\nobs_scheme = ObsScheme(\n    LinearGsnObs(\n        0.0, (@SVector [0.0]);\n        L=(@SMatrix [1.0 0.0]),\n        Σ=(@SMatrix [0.01])\n    )\n)\ndata = collect(obs_scheme, X, 1000)\nrecording = build_recording(P, data, 0.0, KnownStartingPt(y1))\n\nplot(X, Val(:vs_time), size=(800, 300))\nscatter!(map(x->x.t, data), map(x->x.obs[1], data), label=\"data\")","category":"page"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"(Image: data)","category":"page"},{"location":"manual/biblock/#The-algorithm-1","page":"BiBlock","title":"The algorithm","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"function simple_smoothing(AuxLaw, recording, dt; ρ=0.5, num_steps=10^4)\n    tts = OBS.setup_time_grids(recording, dt, standard_guid_prop_time_transf)\n    # this object contains containers\n    sp = SamplingPair(AuxLaw, recording, tts)\n    # and this has pointers to containers and facilitates actual sampling\n    bb = BiBlock(sp, 1:length(recording.obs), ρ, true, num_steps)\n    bb.b.ll = loglikhd(bb.b)\n    paths = []\n\n    # MCMC\n    for i in 1:num_steps\n        # impute a path\n        draw_proposal_path!(bb)\n        # Metropolis–Hastings accept/reject step\n        accept_reject_proposal_path!(bb, i)\n\n        # progress message\n        if i % 100 == 0\n            println(\n                \"$i. ll=$(ll_of_accepted(bb, i)), acceptance rate: \",\n                \"$(sum(bb.accpt_history[(i-99):i])/100)\"\n            )\n        end\n\n        # save intermediate path for plotting\n        i % 400 == 0 && append!(paths, [deepcopy(bb.b.XX)])\n    end\n    paths\nend\n\n@load_diffusion FitzHughNagumoAux\npaths = simple_smoothing(\n    FitzHughNagumoAux, recording, 0.001; ρ=0.96, num_steps=10^4\n)","category":"page"},{"location":"manual/biblock/#Results-1","page":"BiBlock","title":"Results","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"function glue_paths(XX)\n    XX_glued = trajectory(\n        glue_containers( map(x->x.t, XX) ),\n        glue_containers( map(x->x.x, XX) ),\n    )\nend\n\nfunction glue_containers(xs)\n    glued_xs = collect(Iterators.flatten(map(x->x[1:end-1], xs)))\n    append!(glued_xs, [xs[end][end]])\n    glued_xs\nend\n\nconvenient_paths = glue_paths.(paths)\n\ncol = [\"#581845\", \"#900C3F\", \"#C70039\", \"#FF5733\", \"#FFC300\"]\n\np = plot(size=(1000, 500))\nfor path in convenient_paths\n\tplot!(p, path, Val(:vs_time), alpha=0.4, label=\"\", color=[col[3] col[1]])\nend\nplot!(X, Val(:vs_time), color=[col[5] col[4]], linewidth=[3 0.5], label=[\"underlying X₁\" \"underlying X₂\"])\nscatter!(p, map(x->x.t, data), map(x->x.obs[1], data), label=\"data\", markercolor=col[5])\ndisplay(p)","category":"page"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"(Image: smoothing)","category":"page"},{"location":"manual/biblock/#Example:-smoothing-with-blocking-1","page":"BiBlock","title":"Example: smoothing with blocking","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"","category":"page"},{"location":"manual/biblock/#Set-up-2","page":"BiBlock","title":"Set-up","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"Same as above","category":"page"},{"location":"manual/biblock/#The-algorithm-2","page":"BiBlock","title":"The algorithm","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"function simple_smoothing_with_blocking(\n        AuxLaw, recording, dt, AuxLawBlocking, block_layout;\n        ρ=0.5, num_steps=10^4\n    )\n    tts = OBS.setup_time_grids(recording, dt, standard_guid_prop_time_transf)\n    # this object contains containers\n    sp = SamplingPair(AuxLaw, recording, tts)\n    # and this has pointers to containers and facilitates actual sampling\n    blocks = [\n        [\n            BiBlock(sp, br, ρ, i==length(block_ranges), num_steps)\n            for (i,br) in enumerate(block_ranges)\n        ] for block_ranges in block_layout\n    ]\n\n    paths = []\n\n    N = length(blocks)\n    # MCMC\n    for i in 1:num_steps\n        for B in blocks\n            # freeze terminal points of blocks to be artificial observations\n            GP.set_obs!.(B)\n            # recompute the guiding term only on the \"accepted\" laws `bb.b.PP`\n            (bb->recompute_guiding_term!(bb.b)).(B)\n            # recompute the Wiener path\n            find_W_for_X!.(B)\n            # re-evaluate the log-likelihood\n            ( bb->(bb.b.ll = loglikhd(bb.b)) ).(B)\n            # impute a path\n            draw_proposal_path!.(B)\n            # Metropolis–Hastings accept/reject step\n            accept_reject_proposal_path!.(B, i)\n\n            # progress message\n            if i % 100 == 0\n                println(\n                    \"$i. ll=$(ll_of_accepted.(B, i)), acceptance rate: \",\n                    \"$( map(bb->accpt_rate(bb, (i-99):i), B) )\"\n                )\n            end\n        end\n\n        # save intermediate path for plotting\n        i % 400 == 0 && append!(paths, [deepcopy(sp.u.XX)])\n    end\n    paths\nend","category":"page"},{"location":"manual/biblock/#Results-2","page":"BiBlock","title":"Results","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"@inline DD.nonhypo(x, P::FitzHughNagumo) = x[SVector{1,Int64}(2)]\n@inline DD.nonhypo_σ(t::Float64, x, P::FitzHughNagumo) = SMatrix{1,1,Float64}(P.σ)\npaths = simple_smoothing_with_blocking(\n    FitzHughNagumoAux, recording, 0.001, FitzHughNagumoAux,\n    [[1:25,26:75,76:100],[1:50, 51:100]];\n    ρ=0.96, num_steps=10^4\n)","category":"page"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"Same plotting routines as above yield: (Image: smoothing_with_blocking_results)","category":"page"},{"location":"manual/biblock/#Example:-inference-with-no-blocking-1","page":"BiBlock","title":"Example: inference with no blocking","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"","category":"page"},{"location":"manual/biblock/#Set-up-3","page":"BiBlock","title":"Set up","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"Same as before","category":"page"},{"location":"manual/biblock/#The-algorithm-3","page":"BiBlock","title":"The algorithm","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"customkernel(θ, scale=0.1) = θ .+ 2.0*scale*(rand()-0.5)\n\n#=\n    NOTE: this will appear to be completely unnecessary and coming out of the\n    blue if you are not considering more complicated settings of mixed effect\n    models. Looking up ahead into the definition of ... should be helpful if\n    you want to understand what the function below is aiming to do.\n\n    In here, we are just creating the most basic struture that is needed for\n    setting parameters. It can be much more complex if blocking, multiple\n    updates and/or mixed effect models were used.\n=#\n#↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓\n_build_struct(N, args...) = (\n    var = tuple(),\n    var_aux = fill(tuple(), N),\n    updt = tuple(args...),\n    updt_aux = fill(tuple(args...), N),\n    updt_obs = fill(tuple(), N),\n)\n\nfunction simple_name_structure(pname::Symbol, num_obs)\n    pnames = (\n        PP = _build_struct(num_obs, (1=>pname)),\n        P_last = _build_struct(0), # was num_obs\n        P_excl = _build_struct(0),\n    )\nend\n#↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑\n\nfunction accept_reject_proposal_param!(bb, mcmciter, θ, θ°)\n    accepted = rand(Exponential(1.0)) > -(bb.b°.ll - bb.b.ll)\n    accepted && swap_XX!(bb)\n    accepted && swap_PP!(bb)\n    save_ll!(bb.b, mcmciter)\n    save_ll!(bb.b°, mcmciter)\n    accepted && swap_ll!(bb)\n    accepted, copy(accepted ? θ° : θ)\nend\n\nfunction simple_inference(AuxLaw, recording, dt, _θ; ϵ=0.3, ρ=0.5, num_steps=10^4)\n    # making sure that things are in order...\n    _pname = collect(keys(_θ))\n    # for simplicity restrict to inference for a single param\n    @assert length(_pname) == 1\n    pname = first(_pname)\n    θ = collect(values(_θ))\n\n    # setting the initial guess θ inside the recording\n    OBS.set_parameters!(recording, _θ)\n\n    # setting up containers\n    num_obs = length(recording.obs)\n    tts = OBS.setup_time_grids(recording, dt, standard_guid_prop_time_transf)\n    sp = SamplingPair(AuxLaw, recording, tts)\n    bb = BiBlock(sp, 1:num_obs, ρ, true, num_steps)\n    name_struct = simple_name_structure(pname, num_obs)\n\n    bb.b.ll = loglikhd(bb.b)\n    paths = []\n\n    θθ = [θ]\n    a_h = Bool[]\n\n    for i in 1:num_steps\n        draw_proposal_path!(bb)\n        accept_reject_proposal_path!(bb, i)\n\n        θ° = customkernel(θ, ϵ)\n        set_proposal_law!(bb, θ°, name_struct, true)\n\n        accpt, θ = accept_reject_proposal_param!(bb, i, θ, θ°)\n        push!(θθ, θ)\n        push!(a_h, accpt)\n\n        # progress message\n        if i % 100 == 0\n            println(\n                \"$i. ll=$(ll_of_accepted(bb, i)), \",\n                \"imp a-r: \",\n                \" $(accpt_rate(bb, (i-99):i)), \",\n                \"updt a-r: \",\n                \"$(sum(a_h[(i-99):i])/100).\"\n            )\n        end\n\n        # save intermediate path for plotting\n        i % 400 == 0 && append!(paths, [deepcopy(sp.u.XX)])\n    end\n    paths, θθ\nend","category":"page"},{"location":"manual/biblock/#Results-3","page":"BiBlock","title":"Results","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"plot(getindex.(θθ, 1))","category":"page"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"(Image: inference_chain)","category":"page"},{"location":"manual/biblock/#Example:-inference-with-blocking-1","page":"BiBlock","title":"Example: inference with blocking","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"","category":"page"},{"location":"manual/biblock/#Set-up-4","page":"BiBlock","title":"Set up","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"Same as before","category":"page"},{"location":"manual/biblock/#The-algorithm-4","page":"BiBlock","title":"The algorithm","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"#↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓\nfunction simple_name_structure_not_last(pname::Symbol, num_obs)\n    pnames = (\n        PP = _build_struct(num_obs-1, (1=>pname)),\n        P_last = _build_struct(1, (1=>pname)),\n        P_excl = _build_struct(1, (1=>pname)),\n    )\nend\n\nfunction simple_name_structure_blocking(pname::Symbol, block_layout)\n    map(block_layout) do block_set\n        map(enumerate(block_set)) do (i, block)\n            (\n                i == length(block_set) ?\n                simple_name_structure(pname, length(block)) :\n                simple_name_structure_not_last(pname, length(block))\n            )\n        end\n    end\nend\n#↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑\n\nfunction accept_reject_proposal_param!(B::AbstractArray{<:BiBlock}, mcmciter, θ, θ°)\n    accepted = rand(Exponential(1.0)) > mapreduce(bb->-(bb.b°.ll - bb.b.ll),+,B)\n    accepted && swap_XX!.(B)\n    accepted && swap_PP!.(B)\n    (bb->save_ll!(bb.b, mcmciter)).(B)\n    (bb->save_ll!(bb.b°, mcmciter)).(B)\n    accepted && swap_ll!.(B)\n    accepted, copy(accepted ? θ° : θ)\nend\n\n\nfunction simple_inference_with_blocking(\n        AuxLaw, recording, dt, AuxLawBlocking, block_layout, _θ;\n        ϵ=0.3, ρ=0.5, num_steps=10^4\n    )\n    # making sure that things are in order...\n    _pname = collect(keys(_θ))\n    # for simplicity restrict to inference for a single param\n    @assert length(_pname) == 1\n    pname = first(_pname)\n    θ = collect(values(_θ))\n\n    # setting the initial guess θ inside the recording\n    OBS.set_parameters!(recording, _θ)\n\n    # setting up containers\n    tts = OBS.setup_time_grids(recording, dt, standard_guid_prop_time_transf)\n    sp = SamplingPair(AuxLaw, recording, tts)\n    blocks = [\n        [\n            BiBlock(sp, br, ρ, i==length(block_ranges), num_steps)\n            for (i,br) in enumerate(block_ranges)\n        ] for block_ranges in block_layout\n    ]\n    name_struct = simple_name_structure_blocking(pname, block_layout)\n\n    paths = []\n\n    θθ = [θ]\n    a_h = Bool[]\n\n    # MCMC\n    for i in 1:num_steps\n        for B in blocks\n            GP.set_obs!.(B)\n            (bb->recompute_guiding_term!(bb.b)).(B)\n            find_W_for_X!.(B)\n            ( bb->(bb.b.ll = loglikhd(bb.b)) ).(B)\n            draw_proposal_path!.(B)\n            accept_reject_proposal_path!.(B, i)\n\n            # progress message\n            if i % 100 == 0\n                println(\n                    \"$i. ll=$(ll_of_accepted.(B, i)), acceptance rate: \",\n                    \"$( map(bb->accpt_rate(bb, (i-99):i), B) )\"\n                )\n            end\n        end\n\n        θ° = customkernel(θ, ϵ)\n\n        B = blocks[end]\n        for (idx, bb) in enumerate(B)\n            set_proposal_law!(bb, θ°, name_struct[end][idx], true)\n        end\n        (bb->recompute_guiding_term!(bb.b°)).(B)\n\n        accpt, θ = accept_reject_proposal_param!(B, i, θ, θ°)\n        push!(θθ, θ)\n        push!(a_h, accpt)\n\n        if i % 100 == 0\n            println(\n                \"$i. updt a-r: \",\n                \"$(sum(a_h[(i-99):i])/100).\"\n            )\n        end\n\n        # save intermediate path for plotting\n        i % 400 == 0 && append!(paths, [deepcopy(sp.u.XX)])\n    end\n    paths, θθ\nend","category":"page"},{"location":"manual/biblock/#The-results-1","page":"BiBlock","title":"The results","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"using OrderedCollections\n\nθ = OrderedDict(:γ=>1.5)\n\nDD.var_parameter_names(::FitzHughNagumo) = (:γ,)\nDD.var_parameter_names(::FitzHughNagumoAux) = (:γ,)\n\n@load_diffusion FitzHughNagumoAux\npaths, θθ = simple_inference_with_blocking(\n    FitzHughNagumoAux, recording, 0.001, FitzHughNagumoAux,\n    [[1:25,26:75,76:100],[1:50, 51:100]], θ; ϵ=0.3, ρ=0.96, num_steps=10^4\n)\n\nplot(getindex.(θθ, 1))","category":"page"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"(Image: inference_with_blocking_chain)","category":"page"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"note: Note\nAs you can see above, BiBlock is the fundamental building block that is used for creating inference and smoothing algorithms. However, as the complexity of these algorithms grow it is useful to use some macro structures that operate on or are defined for multiple BiBlocks. This is precisely what the remaining tools defined in this package are for. Otherwise put, they aim to facilitate writing snippets of code as above in a much more compact and convenient way.","category":"page"},{"location":"manual/sampling_unit/#The-smallest-sampling-unit:-SamplingUnit-1","page":"SamplingUnit","title":"The smallest sampling unit: SamplingUnit","text":"","category":"section"},{"location":"manual/sampling_unit/#","page":"SamplingUnit","title":"SamplingUnit","text":"","category":"page"},{"location":"manual/sampling_unit/#","page":"SamplingUnit","title":"SamplingUnit","text":"The struct","category":"page"},{"location":"manual/sampling_unit/#","page":"SamplingUnit","title":"SamplingUnit","text":"DiffusionMCMCTools.SamplingUnit","category":"page"},{"location":"manual/sampling_unit/#DiffusionMCMCTools.SamplingUnit","page":"SamplingUnit","title":"DiffusionMCMCTools.SamplingUnit","text":"struct SamplingUnit{TGP,TGPb,TW,TWn,TX}\n    PP::Vector{TGP}\n    PPb::Vector{TGPb}\n    WW::Vector{TW}\n    Wnr::TWn\n    XX::Vector{TX}\nend\n\nSmallest composite unit with containers needed for sampling of conditioned diffusions via Guided Proposals.\n\nFields\n\n\n\nPP: a vector of GuidProp\nPPb: a vector of GuidProp that can be used in a blocking schemes as        GuidProps on terminal subintervals\nWW: a vector of containers for sampled Wiener process\nWnr: a flag for sampling Wiener processes\nXX: a vector of containers for a sampled process\nSamplingUnit(       auxlaws, recording, tts, args=tuple();       auxlawsblocking=auxlaws, artificialnoise=1e-11,       solverchoice_blocking=args   )\n\nBase constructor.\n\nArguments\n\n\n\naux_laws:\nrecording:\ntts:\nargs:\naux_laws_blocking:\nartificial_noise:\nsolver_choice_blocking:\n\n\n\n\n\n","category":"type"},{"location":"manual/sampling_unit/#","page":"SamplingUnit","title":"SamplingUnit","text":"is the main building block of all remaining units implemented in this package. It has a couple of methods implemented for it:","category":"page"},{"location":"manual/sampling_unit/#","page":"SamplingUnit","title":"SamplingUnit","text":"DiffusionMCMCTools.recompute_guiding_term!(u::DiffusionMCMCTools.SamplingUnit)\nDiffusionMCMCTools.loglikhd(u::DiffusionMCMCTools.SamplingUnit)\nDiffusionMCMCTools.draw_proposal_path!(u::DiffusionMCMCTools.SamplingUnit)","category":"page"},{"location":"manual/sampling_unit/#GuidedProposals.recompute_guiding_term!-Tuple{SamplingUnit}","page":"SamplingUnit","title":"GuidedProposals.recompute_guiding_term!","text":"GP.recompute_guiding_term!(u::SamplingUnit)\n\nRecompute the guiding term assuming u.PP is a vector with guided proposal laws\n\n\n\n\n\n","category":"method"},{"location":"manual/sampling_unit/#GuidedProposals.loglikhd-Tuple{SamplingUnit}","page":"SamplingUnit","title":"GuidedProposals.loglikhd","text":"GP.loglikhd(u::SamplingUnit)\n\nReturn log-likelihood evaluated at a sampled path\n\n\n\n\n\n","category":"method"},{"location":"manual/sampling_unit/#DiffusionMCMCTools.draw_proposal_path!-Tuple{SamplingUnit}","page":"SamplingUnit","title":"DiffusionMCMCTools.draw_proposal_path!","text":"draw_proposal_path!(u::SamplingUnit)\n\nSample a proposal path, compute log-likelihood along the way. Assumes u.XX[1].x[1] is a starting point. No preconditioned Crank-Nicolson scheme is used.\n\n\n\n\n\n","category":"method"},{"location":"manual/sampling_unit/#","page":"SamplingUnit","title":"SamplingUnit","text":"However, because it does not contain proposal-accepted pair it is rarely used on its own for sampling. Instead, it most often appears as a member of other struct.","category":"page"},{"location":"manual/sampling_pair/#A-pairing-of-two-SamplingUnits-1","page":"SamplingPair","title":"A pairing of two SamplingUnits","text":"","category":"section"},{"location":"manual/sampling_pair/#","page":"SamplingPair","title":"SamplingPair","text":"","category":"page"},{"location":"manual/sampling_pair/#","page":"SamplingPair","title":"SamplingPair","text":"Defines all main containers for an entire single recording for a smoothing or inference problem.","category":"page"},{"location":"manual/sampling_pair/#","page":"SamplingPair","title":"SamplingPair","text":"DiffusionMCMCTools.SamplingPair","category":"page"},{"location":"manual/sampling_pair/#DiffusionMCMCTools.SamplingPair","page":"SamplingPair","title":"DiffusionMCMCTools.SamplingPair","text":"struct SamplingPair{TGP,TGPb,TW,TWn,TX}\n    u::SamplingUnit{TGP,TGPb,TW,TWn,TX}\n    u°::SamplingUnit{TGP,TGPb,TW,TWn,TX}\nend\n\nA pairing of two SamplingUnits and can be used for smoothing or inference problems.\n\nSamplingPair(\n    aux_laws, recording, tts, args=tuple();\n    aux_laws_blocking=aux_laws, artificial_noise=1e-11,\n    solver_choice_blocking=args\n)\n\nBase constructor.\n\nArguments\n\n\n\naux_laws:\nrecording:\ntts:\nargs:\naux_laws_blocking:\nartificial_noise:\nsolver_choice_blocking:\n\n\n\n\n\n","category":"type"},{"location":"manual/sampling_pair/#","page":"SamplingPair","title":"SamplingPair","text":"note: Note\nIn practice all sampling is done with a BiBlock that looks at sections of a SamplingPair and never through SamplingPair directly. Even when no blocking is needed, it should still be done by defining a BiBlock that simply looks at the entire SamplingPair.","category":"page"},{"location":"#DiffusionMCMCTools-1","page":"Home","title":"DiffusionMCMCTools","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Utility package for performing MCMC sampling for diffusion processes.","category":"page"}]
}
