var documenterSearchIndex = {"docs":
[{"location":"module_index/","page":"Index","title":"Index","text":"CurrentModule = DiffusionMCMCTools","category":"page"},{"location":"module_index/#DiffusionMCMCTools","page":"Index","title":"DiffusionMCMCTools","text":"","category":"section"},{"location":"module_index/","page":"Index","title":"Index","text":"","category":"page"},{"location":"module_index/","page":"Index","title":"Index","text":"Modules = [DiffusionMCMCTools]","category":"page"},{"location":"module_index/#DiffusionDefinition.set_parameters!","page":"Index","title":"DiffusionDefinition.set_parameters!","text":"DD.set_parameters!(\n    bb::BiBlock,\n    θ°,\n    pnames,\n    critical_change=is_critical_update(bb, pnames)\n)\n\nSet the parameters in bb.b°.PP and bb.b°.P_last to θ° and make sure that all other parameters are shared with bb.b.PP and bb.b.P_last.\n\n\n\n\n\n","category":"function"},{"location":"module_index/#DiffusionMCMCTools._eql_PP!-NTuple{4,Any}","page":"Index","title":"DiffusionMCMCTools._eql_PP!","text":"_eql_PP!(PP, PP°, var_p_names, var_p_aux_names)\n\nGo through all GuidProp structs in  PP and PP° and make sure that the parameters listed in var_p_names and var_p_aux_names agree. Equalize them if they do not. var_p_names should list all parameter names from the target law and var_p_aux_names should list all parameters from the auxiliary law.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#DiffusionMCMCTools.accept_reject_proposal_path!-Tuple{BlockEnsemble,Any}","page":"Index","title":"DiffusionMCMCTools.accept_reject_proposal_path!","text":"accept_reject_proposal_path!(be::BlockEnsemble, mcmciter)\n\nCall accept_reject_proposal_path! separately for each recording.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#DiffusionMCMCTools.accpt_rate-Tuple{BlockEnsemble,Any}","page":"Index","title":"DiffusionMCMCTools.accpt_rate","text":"accpt_rate(be::BlockEnsemble, range)\n\nCompute the acceptance rate over the range of MCMC accept/reject history for each block for each recording.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#DiffusionMCMCTools.draw_proposal_path!-Tuple{BlockEnsemble}","page":"Index","title":"DiffusionMCMCTools.draw_proposal_path!","text":"draw_proposal_path!(be::BlockEnsemble)\n\nCall draw_proposal_path! separately for each recording\n\n\n\n\n\n","category":"method"},{"location":"module_index/#DiffusionMCMCTools.fetch_ll-Tuple{BlockEnsemble}","page":"Index","title":"DiffusionMCMCTools.fetch_ll","text":"fetch_ll(be::BlockEnsemble)\n\nRetreive the log-likelihood for all accepted paths\n\nwarning: Warning\nThe function uses only internal fields ll for this computation, which means that for the call to this function to make sense the log-likelihood must have been previously computed and stored in the field ll. If it hasn't been done, then you must first call loglikhd!(be).\n\n\n\n\n\n","category":"method"},{"location":"module_index/#DiffusionMCMCTools.fetch_ll°-Tuple{BlockEnsemble}","page":"Index","title":"DiffusionMCMCTools.fetch_ll°","text":"fetch_ll°(be::BlockEnsemble)\n\nRetreive the log-likelihood for all proposed paths\n\nwarning: Warning\nThe function uses only internal fields ll for this computation, which means that for the call to this function to make sense the log-likelihood must have been previously computed and stored in the field ll. If it hasn't been done, then you must first call loglikhd°!(be).\n\n\n\n\n\n","category":"method"},{"location":"module_index/#DiffusionMCMCTools.find_W_for_X!-Tuple{BlockCollection}","page":"Index","title":"DiffusionMCMCTools.find_W_for_X!","text":"find_W_for_X!(bc::BlockCollection)\n\nFor each block find the Wiener process bb.b.WW that reconstructs the path bb.b.XX under the accepted law bb.b.PP (possibly including bb.b.P_last).\n\n\n\n\n\n","category":"method"},{"location":"module_index/#DiffusionMCMCTools.find_W_for_X!-Tuple{BlockEnsemble}","page":"Index","title":"DiffusionMCMCTools.find_W_for_X!","text":"find_W_for_X!(be::BlockEnsemble)\n\nCall find_W_for_X! separately for each recording.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#DiffusionMCMCTools.find_var_aux_names_not_in_MCMC_update-Tuple{Any,Any}","page":"Index","title":"DiffusionMCMCTools.find_var_aux_names_not_in_MCMC_update","text":"find_var_aux_names_not_in_MCMC_update(composite_names_in_updt, PP)\n\nParse through all PP and for each element look through variable names of P_aux and remove all those names that already feature in composite_names_in_updt.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#DiffusionMCMCTools.find_var_names_not_in_MCMC_update-Tuple{Any,Any}","page":"Index","title":"DiffusionMCMCTools.find_var_names_not_in_MCMC_update","text":"find_var_names_not_in_MCMC_update(composite_names_in_updt, PP)\n\nParse through all variable names of P_target and remove all those names that already feature in composite_names_in_updt.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#DiffusionMCMCTools.find_θ_aux_names_for_MCMC_update-Tuple{Any,Any}","page":"Index","title":"DiffusionMCMCTools.find_θ_aux_names_for_MCMC_update","text":"find_θ_aux_names_for_MCMC_update(θ_names_for_MCMC_update, PP)\n\nParse through PP and for each GuidProp struct enter the auxiliary law P_aux and pick out names from θ_names_for_MCMC_update that are relevant to this P_aux law.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#DiffusionMCMCTools.find_θ_names_for_MCMC_update-Tuple{Any,Any}","page":"Index","title":"DiffusionMCMCTools.find_θ_names_for_MCMC_update","text":"find_θ_names_for_MCMC_update(θnames, pdep)\n\nParse through θnames i.e. a list of all parameter names that are relevant for a given MCMC update and pick out only those that are relevant for a given diffusion law. All information about the relevant parameters of the law should be stored inside pdep. Return a list of relevant parameter names in a format: idx-of-θ-to-relevant-value => name-of-param-inside-P_target-struct.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#DiffusionMCMCTools.find_θ_obs_idx_for_MCMC_update-Tuple{Any,Any}","page":"Index","title":"DiffusionMCMCTools.find_θ_obs_idx_for_MCMC_update","text":"find_θ_obs_idx_for_MCMC_update(θnames, odeps)\n\nParse through θnames i.e. a list of all parameter names that are relevant for a given MCMC update and for each observation pick out only those that are relevant for it. All information about the relevant parameters of the observations should be stored inside odeps. Return a list of relevant parameter names in a format: idx-of-θ-to-relevant-value => idx-of-obs-inside-obs.θ.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#DiffusionMCMCTools.init_paths!-NTuple{5,Any}","page":"Index","title":"DiffusionMCMCTools.init_paths!","text":"init_paths!(P, WW, Wnr, XX, x0_prior)\n\nSample paths of guided proposals without using the preconditioned Crank–Nicolson scheme.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#DiffusionMCMCTools.ll_of_accepted-Tuple{BlockEnsemble,Any}","page":"Index","title":"DiffusionMCMCTools.ll_of_accepted","text":"ll_of_accepted(be::BlockEnsemble, i)\n\nReturn an array of log-likelihoods (one for each block in each recording) of the paths that were accepted at the ith iteration.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#DiffusionMCMCTools.loglikhd!-Tuple{BlockEnsemble}","page":"Index","title":"DiffusionMCMCTools.loglikhd!","text":"loglikhd!(be::BlockEnsemble)\n\nCall loglikhd! separately for each recording.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#DiffusionMCMCTools.loglikhd°!-Tuple{BlockEnsemble}","page":"Index","title":"DiffusionMCMCTools.loglikhd°!","text":"loglikhd°!(be::BlockEnsemble)\n\nCall loglikhd°! separately for each recording.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#DiffusionMCMCTools.save_ll!-Tuple{BlockEnsemble,Int64}","page":"Index","title":"DiffusionMCMCTools.save_ll!","text":"save_ll!(be::BlockEnsemble, i::Int)\n\nCall save_ll! separately for each recording.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#DiffusionMCMCTools.set_proposal_law!","page":"Index","title":"DiffusionMCMCTools.set_proposal_law!","text":"set_proposal_law!(\n    be::BlockEnsemble,\n    θ°,\n    pnames,\n    critical_change=GP.is_critical_update(bc, pnames);\n    skip=0\n)\n\nCall set_proposal_law! separately for each recording.\n\n\n\n\n\n","category":"function"},{"location":"module_index/#DiffusionMCMCTools.set_proposal_law!-2","page":"Index","title":"DiffusionMCMCTools.set_proposal_law!","text":"set_proposal_law!(\n    bb::BiBlock,\n    θ°,\n    pnames,\n    critical_change=GP.is_critical_update(bb, pnames);\n    skip=0\n)\n\nSet the parameters in bb.b°.PP and bb.b°.P_last to θ° and make sure that all other parameters are shared with bb.b.PP and bb.b.P_last. Recompute the guiding term if needed, and then, compute the proposal trajectory bb.b°.XX for the proposal point θ°.\n\n\n\n\n\n","category":"function"},{"location":"module_index/#DiffusionMCMCTools.swap_PP!-Tuple{BlockEnsemble}","page":"Index","title":"DiffusionMCMCTools.swap_PP!","text":"swap_PP!(be::BlockEnsemble)\n\nCall swap_PP! separately for each recording.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#DiffusionMCMCTools.swap_WW!-Tuple{BlockEnsemble}","page":"Index","title":"DiffusionMCMCTools.swap_WW!","text":"swap_WW!(be::BlockEnsemble)\n\nCall swap_WW! separately for each recording.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#DiffusionMCMCTools.swap_XX!-Tuple{BlockEnsemble}","page":"Index","title":"DiffusionMCMCTools.swap_XX!","text":"swap_XX!(be::BlockEnsemble)\n\nCall swap_XX! separately for each recording.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#DiffusionMCMCTools.swap_ll!-Tuple{BlockEnsemble}","page":"Index","title":"DiffusionMCMCTools.swap_ll!","text":"swap_ll!(be::BlockEnsemble)\n\nCall swap_ll! separately for each recording.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#DiffusionMCMCTools.swap_paths!-Tuple{BlockEnsemble}","page":"Index","title":"DiffusionMCMCTools.swap_paths!","text":"swap_paths!(be::BlockEnsemble)\n\nCall swap_paths! separately for each recording.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.equalize_law_params!-Tuple{BiBlock,Any}","page":"Index","title":"GuidedProposals.equalize_law_params!","text":"GP.equalize_law_params!(bb::BiBlock, pnames)\n\nMake sure that in the corresponding pairs of GuidProp structs of both bb.b and bb.b°, the variable parameters of each law are the same. If not, then set the ones in bb.b° to be the same as the ones in bb.b.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.equalize_obs_params!-Tuple{BiBlock}","page":"Index","title":"GuidedProposals.equalize_obs_params!","text":"GP.equalize_obs_params!(bb::BiBlock)\n\nMake sure that in the corresponding pairs of GuidProp structs of both bb.b and bb.b°, the parameters θ of the obs fields are the same. If not, then set the ones in bb.b° to be the same as the ones in bb.b.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.is_critical_update-Tuple{BiBlock,Any}","page":"Index","title":"GuidedProposals.is_critical_update","text":"is_critical_update(bb::BiBlock, pnames)\n\nVerify whether the update characterized by a list of parameter names stored in pnames is critical in a sense of prompting for recomputation of the guiding term.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.is_critical_update-Tuple{BlockCollection,Any}","page":"Index","title":"GuidedProposals.is_critical_update","text":"is_critical_update(bb::BlockCollection, pnames)\n\nFor each block in the collection verify whether the update characterized by a list of parameter names stored in pnames is critical in a sense of prompting for recomputation of the guiding term.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.is_critical_update-Tuple{BlockEnsemble,Any}","page":"Index","title":"GuidedProposals.is_critical_update","text":"is_critical_update(be::BlockEnsemble, pnames)\n\nCall is_critical_update separately for each recording.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.recompute_guiding_term!-Tuple{BlockCollection}","page":"Index","title":"GuidedProposals.recompute_guiding_term!","text":"GP.recompute_guiding_term!(bc::BlockCollection, [::Val{:_only}])\n\nFor each block in the collection recompute the guiding terms of both the proposal and the accepted laws. If an additional flag Val(:P_only) is passed, then recomputes the guiding term on accepted law only. If Val(:P°_only), then recomputes for the proposal law only.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.recompute_guiding_term!-Tuple{BlockEnsemble}","page":"Index","title":"GuidedProposals.recompute_guiding_term!","text":"GP.recompute_guiding_term!(be::BlockEnsemble, [::Val{:_only}])\n\nCall recompute_guiding_term! separately for each recording.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.set_obs!-Tuple{BlockEnsemble}","page":"Index","title":"GuidedProposals.set_obs!","text":"GP.set_obs!(be::BlockEnsemble)\n\nCall save_ll! separately for each recording.\n\n\n\n\n\n","category":"method"},{"location":"get_started/overview/#get_started","page":"Get started","title":"Get started","text":"","category":"section"},{"location":"get_started/overview/","page":"Get started","title":"Get started","text":"","category":"page"},{"location":"get_started/overview/#Installation","page":"Get started","title":"Installation","text":"","category":"section"},{"location":"get_started/overview/","page":"Get started","title":"Get started","text":"","category":"page"},{"location":"get_started/overview/","page":"Get started","title":"Get started","text":"] add https://github.com/JuliaDiffusionBayes/DiffusionMCMCTools.jl","category":"page"},{"location":"get_started/overview/#Structs-that-neatly-gather-all-necessary-containers","page":"Get started","title":"Structs that neatly gather all necessary containers","text":"","category":"section"},{"location":"get_started/overview/","page":"Get started","title":"Get started","text":"","category":"page"},{"location":"get_started/overview/","page":"Get started","title":"Get started","text":"As the title suggests. An important point is that they don't have almost any methods implemented for them and thus cannot be used for sampling or inference. You can think of them as essentially bags that carry the objects. For sampling and inference see various blocks that are presented below.","category":"page"},{"location":"get_started/overview/#SamplingPair","page":"Get started","title":"SamplingPair","text":"","category":"section"},{"location":"get_started/overview/","page":"Get started","title":"Get started","text":"AuxLaw = ... # `Type` of an auxiliary diffusion (NOT its instance)\nrecording = (P = ..., obs = ..., t0 = ..., x0_prior = ...)\ntts = ... # time grids corresponding to `obs` in `recording`\n\nsampling_pair = SamplingPair(AuxLaw, recording, tts)","category":"page"},{"location":"get_started/overview/","page":"Get started","title":"Get started","text":"sampling_pair will contain all containers—such as u.PP, u.WW, u.XX i.e. accepted guided proposals, Wiener process and path of a process, u°.PP, u°.WW, u°.XX i.e. their proposed versions and more—that are needed for smoothing or inference based on the recording.","category":"page"},{"location":"get_started/overview/#SamplingEnsemble","page":"Get started","title":"SamplingEnsemble","text":"","category":"section"},{"location":"get_started/overview/","page":"Get started","title":"Get started","text":"Same as SamplingPair, but for multiple recordings.","category":"page"},{"location":"get_started/overview/","page":"Get started","title":"Get started","text":"AuxLaw = ... # `Type` of an auxiliary diffusion (NOT its instance)\n\n_all_obs = AllObservations() # a structure with multiple recordings and dependency structures\nadd_recording!(_all_obs, ...)\nall_obs, _ = initialize(all_obs)\n\ntts = ... # time grids corresponding to `recordings` in `all_obs.recordings`\n\nsampling_ensemble = SamplingEnsemble(AuxLaw, all_obs.recordings, tts)","category":"page"},{"location":"get_started/overview/","page":"Get started","title":"Get started","text":"sampling_ensemble will contain an instance of SamplingPair for each recording.","category":"page"},{"location":"get_started/overview/#Structs-that-act-as-windowed-views-into-containers-above","page":"Get started","title":"Structs that act as windowed views into containers above","text":"","category":"section"},{"location":"get_started/overview/","page":"Get started","title":"Get started","text":"","category":"page"},{"location":"get_started/overview/","page":"Get started","title":"Get started","text":"Unlike the containers above, the block-structures defined below have many methods implemented for them so that they can be used for sampling and inference.","category":"page"},{"location":"get_started/overview/#BiBlock","page":"Get started","title":"BiBlock","text":"","category":"section"},{"location":"get_started/overview/","page":"Get started","title":"Get started","text":"last_block = true\nblock = BiBlock(sampling_pair, start_idx:end_idx, ρ, last_block, num_steps)","category":"page"},{"location":"get_started/overview/","page":"Get started","title":"Get started","text":"A block above is a view into containers of sampling_pair that have indices running through start_idx:end_idx. last_block is a flag that indicates whether we want block to be the terminal block for a given recording. If set to true (as above), then block will essentially point to sampling_pair.u.PP[start_idx:end_idx], sampling_pair.u°.PP[start_idx:end_idx], sampling_pair.u.XX[start_idx:end_idx] etc.. On the other hand, if set to false, then for pointers to law, i.e. to sampling_pair.u.PP and sampling_pair.u°.PP, the indices would run through start_idx:end_idx instead and the terminal law would be substituted with a P_last that can handle an exact terminal observation.","category":"page"},{"location":"get_started/overview/","page":"Get started","title":"Get started","text":"We can now perform many different operations on block. For instance:","category":"page"},{"location":"get_started/overview/","page":"Get started","title":"Get started","text":"# to draw a proposal path\ndraw_proposal_path!(block)\n\n# use Metropolis–Hastings accept/reject rule to decide whether proposal path should be accepted\naccept_reject_proposal_path!(block, mcmc_iteration_idx)\n\n# to compute acceptance rate based on the last 100 path imputations\naccpt_rate(block, (mcmc_iteration_idx-99):mcmc_iteration_idx)\n\n# to freeze the terminal point of a block to become an artificial observation\nset_obs!(block)\n\n# to recompute the guiding term only on the \"accepted\" laws `bb.b.PP`\nrecompute_guiding_term!(block)\n\n# to recompute the Wiener path that reconstructs the accepted path under the accepted law\nfind_W_for_X!(block)\n\n# re-evaluate the log-likelihood and store it in a local field\nloglikhd!(block)\n\n# set the parameters inside the proposal law\nset_proposal_law!(block, θ°, #= to be explained =# name_struct #= to be explained =#, true)\n# name_struct should be an instance of `ParamNamesBlock`","category":"page"},{"location":"get_started/overview/#BlockCollection","page":"Get started","title":"BlockCollection","text":"","category":"section"},{"location":"get_started/overview/","page":"Get started","title":"Get started","text":"block_ranges = ... # for instance [1:15, 16:30, 31:50, 51:100]\nblock_collection = BlockCollection(sampling_pair, block_ranges, ρ, num_steps)","category":"page"},{"location":"get_started/overview/","page":"Get started","title":"Get started","text":"block_collection will contain multiple BiBlocks that together split the recording into segments called blocks. You can call all methods listed above on block_collection instead of calling them separately on each BiBlock and the result will be most likely as you'd expect it: the function will be recursively applied to each block that block_collection comprises of.","category":"page"},{"location":"get_started/overview/#BlockEnsemble","page":"Get started","title":"BlockEnsemble","text":"","category":"section"},{"location":"get_started/overview/","page":"Get started","title":"Get started","text":"BlockEnsemble is simply a collection of BlockCollections, where a single instance of BlockCollection is defined per every recording.","category":"page"},{"location":"get_started/overview/","page":"Get started","title":"Get started","text":"block_ensemble = BlockEnsemble(\n    sampling_ensemble,\n    block_ranges, # for instance [[1:50, 51:100], [1:20, 21:35, 36:50]]\n    ρ,\n    num_steps\n)","category":"page"},{"location":"get_started/overview/","page":"Get started","title":"Get started","text":"Similarly to before, you can call methods above directly on block_ensemble and they will be applied recursively to constituent elements of it.","category":"page"},{"location":"get_started/overview/#Structs-that-translate-between-different-parameter-names","page":"Get started","title":"Structs that translate between different parameter names","text":"","category":"section"},{"location":"get_started/overview/","page":"Get started","title":"Get started","text":"","category":"page"},{"location":"get_started/overview/","page":"Get started","title":"Get started","text":"It is very convenient to have the MCMC chain refer to various parameters independently from how they are internally called inside each diffusion law or inside each observation. This makes it possible to couple parameters that don't share local names. For instance you might have an instance of one law with parameter ϵ, say P1.ϵ and an instance of another law with parameter δ, say P2.δ and you'd want to impose a restriction that these parameters are the same. Worry not, you don't need to redefine the diffusion laws!. Simply make sure that a relevant dependency structure is passed to an AllObservations object, where a parameter, let's call it shared_ϵδ, will be defined and will point to appropriate laws. For instance:","category":"page"},{"location":"get_started/overview/","page":"Get started","title":"Get started","text":"all_obs = ...\nadd_dependency!(\n    all_obs,\n    Dict(\n        :shared_ϵδ => [(1, :ϵ), (2, :δ)]\n    )\n)","category":"page"},{"location":"get_started/overview/","page":"Get started","title":"Get started","text":"The objects ParamNamesBlock, ParamNamesRecording and ParamNamesAllObs will define relevant translations between parameter names for you. Simply treat shared_ϵδ as a parameter name known to the MCMC chain that will implicitly point to relevant parameters ϵ and δ that you've defined by adding the dependency structure.","category":"page"},{"location":"get_started/overview/#ParamNamesBlock","page":"Get started","title":"ParamNamesBlock","text":"","category":"section"},{"location":"get_started/overview/","page":"Get started","title":"Get started","text":"all_obs = ...\npname = ... # for instance [:shared_ϵδ]\n\nname_struct = ParamNamesBlock(\n    block.b,\n    pname,\n    first(all_obs.param_depend_rev),\n    first(all_obs.obs_depend_rev)\n)","category":"page"},{"location":"get_started/overview/#ParamNamesRecording","page":"Get started","title":"ParamNamesRecording","text":"","category":"section"},{"location":"get_started/overview/","page":"Get started","title":"Get started","text":"all_obs = ...\npname = ... # for instance [:shared_ϵδ]\n\nname_struct = ParamNamesRecording(\n    block_collection,\n    pname,\n    first(all_obs.param_depend_rev),\n    first(all_obs.obs_depend_rev)\n)","category":"page"},{"location":"get_started/overview/#ParamNamesAllObs","page":"Get started","title":"ParamNamesAllObs","text":"","category":"section"},{"location":"get_started/overview/","page":"Get started","title":"Get started","text":"all_obs = ...\npname = ... # for instance [:shared_ϵδ]\n\nname_struct = ParamNamesAllObs(block_ensemble, pname, all_obs)","category":"page"},{"location":"manual/biblock/#biblock_def","page":"BiBlock","title":"BiBlock","text":"","category":"section"},{"location":"manual/biblock/","page":"BiBlock","title":"BiBlock","text":"","category":"page"},{"location":"manual/biblock/","page":"BiBlock","title":"BiBlock","text":"A composite unit that represents a block. It can be used for sampling on a block in a setting of smoothing or inference.","category":"page"},{"location":"manual/biblock/","page":"BiBlock","title":"BiBlock","text":"DiffusionMCMCTools.BiBlock","category":"page"},{"location":"manual/biblock/#DiffusionMCMCTools.BiBlock","page":"BiBlock","title":"DiffusionMCMCTools.BiBlock","text":"mutable struct BiBlock{L,TGP,TGPl,TW,TWn,TX}\n    b::Block{L,TGP,TGPl,TW,TWn,TX}\n    b°::Block{L,TGP,TGPl,TW,TWn,TX}\n    ρ::Float64\n    accpt_history::Vector{Bool}\nend\n\nComposite unit that allows for sampling of a single block. It provides two Blocks: one proposal b°, one accepted b that can be used for smoothing or inference problems. ρ is a memory parameter of the preconditioned Crank-Nicolson scheme and accpt_history stores the history of accept/reject decisions (useful for MCMC).\n\nfunction BiBlock(\n    sp::SamplingPair,\n    range::UnitRange{Int64},\n    ρ=0.0,\n    last_block=false,\n    ll_hist_len=0\n)\n\nBase constructor.\n\n\n\n\n\n","category":"type"},{"location":"manual/biblock/","page":"BiBlock","title":"BiBlock","text":"There are many functions implemented for it.","category":"page"},{"location":"manual/biblock/#Imputation-of-paths","page":"BiBlock","title":"Imputation of paths","text":"","category":"section"},{"location":"manual/biblock/","page":"BiBlock","title":"BiBlock","text":"","category":"page"},{"location":"manual/biblock/","page":"BiBlock","title":"BiBlock","text":"DiffusionMCMCTools.draw_proposal_path!(bb::DiffusionMCMCTools.BiBlock)","category":"page"},{"location":"manual/biblock/#DiffusionMCMCTools.draw_proposal_path!-Tuple{BiBlock}","page":"BiBlock","title":"DiffusionMCMCTools.draw_proposal_path!","text":"draw_proposal_path!(bb::BiBlock)\n\nSample a proposal path, compute log-likelihood along the way. Assumes bb.b.XX[1].x[1] is a starting point. Uses preconditioned Crank-Nicolson scheme with memory parameter set as bb.ρ.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#Accept/reject-decision-in-an-MCMC-setting","page":"BiBlock","title":"Accept/reject decision in an MCMC setting","text":"","category":"section"},{"location":"manual/biblock/","page":"BiBlock","title":"BiBlock","text":"","category":"page"},{"location":"manual/biblock/","page":"BiBlock","title":"BiBlock","text":"DiffusionMCMCTools.accept_reject_proposal_path!(bb::DiffusionMCMCTools.BiBlock, mcmciter)","category":"page"},{"location":"manual/biblock/#DiffusionMCMCTools.accept_reject_proposal_path!-Tuple{BiBlock,Any}","page":"BiBlock","title":"DiffusionMCMCTools.accept_reject_proposal_path!","text":"accept_reject_proposal_path!(bb::BiBlock, mcmciter)\n\nAccept/reject decision of the Metropolis-Hastings algorithm for the step of path imputation.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#Adjustments-made-after-the-accept-reject-decision-(regardless-of-what-it-was)","page":"BiBlock","title":"Adjustments made after the accept-reject decision (regardless of what it was)","text":"","category":"section"},{"location":"manual/biblock/","page":"BiBlock","title":"BiBlock","text":"","category":"page"},{"location":"manual/biblock/","page":"BiBlock","title":"BiBlock","text":"DiffusionMCMCTools.set_accepted!(bb::DiffusionMCMCTools.BiBlock, i::Int, v)","category":"page"},{"location":"manual/biblock/#DiffusionMCMCTools.set_accepted!-Tuple{BiBlock,Int64,Any}","page":"BiBlock","title":"DiffusionMCMCTools.set_accepted!","text":"set_accepted!(bb::BiBlock, i::Int, v)\n\nCommit the accept/reject decision v to acceptance history of BiBlock b at the position i.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#Adjustments-to-the-containers-in-case-of-**acceptance**-of-proposals:","page":"BiBlock","title":"Adjustments to the containers in case of acceptance of proposals:","text":"","category":"section"},{"location":"manual/biblock/","page":"BiBlock","title":"BiBlock","text":"","category":"page"},{"location":"manual/biblock/","page":"BiBlock","title":"BiBlock","text":"DiffusionMCMCTools.swap_paths!(bb::DiffusionMCMCTools.BiBlock)\nDiffusionMCMCTools.swap_XX!(bb::DiffusionMCMCTools.BiBlock)\nDiffusionMCMCTools.swap_WW!(bb::DiffusionMCMCTools.BiBlock)\nDiffusionMCMCTools.swap_PP!(bb::DiffusionMCMCTools.BiBlock)\nDiffusionMCMCTools.swap_ll!(bb::DiffusionMCMCTools.BiBlock)","category":"page"},{"location":"manual/biblock/#DiffusionMCMCTools.swap_paths!-Tuple{BiBlock}","page":"BiBlock","title":"DiffusionMCMCTools.swap_paths!","text":"swap_paths!(bb::BiBlock)\n\nSwap XX and WW containers between proposal-acceptance pair.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#DiffusionMCMCTools.swap_XX!-Tuple{BiBlock}","page":"BiBlock","title":"DiffusionMCMCTools.swap_XX!","text":"swap_XX!(bb::BiBlock)\n\nSwap XX containers between proposal-acceptance pair.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#DiffusionMCMCTools.swap_WW!-Tuple{BiBlock}","page":"BiBlock","title":"DiffusionMCMCTools.swap_WW!","text":"swap_WW!(bb::BiBlock)\n\nSwap WW containers between proposal-acceptance pair.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#DiffusionMCMCTools.swap_PP!-Tuple{BiBlock}","page":"BiBlock","title":"DiffusionMCMCTools.swap_PP!","text":"swap_PP!(bb::BiBlock)\n\nSwap PP containers (including PP_last) between proposal-acceptance pair.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#DiffusionMCMCTools.swap_ll!-Tuple{BiBlock}","page":"BiBlock","title":"DiffusionMCMCTools.swap_ll!","text":"swap_ll!(bb::BiBlock)\n\nSwap ll containers between proposal-acceptance pair.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#Setting-up-a-block","page":"BiBlock","title":"Setting up a block","text":"","category":"section"},{"location":"manual/biblock/","page":"BiBlock","title":"BiBlock","text":"","category":"page"},{"location":"manual/biblock/","page":"BiBlock","title":"BiBlock","text":"DiffusionMCMCTools.set_obs!(bb::DiffusionMCMCTools.BiBlock)\nDiffusionMCMCTools.recompute_guiding_term!(bb::DiffusionMCMCTools.BiBlock)\nDiffusionMCMCTools.find_W_for_X!(bb::DiffusionMCMCTools.BiBlock)","category":"page"},{"location":"manual/biblock/#GuidedProposals.set_obs!-Tuple{BiBlock}","page":"BiBlock","title":"GuidedProposals.set_obs!","text":"GP.set_obs!(bb::BiBlock)\n\nFreeze an artificial observation at the terminal point of the block. For a terminal block nothing is done.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#GuidedProposals.recompute_guiding_term!-Tuple{BiBlock}","page":"BiBlock","title":"GuidedProposals.recompute_guiding_term!","text":"GP.recompute_guiding_term!(bb::BiBlock)\n\nRecompute the guiding terms of both the proposal and the accepted laws.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#DiffusionMCMCTools.find_W_for_X!-Tuple{BiBlock}","page":"BiBlock","title":"DiffusionMCMCTools.find_W_for_X!","text":"find_W_for_X!(bb::BiBlock)\n\nFind the Wiener process bb.b.WW that reconstructs path bb.b.XX under the accepted law bb.b.PP (possibly including bb.b.P_last).\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#Setting-parameters","page":"BiBlock","title":"Setting parameters","text":"","category":"section"},{"location":"manual/biblock/","page":"BiBlock","title":"BiBlock","text":"","category":"page"},{"location":"manual/biblock/","page":"BiBlock","title":"BiBlock","text":"DiffusionMCMCTools.set_proposal_law!(\n    bb::DiffusionMCMCTools.BiBlock,\n    θ°,\n    pnames,\n    critical_change=DiffusionMCMCTools.is_critical_update(bb, pnames),\n    skip=0\n)\n","category":"page"},{"location":"manual/biblock/#Utility","page":"BiBlock","title":"Utility","text":"","category":"section"},{"location":"manual/biblock/","page":"BiBlock","title":"BiBlock","text":"","category":"page"},{"location":"manual/biblock/","page":"BiBlock","title":"BiBlock","text":"DiffusionMCMCTools.ll_of_accepted(bb::DiffusionMCMCTools.BiBlock, i)\nDiffusionMCMCTools.accpt_rate(bb::DiffusionMCMCTools.BiBlock, range)\nDiffusionMCMCTools.loglikhd!(bb::DiffusionMCMCTools.BiBlock)\nDiffusionMCMCTools.loglikhd°!(bb::DiffusionMCMCTools.BiBlock)\nDiffusionMCMCTools.save_ll!(bb::DiffusionMCMCTools.BiBlock, i::Int)","category":"page"},{"location":"manual/biblock/#DiffusionMCMCTools.ll_of_accepted-Tuple{BiBlock,Any}","page":"BiBlock","title":"DiffusionMCMCTools.ll_of_accepted","text":"ll_of_accepted(bb::BiBlock, i)\n\nReturn the log-likelihood of the path that was accepted at the ith iteration.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#DiffusionMCMCTools.accpt_rate-Tuple{BiBlock,Any}","page":"BiBlock","title":"DiffusionMCMCTools.accpt_rate","text":"accpt_rate(bb::BiBlock, range)\n\nCompute the acceptance rate over the range of MCMC accept/reject history.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#DiffusionMCMCTools.loglikhd!-Tuple{BiBlock}","page":"BiBlock","title":"DiffusionMCMCTools.loglikhd!","text":"loglikhd!(b::BiBlock)\n\nCompute the log-likelihood for the accepted block, evaluated at a sampled path and store the result in an internal field ll.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#DiffusionMCMCTools.loglikhd°!-Tuple{BiBlock}","page":"BiBlock","title":"DiffusionMCMCTools.loglikhd°!","text":"loglikhd°!(b::BiBlock)\n\nCompute the log-likelihood for the proposal block, evaluated at a sampled path and store the result in an internal field ll.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#DiffusionMCMCTools.save_ll!-Tuple{BiBlock,Int64}","page":"BiBlock","title":"DiffusionMCMCTools.save_ll!","text":"save_ll!(bb::BiBlock, i::Int)\n\nCommit the current proposal and accepted log-likelihood fields ll to history, at index i.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/","page":"BiBlock","title":"BiBlock","text":"note: Note\nAs you can see above, BiBlock is the fundamental building block that is used for creating inference and smoothing algorithms. However, as the complexity of these algorithms grow it is useful to use some macro structures that operate on or are defined for multiple BiBlocks. This is precisely what the remaining tools defined in this package are for. Otherwise put, they aim to facilitate writing snippets of code as above in a much more compact and convenient way.","category":"page"},{"location":"tutorials/preamble/#tutorials_start","page":"⚠ Preamble ⚠","title":"Preamble to tutorials","text":"","category":"section"},{"location":"tutorials/preamble/","page":"⚠ Preamble ⚠","title":"⚠ Preamble ⚠","text":"","category":"page"},{"location":"tutorials/preamble/","page":"⚠ Preamble ⚠","title":"⚠ Preamble ⚠","text":"Different structs and methods introduced in the package DiffusionMCMCTools often aim to accomplish the same (or at least very similar) thing. The differences most often boil down to the degree of abstraction.","category":"page"},{"location":"tutorials/preamble/","page":"⚠ Preamble ⚠","title":"⚠ Preamble ⚠","text":"For instance, you might look at two structs: BiBlock and BlockCollection and consider a method draw_proposal_path! that is implemented for both of them. Conceptually, draw_proposal_path! does the same thing for both objects: it samples the diffusion paths; however, the result is slightly different. The reason is that BiBlock always points to a single block, whereas BlockCollection points to a collection of such blocks. Consequently, when we call draw_proposal_path! on a BiBlock, then a path is sampled on a single block, whereas if we call it on BlockCollection, it is sampled on multiple blocks.","category":"page"},{"location":"tutorials/preamble/","page":"⚠ Preamble ⚠","title":"⚠ Preamble ⚠","text":"The differences like this one are abound in the package DiffusionMCMCTools (though, in practice, there are really only three grades of such differences: when the methods are called on: BiBlock, BlockCollection or BlockEnsemble) and consequently, by choosing a different level of abstraction it is possible to write inference and smoothing algorithms in different ways.","category":"page"},{"location":"tutorials/preamble/","page":"⚠ Preamble ⚠","title":"⚠ Preamble ⚠","text":"To illustrate these differences most clearly we will unify the setting that is treated across all tutorials and present various takes on writing algorithms for problems of inference and smoothing.","category":"page"},{"location":"tutorials/preamble/#The-set-up","page":"⚠ Preamble ⚠","title":"The set-up","text":"","category":"section"},{"location":"tutorials/preamble/","page":"⚠ Preamble ⚠","title":"⚠ Preamble ⚠","text":"","category":"page"},{"location":"tutorials/preamble/","page":"⚠ Preamble ⚠","title":"⚠ Preamble ⚠","text":"All tutorials are treating the FitzHugh–Nagumo model. Consequently, we will use the following preamble for all tutorials:","category":"page"},{"location":"tutorials/preamble/","page":"⚠ Preamble ⚠","title":"⚠ Preamble ⚠","text":"using GuidedProposals, DiffusionDefinition, ObservationSchemes, DiffusionMCMCTools\nconst GP = GuidedProposals\nconst DD = DiffusionDefinition\nconst OBS = ObservationSchemes\nconst dMCMCt = DiffusionMCMCTools\n\nusing StaticArrays, Random, Plots, Distributions\n\n# seed with which all tutorials start\nRandom.seed!(100)\n\n@load_diffusion FitzHughNagumo\n@load_diffusion FitzHughNagumoAux","category":"page"},{"location":"tutorials/preamble/","page":"⚠ Preamble ⚠","title":"⚠ Preamble ⚠","text":"For any blocking scheme we additionally need the following snippet for the function find_W_for_X! to work properly:","category":"page"},{"location":"tutorials/preamble/","page":"⚠ Preamble ⚠","title":"⚠ Preamble ⚠","text":"@inline DD.nonhypo(x, P::FitzHughNagumo) = x[SVector{1,Int64}(2)]\n@inline DD.nonhypo_σ(t::Float64, x, P::FitzHughNagumo) = SMatrix{1,1,Float64}(P.σ)","category":"page"},{"location":"tutorials/preamble/","page":"⚠ Preamble ⚠","title":"⚠ Preamble ⚠","text":"And for simplicity, for all inference algorithms we will be updating a single parameter  γ only. We will thus need to indicate which parameters are considered to be variable as follows","category":"page"},{"location":"tutorials/preamble/","page":"⚠ Preamble ⚠","title":"⚠ Preamble ⚠","text":"DD.var_parameter_names(::FitzHughNagumo) = (:γ,)\nDD.var_parameter_names(::FitzHughNagumoAux) = (:γ,)","category":"page"},{"location":"tutorials/preamble/","page":"⚠ Preamble ⚠","title":"⚠ Preamble ⚠","text":"As a good practice for more complicated models (though not strictly necessary in our settings) we will also use a package OrderedCollections for indicating which parameters the MCMC chain should be updating, so we will load it in alongside other packages.","category":"page"},{"location":"tutorials/preamble/#Full-code-for-the-set-up","page":"⚠ Preamble ⚠","title":"Full code for the set-up","text":"","category":"section"},{"location":"tutorials/preamble/","page":"⚠ Preamble ⚠","title":"⚠ Preamble ⚠","text":"Consequently, all tutorials should run correctly if you start from calling the following lines:","category":"page"},{"location":"tutorials/preamble/","page":"⚠ Preamble ⚠","title":"⚠ Preamble ⚠","text":"using GuidedProposals, DiffusionDefinition, ObservationSchemes, DiffusionMCMCTools\nconst GP = GuidedProposals\nconst DD = DiffusionDefinition\nconst OBS = ObservationSchemes\nconst dMCMCt = DiffusionMCMCTools\n\nusing StaticArrays, Random, Plots, Distributions, OrderedCollections\n\n# seed with which all tutorials start\nRandom.seed!(100)\n\n@load_diffusion FitzHughNagumo\n@load_diffusion FitzHughNagumoAux\n\n@inline DD.nonhypo(x, P::FitzHughNagumo) = x[SVector{1,Int64}(2)]\n@inline DD.nonhypo_σ(t::Float64, x, P::FitzHughNagumo) = SMatrix{1,1,Float64}(P.σ)\n\nDD.var_parameter_names(::FitzHughNagumo) = (:γ,)\nDD.var_parameter_names(::FitzHughNagumoAux) = (:γ,)","category":"page"},{"location":"tutorials/preamble/#The-data","page":"⚠ Preamble ⚠","title":"The data","text":"","category":"section"},{"location":"tutorials/preamble/","page":"⚠ Preamble ⚠","title":"⚠ Preamble ⚠","text":"","category":"page"},{"location":"tutorials/preamble/","page":"⚠ Preamble ⚠","title":"⚠ Preamble ⚠","text":"For most tutorials we will use the same dataset that we generate from the target model as follows:","category":"page"},{"location":"tutorials/preamble/","page":"⚠ Preamble ⚠","title":"⚠ Preamble ⚠","text":"θ = [0.1, -0.8, 1.5, 0.0, 0.3]\nP = FitzHughNagumo(θ...)\ntt, y1 = 0.0:0.0001:10.0, @SVector [-0.9, -1.0]\nX = rand(P, tt, y1)\nobs_scheme = ObsScheme(\n    LinearGsnObs(\n        0.0, (@SVector [0.0]);\n        L=(@SMatrix [1.0 0.0]),\n        Σ=(@SMatrix [0.01])\n    )\n)\ndata = collect(obs_scheme, X, 1000)\nrecording = build_recording(P, data, 0.0, KnownStartingPt(y1))\n\nplot(X, Val(:vs_time), size=(800, 300))\nscatter!(map(x->x.t, data), map(x->x.obs[1], data), label=\"data\")","category":"page"},{"location":"tutorials/preamble/","page":"⚠ Preamble ⚠","title":"⚠ Preamble ⚠","text":"(Image: data)","category":"page"},{"location":"tutorials/preamble/","page":"⚠ Preamble ⚠","title":"⚠ Preamble ⚠","text":"The only exception will be the tutorial for the BlockEnsemble in which not one, but multiple trajectories from the target model will be used.","category":"page"},{"location":"tutorials/preamble/#Displaying-results","page":"⚠ Preamble ⚠","title":"Displaying results","text":"","category":"section"},{"location":"tutorials/preamble/","page":"⚠ Preamble ⚠","title":"⚠ Preamble ⚠","text":"","category":"page"},{"location":"tutorials/preamble/","page":"⚠ Preamble ⚠","title":"⚠ Preamble ⚠","text":"For displaying results we will make use of some plotting functions that we define below.","category":"page"},{"location":"tutorials/preamble/","page":"⚠ Preamble ⚠","title":"⚠ Preamble ⚠","text":"For improving the plotting performance we will use the following routines:","category":"page"},{"location":"tutorials/preamble/","page":"⚠ Preamble ⚠","title":"⚠ Preamble ⚠","text":"function glue_paths(XX)\n    XX_glued = trajectory(\n        glue_containers( map(x->x.t, XX) ),\n        glue_containers( map(x->x.x, XX) ),\n    )\nend\n\nfunction glue_containers(xs)\n    glued_xs = collect(Iterators.flatten(map(x->x[1:end-1], xs)))\n    append!(glued_xs, [xs[end][end]])\n    glued_xs\nend","category":"page"},{"location":"tutorials/preamble/","page":"⚠ Preamble ⚠","title":"⚠ Preamble ⚠","text":"And for displaying imputed trajectories (which already make use of routines above):","category":"page"},{"location":"tutorials/preamble/","page":"⚠ Preamble ⚠","title":"⚠ Preamble ⚠","text":"function plot_imputed_trajectories(paths)\n    convenient_paths = glue_paths.(paths)\n\n    col = [\"#581845\", \"#900C3F\", \"#C70039\", \"#FF5733\", \"#FFC300\"]\n\n    p = plot(size=(1000, 500))\n    for path in convenient_paths\n    \tplot!(p, path, Val(:vs_time), alpha=0.4, label=\"\", color=[col[3] col[1]])\n    end\n    plot!(X, Val(:vs_time), color=[col[5] col[4]], linewidth=[3 0.5], label=[\"underlying X₁\" \"underlying X₂\"])\n    scatter!(p, map(x->x.t, data), map(x->x.obs[1], data), label=\"data\", markercolor=col[5])\n    display(p)\nend","category":"page"},{"location":"manual/sampling_pair/#A-pairing-of-two-SamplingUnits","page":"SamplingPair","title":"A pairing of two SamplingUnits","text":"","category":"section"},{"location":"manual/sampling_pair/","page":"SamplingPair","title":"SamplingPair","text":"","category":"page"},{"location":"manual/sampling_pair/","page":"SamplingPair","title":"SamplingPair","text":"Defines all main containers for an entire single recording for a smoothing or inference problem.","category":"page"},{"location":"manual/sampling_pair/","page":"SamplingPair","title":"SamplingPair","text":"DiffusionMCMCTools.SamplingPair","category":"page"},{"location":"manual/sampling_pair/#DiffusionMCMCTools.SamplingPair","page":"SamplingPair","title":"DiffusionMCMCTools.SamplingPair","text":"struct SamplingPair{TGP,TGPb,TW,TWn,TX}\n    u::SamplingUnit{TGP,TGPb,TW,TWn,TX}\n    u°::SamplingUnit{TGP,TGPb,TW,TWn,TX}\nend\n\nA pairing of two SamplingUnits, can be used for smoothing or inference problems.\n\nSamplingPair(\n    aux_laws, recording, tts, args=tuple();\n    aux_laws_blocking=aux_laws, artificial_noise=1e-11,\n    solver_choice_blocking=args\n)\n\nBase constructor.\n\nArguments\n\n\n\naux_laws:\nrecording:\ntts:\nargs:\naux_laws_blocking:\nartificial_noise:\nsolver_choice_blocking:\n\n\n\n\n\n","category":"type"},{"location":"manual/sampling_pair/","page":"SamplingPair","title":"SamplingPair","text":"note: Note\nIn practice all sampling is done with a BiBlock that looks at sections of a SamplingPair and never through SamplingPair directly. Even when no blocking is needed, it should still be done by defining a BiBlock that simply looks at the entire SamplingPair.","category":"page"},{"location":"tutorials/biblock/smoothing/#Smoothing-with-BiBlocks","page":"Smoothing","title":"Smoothing with BiBlocks","text":"","category":"section"},{"location":"tutorials/biblock/smoothing/","page":"Smoothing","title":"Smoothing","text":"","category":"page"},{"location":"tutorials/biblock/smoothing/","page":"Smoothing","title":"Smoothing","text":"note: important\nMake sure that you read the preamble before you start reading this tutorial.","category":"page"},{"location":"tutorials/biblock/smoothing/#The-algorithm","page":"Smoothing","title":"The algorithm","text":"","category":"section"},{"location":"tutorials/biblock/smoothing/","page":"Smoothing","title":"Smoothing","text":"","category":"page"},{"location":"tutorials/biblock/smoothing/","page":"Smoothing","title":"Smoothing","text":"The smoothing algorithm is very simple. We","category":"page"},{"location":"tutorials/biblock/smoothing/","page":"Smoothing","title":"Smoothing","text":"initialize appropriate objects:\nthe time-grids\nall containers needed for smoothing via SamplingPair\npointers via BiBlock that basically point to all containers (as we do not employ any blocking schemes)\nrun MCMC by repeatedly\nproposing a new path from a proposal diffusion measure\naccept/reject decisions and updating the chain of trajectories","category":"page"},{"location":"tutorials/biblock/smoothing/","page":"Smoothing","title":"Smoothing","text":"\"\"\"\nThis is a simple smoothing function that imputes unobserved parts of the path.\nNo blocking is used, only the preconditioned Crank-Nicolson scheme with memory\nparameter ρ.\n\"\"\"\nfunction simple_smoothing(AuxLaw, recording, dt; ρ=0.5, num_steps=10^4)\n    # set up time-grids\n    tts = OBS.setup_time_grids(recording, dt, standard_guid_prop_time_transf)    \n    # this object contains containers\n    sp = SamplingPair(AuxLaw, recording, tts)\n    # and this has pointers to containers and facilitates actual sampling\n    bb = BiBlock(sp, 1:length(recording.obs), ρ, true, num_steps)\n    # make sure that the log-likelihood is computed for the initialized paths\n    # and stored in a local field `ll`\n    loglikhd!(bb)\n    # we will append imputed paths once in a while to visualize the sampler\n    # and see for ourselves how we are doing\n    paths = []\n\n    # MCMC\n    for i in 1:num_steps\n        # impute a path\n        draw_proposal_path!(bb)\n        # Metropolis–Hastings accept/reject step\n        accept_reject_proposal_path!(bb, i)\n\n        # progress message\n        if i % 100 == 0\n            println(\n                \"$i. ll=$(ll_of_accepted(bb, i)), acceptance rate: \",\n                \"$( accpt_rate(bb, (i-99):i) )\"\n            )\n        end\n\n        # save intermediate path for plotting\n        i % 400 == 0 && append!(paths, [deepcopy(bb.b.XX)])\n    end\n    paths\nend","category":"page"},{"location":"tutorials/biblock/smoothing/","page":"Smoothing","title":"Smoothing","text":"running the algorithm is very simple","category":"page"},{"location":"tutorials/biblock/smoothing/","page":"Smoothing","title":"Smoothing","text":"paths = simple_smoothing(FitzHughNagumoAux, recording, 0.001; ρ=0.96, num_steps=10^4)","category":"page"},{"location":"tutorials/biblock/smoothing/#Results","page":"Smoothing","title":"Results","text":"","category":"section"},{"location":"tutorials/biblock/smoothing/","page":"Smoothing","title":"Smoothing","text":"","category":"page"},{"location":"tutorials/biblock/smoothing/","page":"Smoothing","title":"Smoothing","text":"plot_imputed_trajectories(paths)","category":"page"},{"location":"tutorials/biblock/smoothing/","page":"Smoothing","title":"Smoothing","text":"(Image: smoothing)","category":"page"},{"location":"manual/block_ensemble/#BlockEnsemble","page":"BlockEnsemble","title":"BlockEnsemble","text":"","category":"section"},{"location":"manual/block_ensemble/","page":"BlockEnsemble","title":"BlockEnsemble","text":"","category":"page"},{"location":"manual/block_ensemble/","page":"BlockEnsemble","title":"BlockEnsemble","text":"DiffusionMCMCTools.BlockEnsemble","category":"page"},{"location":"manual/block_ensemble/#DiffusionMCMCTools.BlockEnsemble","page":"BlockEnsemble","title":"DiffusionMCMCTools.BlockEnsemble","text":"struct BlockEnsemble{T}\n    recordings::Vector{T}\nend\n\nGathers all blocks relevant for an entire single recording.\n\nBlockEnsemble(\n    se::SamplingEnsemble,\n    ranges,\n    ρρ=0.0,\n    ll_hist_len=0\n)\n\nBase constructor.\n\n\n\n\n\n","category":"type"},{"location":"tutorials/pnames/inference_with_biblock/#Collections-for-translating-parameter-names,-example-with-BiBlocks","page":"Inference with BiBlocks","title":"Collections for translating parameter names, example with BiBlocks","text":"","category":"section"},{"location":"tutorials/pnames/inference_with_biblock/","page":"Inference with BiBlocks","title":"Inference with BiBlocks","text":"","category":"page"},{"location":"tutorials/pnames/inference_with_biblock/","page":"Inference with BiBlocks","title":"Inference with BiBlocks","text":"all_obs = AllObservations()\nadd_recording!(all_obs, build_recording(P, data, 0.0, KnownStartingPt(y1)))\nDD.var_parameter_names(::FitzHughNagumo) = (:γ,)\nall_obs, _ = initialize(all_obs)\n\ncustomkernel(θ, scale=0.1) = θ .+ 2.0*scale*(rand()-0.5)\n\n#=\n    NOTE we no longer need to hand-craft the `_build_struct` and\n    `simple_name_structure` functions. These will be substituted with a\n    struct `ParamNamesRecording`\n=#\n\nfunction accept_reject_proposal_param!(bb, mcmciter, θ, θ°)\n    accepted = rand(Exponential(1.0)) > -(bb.b°.ll - bb.b.ll)\n    accepted && swap_XX!(bb)\n    accepted && swap_PP!(bb)\n    save_ll!(bb.b, mcmciter)\n    save_ll!(bb.b°, mcmciter)\n    accepted && swap_ll!(bb)\n    accepted, copy(accepted ? θ° : θ)\nend\n\nfunction simple_inference(AuxLaw, all_obs, dt, _θ; ϵ=0.3, ρ=0.5, num_steps=10^4)\n    # making sure that things are in order...\n    _pname = collect(keys(_θ))\n    # for simplicity restrict to inference for a single param\n    @assert length(_pname) == 1\n    pname = first(_pname)\n    θ = collect(values(_θ))\n\n    # setting the initial guess θ inside the recording\n    OBS.set_parameters!(all_obs, _θ)\n    @assert num_recordings(all_obs) == 1\n    recording = first(all_obs.recordings)\n\n    # setting up containers\n    num_obs = length(recording.obs)\n    tts = OBS.setup_time_grids(recording, dt, standard_guid_prop_time_transf)\n    sp = SamplingPair(AuxLaw, recording, tts)\n    bb = BiBlock(sp, 1:num_obs, ρ, true, num_steps)\n    name_struct = ParamNamesBlock(\n        bb.b, _pname, first(all_obs.param_depend_rev),\n        first(all_obs.obs_depend_rev)\n    )\n\n    loglikhd!(bb)\n    paths = []\n\n    θθ = [θ]\n    a_h = Bool[]\n\n    for i in 1:num_steps\n        draw_proposal_path!(bb)\n        accept_reject_proposal_path!(bb, i)\n\n        θ° = customkernel(θ, ϵ)\n        set_proposal_law!(bb, θ°, name_struct, true)\n\n        accpt, θ = accept_reject_proposal_param!(bb, i, θ, θ°)\n        push!(θθ, θ)\n        push!(a_h, accpt)\n\n        # progress message\n        if i % 100 == 0\n            println(\n                \"$i. ll=$(ll_of_accepted(bb, i)), \",\n                \"imp a-r: \",\n                \" $(accpt_rate(bb, (i-99):i)), \",\n                \"updt a-r: \",\n                \"$(sum(a_h[(i-99):i])/100).\"\n            )\n        end\n\n        # save intermediate path for plotting\n        i % 400 == 0 && append!(paths, [deepcopy(sp.u.XX)])\n    end\n    paths, θθ\nend","category":"page"},{"location":"tutorials/pnames/inference_with_biblock/","page":"Inference with BiBlocks","title":"Inference with BiBlocks","text":"θ = OrderedDict(:REC1_γ=>1.5)\n\npaths, θθ = simple_inference(\n    FitzHughNagumoAux, all_obs, 0.001, θ; ϵ=0.3, ρ=0.96, num_steps=10^4\n)","category":"page"},{"location":"manual/block/#Block","page":"Block","title":"Block","text":"","category":"section"},{"location":"manual/block/","page":"Block","title":"Block","text":"","category":"page"},{"location":"manual/block/","page":"Block","title":"Block","text":"A smallest unit that is needed for blocking.","category":"page"},{"location":"manual/block/","page":"Block","title":"Block","text":"DiffusionMCMCTools.Block","category":"page"},{"location":"manual/block/#DiffusionMCMCTools.Block","page":"Block","title":"DiffusionMCMCTools.Block","text":"mutable struct Block{L,TGP,TGPl,TW,TWn,TX}\n    PP::TVIEW{TGP}\n    P_last::TVIEW{TGPl} # view into a single element\n    WW::TVIEW{TW}\n    Wnr::TWn\n    XX::TVIEW{TX}\n    ll::Float64\n    ll_history::Vector{Float64}\nend\n\nThe smallest \"containerless\" unit that provides a view into SamplingUnit restricted to a range i:j of a block. L is an important flag that indicates whether it is a terminal block or not.\n\nFields\n\n\n\nPP: a vector of views into relevant GuidProp\nP_last: a view into a single (or none) GuidProp corresponding to the           terminal sub-interval.\nWW: a vector of views into containers for sampled Wiener process\nWnr: a flag for sampling Wiener processes\nXX: a vector of views into containers for a sampled process\nll: a placeholder for computed log-likelihood\nll_history: a history of computed log-likelihoods (useful for MCMC)\n\nfunction Block(\n    u::SamplingUnit,\n    range::UnitRange{Int64},\n    last_block=false,\n    ll_hist_len=0\n)\n\nBase constructor.\n\n\n\n\n\n","category":"type"},{"location":"manual/block/","page":"Block","title":"Block","text":"It is rarely used on its own. Instead, it is used mainly as a building block of other, composite units. Nevertheless, there are a couple of useful functions implemented for it:","category":"page"},{"location":"manual/block/","page":"Block","title":"Block","text":"DiffusionMCMCTools.set_ll!(b::DiffusionMCMCTools.Block, i::Int, v)\nDiffusionMCMCTools.save_ll!(b::DiffusionMCMCTools.Block, i::Int)\nDiffusionMCMCTools.recompute_guiding_term!(b::DiffusionMCMCTools.Block)\nDiffusionMCMCTools.find_W_for_X!(b::DiffusionMCMCTools.Block)\nDiffusionMCMCTools.loglikhd(b::DiffusionMCMCTools.Block)\nDiffusionMCMCTools.loglikhd!(b::DiffusionMCMCTools.Block)\nDiffusionMCMCTools.recompute_path!(b::DiffusionMCMCTools.Block, WW=b.WW; skip=0)","category":"page"},{"location":"manual/block/#DiffusionMCMCTools.set_ll!-Tuple{Block,Int64,Any}","page":"Block","title":"DiffusionMCMCTools.set_ll!","text":"set_ll!(b::Block, i::Int, v)\n\nSet the internal log-likelihood history field b.ll_history[i] with a value v\n\n\n\n\n\n","category":"method"},{"location":"manual/block/#DiffusionMCMCTools.save_ll!-Tuple{Block,Int64}","page":"Block","title":"DiffusionMCMCTools.save_ll!","text":"save_ll!(b::Block, i::Int)\n\nCommit the current log-likelihood field ll to history b.ll_history at index i.\n\n\n\n\n\n","category":"method"},{"location":"manual/block/#GuidedProposals.recompute_guiding_term!-Tuple{Block}","page":"Block","title":"GuidedProposals.recompute_guiding_term!","text":"GP.recompute_guiding_term!(b::Block)\n\nRecompute the guiding term.\n\n\n\n\n\n","category":"method"},{"location":"manual/block/#DiffusionMCMCTools.find_W_for_X!-Tuple{Block}","page":"Block","title":"DiffusionMCMCTools.find_W_for_X!","text":"find_W_for_X!(b::Block)\n\nCompute the Wiener process b.WW that is needed for obtaining path b.XX under the law stored in b.\n\n\n\n\n\n","category":"method"},{"location":"manual/block/#GuidedProposals.loglikhd-Tuple{Block}","page":"Block","title":"GuidedProposals.loglikhd","text":"GP.loglikhd(b::Block)\n\nCompute the log-likelihood evaluated at a sampled path.\n\n\n\n\n\n","category":"method"},{"location":"manual/block/#DiffusionMCMCTools.loglikhd!-Tuple{Block}","page":"Block","title":"DiffusionMCMCTools.loglikhd!","text":"loglikhd!(b::Block)\n\nCompute the log-likelihood evaluated at a sampled path and store the result in an internal field ll.\n\n\n\n\n\n","category":"method"},{"location":"manual/block/#DiffusionMCMCTools.recompute_path!","page":"Block","title":"DiffusionMCMCTools.recompute_path!","text":"recompute_path!(b::Block, WW=b.WW; skip=0)\n\nRecompute the path b.XX for a given wiener process WW.\n\n\n\n\n\n","category":"function"},{"location":"manual/param_names_collections/#Containers-for-parameter-names","page":"Containers for parameter names","title":"Containers for parameter names","text":"","category":"section"},{"location":"manual/param_names_collections/","page":"Containers for parameter names","title":"Containers for parameter names","text":"","category":"page"},{"location":"manual/param_names_collections/","page":"Containers for parameter names","title":"Containers for parameter names","text":"DiffusionMCMCTools.ParamNamesUnit\nDiffusionMCMCTools.ParamNamesBlock\nDiffusionMCMCTools.ParamNamesRecording\nDiffusionMCMCTools.ParamNamesAllObs","category":"page"},{"location":"manual/param_names_collections/#DiffusionMCMCTools.ParamNamesUnit","page":"Containers for parameter names","title":"DiffusionMCMCTools.ParamNamesUnit","text":"struct ParamNamesUnit{N1,N2}\n    var::NTuple{N1,Symbol}\n    var_aux::Vector{Tuple{Vararg{Symbol,_N} where _N}}\n    updt::NTuple{N2,Pair{Int64,Symbol}}\n    updt_aux::Vector{Tuple{Vararg{Pair{Int64,Symbol},_N} where _N}}\n    updt_obs::Vector{Tuple{Vararg{Pair{Int64,Int64},_N} where _N}}\nend\n\nSmallest unit storing information about the names of the parameters that are supposed to be updated at a given step of the MCMC algorithm. It is pertinent to a single block of a single recording only, and in particular, only to a single collection of laws, out of:\n\nPP, i.e. those relevant to a given block\nP_last, i.e. the artificial law of the block associated with the last obs\nP_excl, i.e. the last, missed out PP, missed out due to use of P_last\nPPb, i.e. the collection of all remaining artificial laws that are not        P_last\n\nIt stores lists of parameters that are supposed to be updated at various stages of the call to a function set_proposal_law!, which sets the proposal parameter θ° inside the proposal laws.\n\nFields\n\nvar: names of P_target that are checked and—if need be—equalized between        proposal and accepted laws\nvar_aux: names of P_aux that are checked and—if need be—equalized between            proposal and accepted laws\nupdt: list of params of P_target that are being updated at a given MCMC         step; listed as pairs: idx-of-θ-to-relevant-value =>         name-of-param-inside-P_target-struct\nupdt_aux: as above, but for P_aux\nupdt_obs: list of params of obs (i.e. terminal observation for each guid             prop) that are being updated at a given MCMC step; listed as             pairs: idx-of-θ-to-relevant-value => idx-of-obs-inside-obs.θ\n\nParamNamesUnit(\n    PP::AbstractArray{<:GuidProp}, θnames::Vector{Symbol}, pdep, odeps\n)\n\nBase constructor.\n\nArguments\n\nPP:\nθnames:\npdep:\nodeps:\n\n\n\n\n\n","category":"type"},{"location":"manual/param_names_collections/#DiffusionMCMCTools.ParamNamesBlock","page":"Containers for parameter names","title":"DiffusionMCMCTools.ParamNamesBlock","text":"struct ParamNamesBlock{N1,N2}\n    PP::ParamNamesUnit{N1,N2}\n    P_last::ParamNamesUnit{N1,N2}\n    P_excl::ParamNamesUnit{N1,N2}\n    Pb_excl::ParamNamesUnit{N1,N2}\nend\n\nStores information relevant for a Block about the names of the parameters that are supposed to be updated at a given step of the MCMC algorithm. It stores lists of parameters that are supposed to be updated at various stages of the call to a function set_proposal_law!, which sets the proposal parameter θ° inside the proposal laws.\n\nFields\n\nPP, i.e. those relevant to a given block\nP_last, i.e. the artificial law of the block associated with the last obs\nP_excl, i.e. the last, missed out PP, missed out due to use of P_last\nPb_excl, i.e. the collection of all remaining artificial laws that are not            P_last\nParamNamesBlock(b::Block, θnames, pdep, odeps)\n\nBase constructor.\n\nArguments\n\nb::Block:\nθnames:\npdep:\nodeps:\n\n\n\n\n\n","category":"type"},{"location":"manual/param_names_collections/#DiffusionMCMCTools.ParamNamesRecording","page":"Containers for parameter names","title":"DiffusionMCMCTools.ParamNamesRecording","text":"struct ParamNamesRecording{N1,N2}\n    blocks::Vector{ParamNamesBlock{N1,N2}}\nend\n\nStores information relevant for an entire, single recording about the names of the parameters that are supposed to be updated at a given step of the MCMC algorithm. It stores lists of parameters that are supposed to be updated at various stages of the call to a function set_proposal_law!, which sets the proposal parameter θ° inside the proposal laws.\n\nParamNamesRecording(rb::BlockCollection, θnames, pdep, odeps)\n\nBase constructor.\n\n\n\n\n\n","category":"type"},{"location":"manual/param_names_collections/#DiffusionMCMCTools.ParamNamesAllObs","page":"Containers for parameter names","title":"DiffusionMCMCTools.ParamNamesAllObs","text":"struct ParamNamesAllObs{T}\n    recordings::Vector{T}\nend\n\nStores information relevant for multiple recordings about the names of the parameters that are supposed to be updated at a given step of the MCMC algorithm. It stores lists of parameters that are supposed to be updated at various stages of the call to a function set_proposal_law!, which sets the proposal parameter θ° inside the proposal laws.\n\nParamNamesAllObs(be::BlockEnsemble, θnames, all_obs)\n\nBase constructor.\n\n\n\n\n\n","category":"type"},{"location":"manual/block_collection/#block_collection_def","page":"BlockCollection","title":"BlockCollection","text":"","category":"section"},{"location":"manual/block_collection/","page":"BlockCollection","title":"BlockCollection","text":"","category":"page"},{"location":"manual/block_collection/","page":"BlockCollection","title":"BlockCollection","text":"DiffusionMCMCTools.BlockCollection","category":"page"},{"location":"manual/block_collection/#DiffusionMCMCTools.BlockCollection","page":"BlockCollection","title":"DiffusionMCMCTools.BlockCollection","text":"struct BlockCollection{TGP,TGPl,TW,TWn,TX}\n    blocks::Vector{BiBlock{_L,TGP,TGPl,TW,TWn,TX} where _L}\nend\n\nGathers all blocks relevant for an entire single recording.\n\nBlockCollection(\n    sp::SamplingPair{TGP,TGPl,TW,TWn,TX},\n    ranges,\n    ρρ=0.0,\n    ll_hist_len=0\n) where {TGP,TGPl,TW,TWn,TX}\n\nBase constructor.\n\n\n\n\n\n","category":"type"},{"location":"manual/block_collection/#Imputation","page":"BlockCollection","title":"Imputation","text":"","category":"section"},{"location":"manual/block_collection/","page":"BlockCollection","title":"BlockCollection","text":"DiffusionMCMCTools.draw_proposal_path!(bc::DiffusionMCMCTools.BlockCollection)","category":"page"},{"location":"manual/block_collection/#DiffusionMCMCTools.draw_proposal_path!-Tuple{BlockCollection}","page":"BlockCollection","title":"DiffusionMCMCTools.draw_proposal_path!","text":"draw_proposal_path!(bc::BlockCollection)\n\nSample proposal paths on each block, compute log-likelihoods along the way. Assumes bc.blocks[i].b.XX[1].x[1] are starting points for each block. Uses the preconditioned Crank-Nicolson scheme.\n\n\n\n\n\n","category":"method"},{"location":"manual/block_collection/#Accept/reject-decision","page":"BlockCollection","title":"Accept/reject decision","text":"","category":"section"},{"location":"manual/block_collection/","page":"BlockCollection","title":"BlockCollection","text":"DiffusionMCMCTools.accept_reject_proposal_path!(bb::DiffusionMCMCTools.BlockCollection, mcmciter)","category":"page"},{"location":"manual/block_collection/#DiffusionMCMCTools.accept_reject_proposal_path!-Tuple{BlockCollection,Any}","page":"BlockCollection","title":"DiffusionMCMCTools.accept_reject_proposal_path!","text":"accept_reject_proposal_path!(bc::BlockCollection, mcmciter)\n\nAccept/reject decision of the Metropolis-Hastings algorithm for the step of path imputation, done separately for each block.\n\n\n\n\n\n","category":"method"},{"location":"manual/block_collection/#Swaps","page":"BlockCollection","title":"Swaps","text":"","category":"section"},{"location":"manual/block_collection/","page":"BlockCollection","title":"BlockCollection","text":"DiffusionMCMCTools.swap_paths!(bc::DiffusionMCMCTools.BlockCollection)\nDiffusionMCMCTools.swap_XX!(bc::DiffusionMCMCTools.BlockCollection)\nDiffusionMCMCTools.swap_WW!(bc::DiffusionMCMCTools.BlockCollection)\nDiffusionMCMCTools.swap_PP!(bc::DiffusionMCMCTools.BlockCollection)\nDiffusionMCMCTools.swap_ll!(bc::DiffusionMCMCTools.BlockCollection)","category":"page"},{"location":"manual/block_collection/#DiffusionMCMCTools.swap_paths!-Tuple{BlockCollection}","page":"BlockCollection","title":"DiffusionMCMCTools.swap_paths!","text":"swap_paths!(bc::BlockCollection)\n\nFor each block in the collection swap XX and WW containers between proposal-acceptance pair.\n\n\n\n\n\n","category":"method"},{"location":"manual/block_collection/#DiffusionMCMCTools.swap_XX!-Tuple{BlockCollection}","page":"BlockCollection","title":"DiffusionMCMCTools.swap_XX!","text":"swap_XX!(bc::BlockCollection)\n\nFor each block in the collection swap XX containers between proposal-acceptance pair.\n\n\n\n\n\n","category":"method"},{"location":"manual/block_collection/#DiffusionMCMCTools.swap_WW!-Tuple{BlockCollection}","page":"BlockCollection","title":"DiffusionMCMCTools.swap_WW!","text":"swap_WW!(bc::BlockCollection)\n\nFor each block in the collection swap WW containers between proposal-acceptance pair.\n\n\n\n\n\n","category":"method"},{"location":"manual/block_collection/#DiffusionMCMCTools.swap_PP!-Tuple{BlockCollection}","page":"BlockCollection","title":"DiffusionMCMCTools.swap_PP!","text":"swap_PP!(bc::BlockCollection)\n\nFor each block in the collection swap PP containers between proposal-acceptance pair.\n\n\n\n\n\n","category":"method"},{"location":"manual/block_collection/#DiffusionMCMCTools.swap_ll!-Tuple{BlockCollection}","page":"BlockCollection","title":"DiffusionMCMCTools.swap_ll!","text":"swap_ll!(bc::BlockCollection)\n\nFor each block in the collection swap ll fields between proposal-acceptance pair.\n\n\n\n\n\n","category":"method"},{"location":"manual/block_collection/#Setting-up-a-block","page":"BlockCollection","title":"Setting up a block","text":"","category":"section"},{"location":"manual/block_collection/","page":"BlockCollection","title":"BlockCollection","text":"DiffusionMCMCTools.set_obs!(bc::DiffusionMCMCTools.BlockCollection)","category":"page"},{"location":"manual/block_collection/#GuidedProposals.set_obs!-Tuple{BlockCollection}","page":"BlockCollection","title":"GuidedProposals.set_obs!","text":"GP.set_obs!(bc::BlockCollection)\n\nFreeze an artificial observation at the terminal point of each block. For a terminal block nothing is done.\n\n\n\n\n\n","category":"method"},{"location":"manual/block_collection/#utility","page":"BlockCollection","title":"utility","text":"","category":"section"},{"location":"manual/block_collection/","page":"BlockCollection","title":"BlockCollection","text":"DiffusionMCMCTools.loglikhd!(bc::DiffusionMCMCTools.BlockCollection)\nDiffusionMCMCTools.loglikhd°!(bc::DiffusionMCMCTools.BlockCollection)\nDiffusionMCMCTools.fetch_ll(bc::DiffusionMCMCTools.BlockCollection)\nDiffusionMCMCTools.fetch_ll°(bc::DiffusionMCMCTools.BlockCollection)\nDiffusionMCMCTools.save_ll!(bc::DiffusionMCMCTools.BlockCollection, i::Int)\nDiffusionMCMCTools.ll_of_accepted(bb::DiffusionMCMCTools.BlockCollection, i)\nDiffusionMCMCTools.accpt_rate(bb::DiffusionMCMCTools.BlockCollection, range)","category":"page"},{"location":"manual/block_collection/#DiffusionMCMCTools.loglikhd!-Tuple{BlockCollection}","page":"BlockCollection","title":"DiffusionMCMCTools.loglikhd!","text":"loglikhd!(bc::BlockCollection)\n\nFor each BiBlock in a collection compute the log-likelihood for the accepted block, evaluated at a sampled path and store the result in internal fields ll.\n\n\n\n\n\n","category":"method"},{"location":"manual/block_collection/#DiffusionMCMCTools.loglikhd°!-Tuple{BlockCollection}","page":"BlockCollection","title":"DiffusionMCMCTools.loglikhd°!","text":"loglikhd°!(bc::BlockCollection)\n\nFor each BiBlock in a collection compute the log-likelihood for the proposal block, evaluated at a sampled path and store the result in internal fields ll.\n\n\n\n\n\n","category":"method"},{"location":"manual/block_collection/#DiffusionMCMCTools.fetch_ll-Tuple{BlockCollection}","page":"BlockCollection","title":"DiffusionMCMCTools.fetch_ll","text":"fetch_ll(bc::BlockCollection)\n\nRetreive the log-likelihood for the entire accepted path.\n\nwarning: Warning\nThe function uses only internal fields ll for this computation, which means that for the call to this function to make sense the log-likelihood must have been previously computed and stored in the field ll. If it hasn't been done, then you must first call loglikhd!(bc).\n\n\n\n\n\n","category":"method"},{"location":"manual/block_collection/#DiffusionMCMCTools.fetch_ll°-Tuple{BlockCollection}","page":"BlockCollection","title":"DiffusionMCMCTools.fetch_ll°","text":"fetch_ll°(bc::BlockCollection)\n\nRetreive the log-likelihood for the entire proposed path.\n\nwarning: Warning\nThe function uses only internal fields ll for this computation, which means that for the call to this function to make sense the log-likelihood must have been previously computed and stored in the field ll. If it hasn't been done, then you must first call loglikhd°!(bc).\n\n\n\n\n\n","category":"method"},{"location":"manual/block_collection/#DiffusionMCMCTools.save_ll!-Tuple{BlockCollection,Int64}","page":"BlockCollection","title":"DiffusionMCMCTools.save_ll!","text":"save_ll!(bc::BlockCollection, i::Int)\n\nFor each block in the collection commit the current proposal and accepted log-likelihood fields ll to history, at index i.\n\n\n\n\n\n","category":"method"},{"location":"manual/block_collection/#DiffusionMCMCTools.ll_of_accepted-Tuple{BlockCollection,Any}","page":"BlockCollection","title":"DiffusionMCMCTools.ll_of_accepted","text":"ll_of_accepted(bb::BlockCollection, i)\n\nReturn an array of log-likelihoods (one for each block) of the paths that were accepted at the ith iteration.\n\n\n\n\n\n","category":"method"},{"location":"manual/block_collection/#DiffusionMCMCTools.accpt_rate-Tuple{BlockCollection,Any}","page":"BlockCollection","title":"DiffusionMCMCTools.accpt_rate","text":"accpt_rate(bb::BlockCollection, range)\n\nCompute the acceptance rate over the range of MCMC accept/reject history for each block in the collection.\n\n\n\n\n\n","category":"method"},{"location":"manual/block_collection/#Setting-parameters","page":"BlockCollection","title":"Setting parameters","text":"","category":"section"},{"location":"manual/block_collection/","page":"BlockCollection","title":"BlockCollection","text":"DiffusionMCMCTools.set_proposal_law!(\n    bc::DiffusionMCMCTools.BlockCollection,\n    θ°,\n    pnames,\n    critical_change=GP.is_critical_update(bc, pnames);\n    skip=0\n)","category":"page"},{"location":"manual/block_collection/#DiffusionMCMCTools.set_proposal_law!","page":"BlockCollection","title":"DiffusionMCMCTools.set_proposal_law!","text":"set_proposal_law!(\n    bc::BlockCollection,\n    θ°,\n    pnames,\n    critical_change=GP.is_critical_update(bc, pnames);\n    skip=0\n)\n\nFor each block in the collection set the parameters in bb.b°.PP and bb.b°.P_last to θ° and make sure that all other parameters are shared with bb.b.PP and bb.b.P_last. Recompute the guiding term if needed, and then, compute the proposal trajectory bb.b°.XX for the proposal point θ°.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/biblock/inference_with_blocking/#Inference-with-blocking-with-BiBlocks","page":"Inference with blocking","title":"Inference with blocking with BiBlocks","text":"","category":"section"},{"location":"tutorials/biblock/inference_with_blocking/","page":"Inference with blocking","title":"Inference with blocking","text":"","category":"page"},{"location":"tutorials/biblock/inference_with_blocking/","page":"Inference with blocking","title":"Inference with blocking","text":"note: important\nMake sure that you read the preamble before you start reading this tutorial.","category":"page"},{"location":"tutorials/biblock/inference_with_blocking/#The-algorithm","page":"Inference with blocking","title":"The algorithm","text":"","category":"section"},{"location":"tutorials/biblock/inference_with_blocking/","page":"Inference with blocking","title":"Inference with blocking","text":"","category":"page"},{"location":"tutorials/biblock/inference_with_blocking/","page":"Inference with blocking","title":"Inference with blocking","text":"#↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓\nfunction simple_name_structure_not_last(pname::Symbol, num_obs)\n    pnames = (\n        PP = _build_struct(num_obs-1, (1=>pname)),\n        P_last = _build_struct(1, (1=>pname)),\n        P_excl = _build_struct(1, (1=>pname)),\n        Pb_excl = _build_struct(num_obs-1, (1=>pname)),\n    )\nend\n\nfunction simple_name_structure_blocking(pname::Symbol, block_layout)\n    map(block_layout) do block_set\n        map(enumerate(block_set)) do (i, block)\n            (\n                i == length(block_set) ?\n                simple_name_structure(pname, length(block)) :\n                simple_name_structure_not_last(pname, length(block))\n            )\n        end\n    end\nend\n#↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑\n\nfunction accept_reject_proposal_param!(B::AbstractArray{<:BiBlock}, mcmciter, θ, θ°)\n    accepted = rand(Exponential(1.0)) > mapreduce(bb->-(bb.b°.ll - bb.b.ll),+,B)\n    accepted && swap_XX!.(B)\n    accepted && swap_PP!.(B)\n    (bb->save_ll!(bb.b, mcmciter)).(B)\n    (bb->save_ll!(bb.b°, mcmciter)).(B)\n    accepted && swap_ll!.(B)\n    accepted, copy(accepted ? θ° : θ)\nend\n\n\nfunction simple_inference_with_blocking(\n        AuxLaw, recording, dt, AuxLawBlocking, block_layout, _θ;\n        ϵ=0.3, ρ=0.5, num_steps=10^4\n    )\n    # making sure that things are in order...\n    _pname = collect(keys(_θ))\n    # for simplicity restrict to inference for a single param\n    @assert length(_pname) == 1\n    pname = first(_pname)\n    θ = collect(values(_θ))\n\n    # setting the initial guess θ inside the recording\n    OBS.set_parameters!(recording, _θ)\n\n    # setting up containers\n    tts = OBS.setup_time_grids(recording, dt, standard_guid_prop_time_transf)\n    sp = SamplingPair(AuxLaw, recording, tts)\n    blocks = [\n        [\n            BiBlock(sp, br, ρ, i==length(block_ranges), num_steps)\n            for (i,br) in enumerate(block_ranges)\n        ] for block_ranges in block_layout\n    ]\n    name_struct = simple_name_structure_blocking(pname, block_layout)\n\n    paths = []\n\n    θθ = [θ]\n    a_h = Bool[]\n\n    # MCMC\n    for i in 1:num_steps\n        for B in blocks\n            GP.set_obs!.(B)\n            (bb->recompute_guiding_term!(bb.b)).(B)\n            find_W_for_X!.(B)\n            loglikhd!.(B)\n            draw_proposal_path!.(B)\n            accept_reject_proposal_path!.(B, i)\n\n            # progress message\n            if i % 100 == 0\n                println(\n                    \"$i. ll=$(ll_of_accepted.(B, i)), acceptance rate: \",\n                    \"$( map(bb->accpt_rate(bb, (i-99):i), B) )\"\n                )\n            end\n        end\n\n        θ° = customkernel(θ, ϵ)\n\n        B = blocks[end]\n        for (idx, bb) in enumerate(B)\n            set_proposal_law!(bb, θ°, name_struct[end][idx], true)\n        end\n        (bb->recompute_guiding_term!(bb.b°)).(B)\n\n        accpt, θ = accept_reject_proposal_param!(B, i, θ, θ°)\n        push!(θθ, θ)\n        push!(a_h, accpt)\n\n        if i % 100 == 0\n            println(\n                \"$i. updt a-r: \",\n                \"$(sum(a_h[(i-99):i])/100).\"\n            )\n        end\n\n        # save intermediate path for plotting\n        i % 400 == 0 && append!(paths, [deepcopy(sp.u.XX)])\n    end\n    paths, θθ\nend","category":"page"},{"location":"tutorials/biblock/inference_with_blocking/","page":"Inference with blocking","title":"Inference with blocking","text":"θ = OrderedDict(:γ=>1.5)\npaths, θθ = simple_inference_with_blocking(\n    FitzHughNagumoAux, recording, 0.001, FitzHughNagumoAux,\n    [[1:25,26:75,76:100],[1:50, 51:100]], θ; ϵ=0.3, ρ=0.96, num_steps=10^4\n)","category":"page"},{"location":"tutorials/biblock/inference_with_blocking/#Results","page":"Inference with blocking","title":"Results","text":"","category":"section"},{"location":"tutorials/biblock/inference_with_blocking/","page":"Inference with blocking","title":"Inference with blocking","text":"","category":"page"},{"location":"tutorials/biblock/inference_with_blocking/","page":"Inference with blocking","title":"Inference with blocking","text":"plot(getindex.(θθ, 1))","category":"page"},{"location":"tutorials/biblock/inference_with_blocking/","page":"Inference with blocking","title":"Inference with blocking","text":"(Image: inference_with_blocking_chain)","category":"page"},{"location":"tutorials/block_collection/inference_with_blocking/#Inference-with-blocking-with-BlockCollection","page":"Inference with blocking","title":"Inference with blocking with BlockCollection","text":"","category":"section"},{"location":"tutorials/block_collection/inference_with_blocking/","page":"Inference with blocking","title":"Inference with blocking","text":"","category":"page"},{"location":"tutorials/block_collection/inference_with_blocking/","page":"Inference with blocking","title":"Inference with blocking","text":"function accept_reject_proposal_param!(bc::BlockCollection, mcmciter, θ, θ°)\n    accepted = rand(Exponential(1.0)) > -(fetch_ll°(bc) - fetch_ll(bc))\n    accepted && swap_XX!(bc)\n    accepted && swap_PP!(bc)\n    save_ll!(bc, mcmciter)\n    accepted && swap_ll!(bc)\n    accepted, copy(accepted ? θ° : θ)\nend\n\nfunction simple_inference_with_blocking(\n        AuxLaw, all_obs, dt, AuxLawBlocking, block_layout, _θ;\n        ϵ=0.3, ρ=0.5, num_steps=10^4\n    )\n    # making sure that things are in order...\n    _pname = collect(keys(_θ))\n    # for simplicity restrict to inference for a single param\n    @assert length(_pname) == 1\n    pname = first(_pname)\n    θ = collect(values(_θ))\n\n    # setting the initial guess θ inside the recording\n    OBS.set_parameters!(all_obs, _θ)\n    @assert num_recordings(all_obs) == 1\n    recording = first(all_obs.recordings)\n\n    # setting up containers\n    tts = OBS.setup_time_grids(recording, dt, standard_guid_prop_time_transf)\n    sp = SamplingPair(AuxLaw, recording, tts)\n    blocks = [\n        BlockCollection(sp, block_ranges, ρ, num_steps)\n        for block_ranges in block_layout\n    ]\n    name_struct = [\n        ParamNamesRecording(\n            bc, _pname, first(all_obs.param_depend_rev),\n            first(all_obs.obs_depend_rev)\n        ) for bc in blocks\n    ]\n\n    paths = []\n\n    θθ = [θ]\n    a_h = Bool[]\n    crit_change = [fill(true, length(bc.blocks)) for bc in blocks]\n\n    # MCMC\n    for i in 1:num_steps\n        for bc in blocks\n            GP.set_obs!(bc)\n            recompute_guiding_term!(bc, Val(:P_only))\n            find_W_for_X!(bc)\n            loglikhd!(bc)\n            draw_proposal_path!(bc)\n            accept_reject_proposal_path!(bc, i)\n\n            # progress message\n            if i % 100 == 0\n                println(\n                    \"$i. ll=$(ll_of_accepted(bc, i)), acceptance rate: \",\n                    \"$( accpt_rate(bc, (i-99):i) )\"\n                )\n            end\n        end\n\n        θ° = customkernel(θ, ϵ)\n\n        bc = blocks[end]\n        set_proposal_law!(bc, θ°, name_struct[end], crit_change[end])\n        recompute_guiding_term!(bc, Val(:P°_only))\n\n        accpt, θ = accept_reject_proposal_param!(bc, i, θ, θ°)\n        push!(θθ, θ)\n        push!(a_h, accpt)\n\n        if i % 100 == 0\n            println(\n                \"$i. updt a-r: \",\n                \"$(sum(a_h[(i-99):i])/100).\"\n            )\n        end\n\n        # save intermediate path for plotting\n        i % 400 == 0 && append!(paths, [deepcopy(sp.u.XX)])\n    end\n    paths, θθ\nend","category":"page"},{"location":"manual/sampling_ensemble/#SamplingEnsemble","page":"SamplingEnsemble","title":"SamplingEnsemble","text":"","category":"section"},{"location":"manual/sampling_ensemble/","page":"SamplingEnsemble","title":"SamplingEnsemble","text":"","category":"page"},{"location":"manual/sampling_ensemble/","page":"SamplingEnsemble","title":"SamplingEnsemble","text":"DiffusionMCMCTools.SamplingEnsemble","category":"page"},{"location":"manual/sampling_ensemble/#DiffusionMCMCTools.SamplingEnsemble","page":"SamplingEnsemble","title":"DiffusionMCMCTools.SamplingEnsemble","text":"struct SamplingEnsemble{T}\n    recordings::Vector{T}\nend\n\nA collection of SamplingPairs, can be used for smoothing or inference problems.\n\nSamplingEnsemble(\n    aux_laws, recordings, tts, args=tuple();\n    aux_laws_blocking=aux_laws, artificial_noise=1e-11,\n    solver_choice_blocking=args\n)\n\nBase constructor.\n\n\n\n\n\n","category":"type"},{"location":"tutorials/block_ensemble/inference/#Inference-with-BlockEnsemble","page":"Inference","title":"Inference with BlockEnsemble","text":"","category":"section"},{"location":"tutorials/block_ensemble/inference/","page":"Inference","title":"Inference","text":"","category":"page"},{"location":"tutorials/block_ensemble/inference/#Set-up","page":"Inference","title":"Set up","text":"","category":"section"},{"location":"tutorials/block_ensemble/inference/","page":"Inference","title":"Inference","text":"using GuidedProposals, DiffusionDefinition, ObservationSchemes, DiffusionMCMCTools\nconst GP = GuidedProposals\nconst DD = DiffusionDefinition\nconst OBS = ObservationSchemes\nconst dMCMCt = DiffusionMCMCTools\n\nusing StaticArrays, Random, Plots, Distributions\n\n# seed used for this tutorial\nRandom.seed!(100)\n\n@load_diffusion FitzHughNagumo\nθ = [0.1, -0.8, 1.5, 0.0, 0.3]\nP = FitzHughNagumo(θ...)\ntt, y1 = 0.0:0.0001:10.0, @SVector [-0.9, -1.0]\nnum_recs = 2\nXs = [rand(P, tt, y1) for i in 1:num_recs]\nobs_scheme = ObsScheme(\n    LinearGsnObs(\n        0.0, (@SVector [0.0]);\n        L=(@SMatrix [1.0 0.0]),\n        Σ=(@SMatrix [0.01])\n    )\n)\ndata = [collect(obs_scheme, Xs[i], 1000) for i in 1:num_recs]\n\nall_obs = AllObservations()\nadd_recordings!(\n    all_obs,\n    [build_recording(P, data[i], 0.0, KnownStartingPt(y1)) for i in 1:num_recs]\n)\nadd_dependency!(\n    all_obs,\n    Dict(\n        :γ_shared => [(1, :γ), (2, :γ)],\n    )\n)\nDD.var_parameter_names(::FitzHughNagumo) = (:γ,)\nall_obs, _ = initialize(all_obs)\n\n\n\nps = [plot(Xs[i], Val(:vs_time)) for i in 1:num_recs]\n[scatter!(ps[i], map(x->x.t, data[i]), map(x->x.obs[1], data[i]), label=\"data\") for i in 1:num_recs]\nplot(ps..., layout=(num_recs,1), size=(800, 300*num_recs))","category":"page"},{"location":"tutorials/block_ensemble/inference/","page":"Inference","title":"Inference","text":"(Image: inference_data)","category":"page"},{"location":"tutorials/block_ensemble/inference/#The-algorithm","page":"Inference","title":"The algorithm","text":"","category":"section"},{"location":"tutorials/block_ensemble/inference/","page":"Inference","title":"Inference","text":"customkernel(θ, scale=0.1) = θ .+ 2.0*scale*(rand()-0.5)\n\nfunction accept_reject_proposal_param!(bc, mcmciter, θ, θ°)\n    accepted = rand(Exponential(1.0)) > -(fetch_ll°(bc)-fetch_ll(bc))\n    accepted && swap_XX!(bc)\n    accepted && swap_PP!(bc)\n    save_ll!(bc, mcmciter)\n    accepted && swap_ll!(bc)\n    accepted, copy(accepted ? θ° : θ)\nend\n\nfunction simple_inference(AuxLaw, all_obs, dt, _θ; ϵ=0.3, ρ=0.5, num_steps=10^4)\n    # making sure that things are in order...\n    _pname = collect(keys(_θ))\n    # for simplicity restrict to inference for a single param\n    @assert length(_pname) == 1\n    pname = first(_pname)\n    θ = collect(values(_θ))\n\n    # setting the initial guess θ inside the recording\n    OBS.set_parameters!(all_obs, _θ)\n\n    # setting up containers\n    tts = OBS.setup_time_grids(all_obs, dt, standard_guid_prop_time_transf)\n    se = SamplingEnsemble(AuxLaw, all_obs.recordings, tts)\n    be = BlockEnsemble(\n        se,\n        collect([[1:length(rec.obs)] for rec in all_obs.recordings]),\n        ρ,\n        num_steps\n    )\n    name_struct = ParamNamesAllObs(be, _pname, all_obs)\n\n    loglikhd!(be)\n    paths = []\n\n    θθ = [θ]\n    a_h = Bool[]\n    crit_change = collect([[true] for rec in se.recordings])\n\n    for i in 1:num_steps\n        draw_proposal_path!(be)\n        accept_reject_proposal_path!(be, i)\n\n        θ° = customkernel(θ, ϵ)\n        set_proposal_law!(be, θ°, name_struct, crit_change)\n\n        accpt, θ = accept_reject_proposal_param!(be, i, θ, θ°)\n        push!(θθ, θ)\n        push!(a_h, accpt)\n\n        # progress message\n        if i % 100 == 0\n            println(\n                \"$i. ll=$(ll_of_accepted(be, i)), \",\n                \"imp a-r: \",\n                \" $(accpt_rate(be, (i-99):i)), \",\n                \"updt a-r: \",\n                \"$(sum(a_h[(i-99):i])/100).\"\n            )\n        end\n\n        # save intermediate path for plotting\n        i % 400 == 0 && append!(\n            paths,\n            [[deepcopy(rec.u.XX) for rec in se.recordings]]\n        )\n    end\n    paths, θθ\nend","category":"page"},{"location":"tutorials/block_ensemble/inference/#Results","page":"Inference","title":"Results","text":"","category":"section"},{"location":"tutorials/block_ensemble/inference/","page":"Inference","title":"Inference","text":"using OrderedCollections\n\nθ = OrderedDict(:γ_shared=>1.5)\n@load_diffusion FitzHughNagumoAux\nDD.var_parameter_names(::FitzHughNagumo) = (:γ,)\nDD.var_parameter_names(::FitzHughNagumoAux) = (:γ,)\npaths, θθ = simple_inference(\n    FitzHughNagumoAux, all_obs, 0.001, θ; ϵ=0.3, ρ=0.96, num_steps=10^4\n)\n\nplot(getindex.(θθ, 1))","category":"page"},{"location":"tutorials/block_ensemble/inference/","page":"Inference","title":"Inference","text":"(Image: inference_chain)","category":"page"},{"location":"tutorials/block_ensemble/inference/","page":"Inference","title":"Inference","text":"function glue_paths(XX)\n    XX_glued = trajectory(\n        glue_containers( map(x->x.t, XX) ),\n        glue_containers( map(x->x.x, XX) ),\n    )\nend\n\nfunction glue_containers(xs)\n    glued_xs = collect(Iterators.flatten(map(x->x[1:end-1], xs)))\n    append!(glued_xs, [xs[end][end]])\n    glued_xs\nend\n\nconvenient_paths = [glue_paths.(getindex.(paths, i)) for i in 1:num_recs]\n\ncol = [\"#581845\", \"#900C3F\", \"#C70039\", \"#FF5733\", \"#FFC300\"]\n\np = collect([plot() for i in 1:num_recs])\nfor i in 1:num_recs\n    for path in convenient_paths[i]\n    \tplot!(p[i], path, Val(:vs_time), alpha=0.4, label=\"\", color=[col[3] col[1]])\n    end\n    plot!(p[i], Xs[i], Val(:vs_time), color=[col[5] col[4]], linewidth=[3 0.5], label=[\"underlying X₁\" \"underlying X₂\"])\n    scatter!(p[i], map(x->x.t, data[i]), map(x->x.obs[1], data[i]), label=\"data\", markercolor=col[5])\nend\nplot(p..., layout=(num_recs, 1), size=(1000, 500*num_recs))","category":"page"},{"location":"tutorials/block_ensemble/inference/","page":"Inference","title":"Inference","text":"(Image: inference_smoothed_paths)","category":"page"},{"location":"tutorials/block_collection/inference/#Inference-with-BlockCollection","page":"Inference","title":"Inference with BlockCollection","text":"","category":"section"},{"location":"tutorials/block_collection/inference/","page":"Inference","title":"Inference","text":"","category":"page"},{"location":"tutorials/block_collection/inference/","page":"Inference","title":"Inference","text":"all_obs = AllObservations()\nadd_recording!(all_obs, build_recording(P, data, 0.0, KnownStartingPt(y1)))\nDD.var_parameter_names(::FitzHughNagumo) = (:γ,)\nall_obs, _ = initialize(all_obs)\n\ncustomkernel(θ, scale=0.1) = θ .+ 2.0*scale*(rand()-0.5)\n\n\nfunction accept_reject_proposal_param!(bc, mcmciter, θ, θ°)\n    accepted = rand(Exponential(1.0)) > -(fetch_ll°(bc)-fetch_ll(bc))\n    accepted && swap_XX!(bc)\n    accepted && swap_PP!(bc)\n    save_ll!(bc, mcmciter)\n    accepted && swap_ll!(bc)\n    accepted, copy(accepted ? θ° : θ)\nend\n\nfunction simple_inference(AuxLaw, all_obs, dt, _θ; ϵ=0.3, ρ=0.5, num_steps=10^4)\n    # making sure that things are in order...\n    _pname = collect(keys(_θ))\n    # for simplicity restrict to inference for a single param\n    @assert length(_pname) == 1\n    pname = first(_pname)\n    θ = collect(values(_θ))\n\n    # setting the initial guess θ inside the recording\n    OBS.set_parameters!(all_obs, _θ)\n    @assert num_recordings(all_obs) == 1\n    recording = first(all_obs.recordings)\n\n    # setting up containers\n    num_obs = length(recording.obs)\n    tts = OBS.setup_time_grids(recording, dt, standard_guid_prop_time_transf)\n    sp = SamplingPair(AuxLaw, recording, tts)\n    bc = BlockCollection(sp, [1:num_obs], ρ, num_steps)\n    name_struct = ParamNamesRecording(\n        bc, _pname, first(all_obs.param_depend_rev),\n        first(all_obs.obs_depend_rev)\n    )\n\n    loglikhd!(bc)\n    paths = []\n\n    θθ = [θ]\n    a_h = Bool[]\n    crit_change = [true]\n\n    for i in 1:num_steps\n        draw_proposal_path!(bc)\n        accept_reject_proposal_path!(bc, i)\n\n        θ° = customkernel(θ, ϵ)\n        set_proposal_law!(bc, θ°, name_struct, crit_change)\n\n        accpt, θ = accept_reject_proposal_param!(bc, i, θ, θ°)\n        push!(θθ, θ)\n        push!(a_h, accpt)\n\n        # progress message\n        if i % 100 == 0\n            println(\n                \"$i. ll=$(ll_of_accepted(bc, i)), \",\n                \"imp a-r: \",\n                \" $(accpt_rate(bc, (i-99):i)), \",\n                \"updt a-r: \",\n                \"$(sum(a_h[(i-99):i])/100).\"\n            )\n        end\n\n        # save intermediate path for plotting\n        i % 400 == 0 && append!(paths, [deepcopy(sp.u.XX)])\n    end\n    paths, θθ\nend","category":"page"},{"location":"tutorials/block_collection/inference/","page":"Inference","title":"Inference","text":"θ = OrderedDict(:REC1_γ=>1.5)\npaths, θθ = simple_inference(\n    FitzHughNagumoAux, all_obs, 0.001, θ; ϵ=0.3, ρ=0.96, num_steps=10^4\n)","category":"page"},{"location":"tutorials/biblock/inference/#Inference-with-BiBlocks","page":"Inference","title":"Inference with BiBlocks","text":"","category":"section"},{"location":"tutorials/biblock/inference/","page":"Inference","title":"Inference","text":"","category":"page"},{"location":"tutorials/biblock/inference/","page":"Inference","title":"Inference","text":"note: important\nMake sure that you read the preamble before you start reading this tutorial.","category":"page"},{"location":"tutorials/biblock/inference/","page":"Inference","title":"Inference","text":"Another level of complication to a smoothing algorithm, somewhat orthogonal to blocking is addition of an inference step. Let's forget about blocking for this tutorial (we will come back to it the subsequent tutorial) and focus on inference only.","category":"page"},{"location":"tutorials/biblock/inference/#The-algorithm","page":"Inference","title":"The algorithm","text":"","category":"section"},{"location":"tutorials/biblock/inference/","page":"Inference","title":"Inference","text":"","category":"page"},{"location":"tutorials/biblock/inference/","page":"Inference","title":"Inference","text":"customkernel(θ, scale=0.1) = θ .+ 2.0*scale*(rand()-0.5)\n\n#=\n    NOTE: this will appear to be completely unnecessary and coming out of the\n    blue if you are not considering more complicated settings of mixed effect\n    models. Looking up ahead into the definition of ... should be helpful if\n    you want to understand what the function below is aiming to do.\n\n    In here, we are just creating the most basic struture that is needed for\n    setting parameters. It can be much more complex if blocking, multiple\n    updates and/or mixed effect models were used.\n=#\n#↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓\n_build_struct(N, args...) = (\n    var = tuple(),\n    var_aux = fill(tuple(), N),\n    updt = tuple(args...),\n    updt_aux = fill(tuple(args...), N),\n    updt_obs = fill(tuple(), N),\n)\n\nfunction simple_name_structure(pname::Symbol, num_obs)\n    pnames = (\n        PP = _build_struct(num_obs, (1=>pname)),\n        P_last = _build_struct(0), # was num_obs\n        P_excl = _build_struct(0),\n        Pb_excl = _build_struct(num_obs, (1=>pname)),\n    )\nend\n#↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑\n\nfunction accept_reject_proposal_param!(bb, mcmciter, θ, θ°)\n    accepted = rand(Exponential(1.0)) > -(bb.b°.ll - bb.b.ll)\n    accepted && swap_XX!(bb)\n    accepted && swap_PP!(bb)\n    save_ll!(bb, mcmciter)\n    accepted && swap_ll!(bb)\n    accepted, copy(accepted ? θ° : θ)\nend\n\nfunction simple_inference(AuxLaw, recording, dt, _θ; ϵ=0.3, ρ=0.5, num_steps=10^4)\n    # making sure that things are in order...\n    _pname = collect(keys(_θ))\n    # for simplicity restrict to inference for a single param\n    @assert length(_pname) == 1\n    pname = first(_pname)\n    θ = collect(values(_θ))\n\n    # setting the initial guess θ inside the recording\n    OBS.set_parameters!(recording, _θ)\n\n    # setting up containers\n    num_obs = length(recording.obs)\n    tts = OBS.setup_time_grids(recording, dt, standard_guid_prop_time_transf)\n    sp = SamplingPair(AuxLaw, recording, tts)\n    bb = BiBlock(sp, 1:num_obs, ρ, true, num_steps)\n    name_struct = simple_name_structure(pname, num_obs)\n\n    loglikhd!(bb)\n    paths = []\n\n    θθ = [θ]\n    a_h = Bool[]\n\n    for i in 1:num_steps\n        draw_proposal_path!(bb)\n        accept_reject_proposal_path!(bb, i)\n\n        θ° = customkernel(θ, ϵ)\n        set_proposal_law!(bb, θ°, name_struct, true)\n\n        accpt, θ = accept_reject_proposal_param!(bb, i, θ, θ°)\n        push!(θθ, θ)\n        push!(a_h, accpt)\n\n        # progress message\n        if i % 100 == 0\n            println(\n                \"$i. ll=$(ll_of_accepted(bb, i)), \",\n                \"imp a-r: \",\n                \" $(accpt_rate(bb, (i-99):i)), \",\n                \"updt a-r: \",\n                \"$(sum(a_h[(i-99):i])/100).\"\n            )\n        end\n\n        # save intermediate path for plotting\n        i % 400 == 0 && append!(paths, [deepcopy(sp.u.XX)])\n    end\n    paths, θθ\nend","category":"page"},{"location":"tutorials/biblock/inference/#Results","page":"Inference","title":"Results","text":"","category":"section"},{"location":"tutorials/biblock/inference/","page":"Inference","title":"Inference","text":"","category":"page"},{"location":"tutorials/biblock/inference/","page":"Inference","title":"Inference","text":"plot(getindex.(θθ, 1))","category":"page"},{"location":"tutorials/biblock/inference/","page":"Inference","title":"Inference","text":"(Image: inference_chain)","category":"page"},{"location":"manual/sampling_unit/#The-smallest-sampling-unit:-SamplingUnit","page":"SamplingUnit","title":"The smallest sampling unit: SamplingUnit","text":"","category":"section"},{"location":"manual/sampling_unit/","page":"SamplingUnit","title":"SamplingUnit","text":"","category":"page"},{"location":"manual/sampling_unit/","page":"SamplingUnit","title":"SamplingUnit","text":"The struct","category":"page"},{"location":"manual/sampling_unit/","page":"SamplingUnit","title":"SamplingUnit","text":"DiffusionMCMCTools.SamplingUnit","category":"page"},{"location":"manual/sampling_unit/#DiffusionMCMCTools.SamplingUnit","page":"SamplingUnit","title":"DiffusionMCMCTools.SamplingUnit","text":"struct SamplingUnit{TGP,TGPb,TW,TWn,TX}\n    PP::Vector{TGP}\n    PPb::Vector{TGPb}\n    WW::Vector{TW}\n    Wnr::TWn\n    XX::Vector{TX}\nend\n\nSmallest composite unit with containers needed for sampling of conditioned diffusions via Guided Proposals.\n\nFields\n\n\n\nPP: a vector of GuidProp\nPPb: a vector of GuidProp that can be used in a blocking schemes as        GuidProps on terminal subintervals\nWW: a vector of containers for sampled Wiener process\nWnr: a flag for sampling Wiener processes\nXX: a vector of containers for a sampled process\nSamplingUnit(       auxlaws, recording, tts, args=tuple();       auxlawsblocking=auxlaws, artificialnoise=1e-11,       solverchoice_blocking=args   )\n\nBase constructor.\n\nArguments\n\n\n\naux_laws:\nrecording:\ntts:\nargs:\naux_laws_blocking:\nartificial_noise:\nsolver_choice_blocking:\n\n\n\n\n\n","category":"type"},{"location":"manual/sampling_unit/","page":"SamplingUnit","title":"SamplingUnit","text":"is the main building block of all remaining units implemented in this package. It has a couple of methods implemented for it:","category":"page"},{"location":"manual/sampling_unit/","page":"SamplingUnit","title":"SamplingUnit","text":"DiffusionMCMCTools.recompute_guiding_term!(u::DiffusionMCMCTools.SamplingUnit)\nDiffusionMCMCTools.loglikhd(u::DiffusionMCMCTools.SamplingUnit)\nDiffusionMCMCTools.draw_proposal_path!(u::DiffusionMCMCTools.SamplingUnit)","category":"page"},{"location":"manual/sampling_unit/#GuidedProposals.recompute_guiding_term!-Tuple{SamplingUnit}","page":"SamplingUnit","title":"GuidedProposals.recompute_guiding_term!","text":"GP.recompute_guiding_term!(u::SamplingUnit)\n\nRecompute the guiding term assuming u.PP is a vector with guided proposal laws\n\n\n\n\n\n","category":"method"},{"location":"manual/sampling_unit/#GuidedProposals.loglikhd-Tuple{SamplingUnit}","page":"SamplingUnit","title":"GuidedProposals.loglikhd","text":"GP.loglikhd(u::SamplingUnit)\n\nReturn log-likelihood evaluated at a sampled path\n\n\n\n\n\n","category":"method"},{"location":"manual/sampling_unit/#DiffusionMCMCTools.draw_proposal_path!-Tuple{SamplingUnit}","page":"SamplingUnit","title":"DiffusionMCMCTools.draw_proposal_path!","text":"draw_proposal_path!(u::SamplingUnit)\n\nSample a proposal path, compute log-likelihood along the way. Assumes u.XX[1].x[1] is a starting point. No preconditioned Crank-Nicolson scheme is used.\n\n\n\n\n\n","category":"method"},{"location":"manual/sampling_unit/","page":"SamplingUnit","title":"SamplingUnit","text":"However, because it does not contain proposal-accepted pair it is rarely used on its own for sampling. Instead, it most often appears as a member of other struct.","category":"page"},{"location":"how_to_guides/under_construction/#how_to_guides_start","page":"...","title":"Under construction...","text":"","category":"section"},{"location":"how_to_guides/under_construction/","page":"...","title":"...","text":"","category":"page"},{"location":"tutorials/biblock/smoothing_with_blocking/#Smoothing-with-blocking-with-BiBlocks","page":"Smoothing with blocking","title":"Smoothing with blocking with BiBlocks","text":"","category":"section"},{"location":"tutorials/biblock/smoothing_with_blocking/","page":"Smoothing with blocking","title":"Smoothing with blocking","text":"","category":"page"},{"location":"tutorials/biblock/smoothing_with_blocking/","page":"Smoothing with blocking","title":"Smoothing with blocking","text":"note: important\nMake sure that you read the preamble before you start reading this tutorial.","category":"page"},{"location":"tutorials/biblock/smoothing_with_blocking/","page":"Smoothing with blocking","title":"Smoothing with blocking","text":"A first level of complication to regular smoothing algorithm is an addition of a blocking scheme. Below we will define blocking \"by hand\" by operating directly on BiBlocks.","category":"page"},{"location":"tutorials/biblock/smoothing_with_blocking/#The-algorithm","page":"Smoothing with blocking","title":"The algorithm","text":"","category":"section"},{"location":"tutorials/biblock/smoothing_with_blocking/","page":"Smoothing with blocking","title":"Smoothing with blocking","text":"","category":"page"},{"location":"tutorials/biblock/smoothing_with_blocking/","page":"Smoothing with blocking","title":"Smoothing with blocking","text":"function simple_smoothing_with_blocking(\n        AuxLaw, recording, dt, AuxLawBlocking, block_layout;\n        ρ=0.5, num_steps=10^4\n    )\n    tts = OBS.setup_time_grids(recording, dt, standard_guid_prop_time_transf)\n    # this object is not changing, it still has all relevant containers\n    sp = SamplingPair(AuxLaw, recording, tts)\n    # and this has pointers to containers and facilitates actual sampling,\n    # it's a bit more complicated than before and contains multiple sets of blocks\n    blocks = [\n        [\n            BiBlock(sp, br, ρ, i==length(block_ranges), num_steps)\n            for (i,br) in enumerate(block_ranges)\n        ] for block_ranges in block_layout\n    ]\n\n    # we will again aggregate sampled paths here\n    paths = []\n\n    # MCMC\n    for i in 1:num_steps\n        # iterate through all sets of blocks\n        for B in blocks\n            # freeze terminal points of blocks to be artificial observations\n            GP.set_obs!.(B)\n            # recompute the guiding term only on the \"accepted\" laws `bb.b.PP`\n            (bb->recompute_guiding_term!(bb.b)).(B)\n            # recompute the Wiener path\n            find_W_for_X!.(B)\n            # re-evaluate the log-likelihood\n            loglikhd!.(B)\n            # impute a path\n            draw_proposal_path!.(B)\n            # Metropolis–Hastings accept/reject step\n            accept_reject_proposal_path!.(B, i)\n\n            # progress message\n            if i % 100 == 0\n                println(\n                    \"$i. ll=$(ll_of_accepted.(B, i)), acceptance rate: \",\n                    \"$( map(bb->accpt_rate(bb, (i-99):i), B) )\"\n                )\n            end\n        end\n\n        # save intermediate path for plotting\n        i % 400 == 0 && append!(paths, [deepcopy(sp.u.XX)])\n    end\n    paths\nend","category":"page"},{"location":"tutorials/biblock/smoothing_with_blocking/","page":"Smoothing with blocking","title":"Smoothing with blocking","text":"Let's run the algorithm on two sets of blocks based on 3 artificial points.","category":"page"},{"location":"tutorials/biblock/smoothing_with_blocking/","page":"Smoothing with blocking","title":"Smoothing with blocking","text":"paths = simple_smoothing_with_blocking(\n    FitzHughNagumoAux, recording, 0.001, FitzHughNagumoAux,\n    [[1:25,26:75,76:100],[1:50, 51:100]];\n    ρ=0.96, num_steps=10^4\n)","category":"page"},{"location":"tutorials/biblock/smoothing_with_blocking/#Results","page":"Smoothing with blocking","title":"Results","text":"","category":"section"},{"location":"tutorials/biblock/smoothing_with_blocking/","page":"Smoothing with blocking","title":"Smoothing with blocking","text":"","category":"page"},{"location":"tutorials/biblock/smoothing_with_blocking/","page":"Smoothing with blocking","title":"Smoothing with blocking","text":"plot_imputed_trajectories(paths)","category":"page"},{"location":"tutorials/biblock/smoothing_with_blocking/","page":"Smoothing with blocking","title":"Smoothing with blocking","text":"(Image: smoothing_with_blocking)","category":"page"},{"location":"#DiffusionMCMCTools","page":"Home","title":"DiffusionMCMCTools","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is a utility package belonging to a suite of packages in JuliaDiffusionBayes. It provides structs and methods that make it easier to write algorithms doing inference and/or smoothing for diffusion processes.","category":"page"},{"location":"","page":"Home","title":"Home","text":"There are three categories of objects (that have their own, associated methods) provided in this package:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Structs that gather all containers that are needed for sampling/inference of diffusion processes\nStructs that provide windowed views into the structs above (and hence, facilitate use of the so-called blocking technique)\nStructs that provide a translation between parameter names:\nparameter names known to MCMC sampler\nparameter names known to each individual diffusion law or observation","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Depending on your intended use of this package you might choose to start at different places:","category":"page"},{"location":"","page":"Home","title":"Home","text":"For a quick overview of DiffusionMCMCTools.jl's main functionality see Get started\nFor a systematic introduction to all functionality introduced in this package see the Manual\nFor a didactic introduction to problems that can be solved using DiffusionMCMCTools.jl see the Tutorials\nIf you have a problem that you think can be addressed with this package, then check out the How-to guides to see if the answer is already there.","category":"page"}]
}
