var documenterSearchIndex = {"docs":
[{"location":"module_index/#","page":"Index","title":"Index","text":"CurrentModule = DiffusionMCMCTools","category":"page"},{"location":"module_index/#DiffusionMCMCTools-1","page":"Index","title":"DiffusionMCMCTools","text":"","category":"section"},{"location":"module_index/#","page":"Index","title":"Index","text":"","category":"page"},{"location":"module_index/#","page":"Index","title":"Index","text":"Modules = [DiffusionMCMCTools]","category":"page"},{"location":"module_index/#DiffusionMCMCTools.init_paths!-NTuple{5,Any}","page":"Index","title":"DiffusionMCMCTools.init_paths!","text":"init_paths!(P, WW, Wnr, XX, x0_prior)\n\nSample paths of guided proposals without using the preconditioned Crank–Nicolson scheme.\n\n\n\n\n\n","category":"method"},{"location":"manual/block/#Block-1","page":"Block","title":"Block","text":"","category":"section"},{"location":"manual/block/#","page":"Block","title":"Block","text":"","category":"page"},{"location":"manual/block/#","page":"Block","title":"Block","text":"A smallest unit that is needed for blocking.","category":"page"},{"location":"manual/block/#","page":"Block","title":"Block","text":"DiffusionMCMCTools.Block","category":"page"},{"location":"manual/block/#DiffusionMCMCTools.Block","page":"Block","title":"DiffusionMCMCTools.Block","text":"mutable struct Block{L,TGP,TGPl,TW,TWn,TX}\n    PP::TVIEW{TGP}\n    P_last::TVIEW{TGPl} # view into a single element\n    WW::TVIEW{TW}\n    Wnr::TWn\n    XX::TVIEW{TX}\n    ll::Float64\n    ll_history::Vector{Float64}\nend\n\nThe smallest \"containerless\" unit that provides a view into SamplingUnit restricted to a range i:j of a block. L is an important flag that indicates whether it is a terminal block or not.\n\nFields\n\n\n\nPP: a vector of views into relevant GuidProp\nP_last: a view into a single (or none) GuidProp corresponding to the           terminal sub-interval.\nWW: a vector of views into containers for sampled Wiener process\nWnr: a flag for sampling Wiener processes\nXX: a vector of views into containers for a sampled process\nll: a placeholder for computed log-likelihood\nll_history: a history of computed log-likelihoods (useful for MCMC)\n\nfunction Block(\n    u::SamplingUnit,\n    range::UnitRange{Int64},\n    last_block=false,\n    ll_hist_len=0\n)\n\nBase constructor.\n\n\n\n\n\n","category":"type"},{"location":"manual/block/#","page":"Block","title":"Block","text":"It is rarely used on its own. Instead, it is used mainly as a building block of other, composite units. Nevertheless, there are a couple of useful functions implemented for it:","category":"page"},{"location":"manual/block/#","page":"Block","title":"Block","text":"DiffusionMCMCTools.set_ll!(b::DiffusionMCMCTools.Block, i::Int, v)\nDiffusionMCMCTools.save_ll!(b::DiffusionMCMCTools.Block, i::Int)\nDiffusionMCMCTools.recompute_guiding_term!(b::DiffusionMCMCTools.Block)\nDiffusionMCMCTools.find_W_for_X!(b::DiffusionMCMCTools.Block)\nDiffusionMCMCTools.loglikhd(b::DiffusionMCMCTools.Block)\nDiffusionMCMCTools.recompute_path!(b::DiffusionMCMCTools.Block, WW=b.WW; skip=0)","category":"page"},{"location":"manual/block/#DiffusionMCMCTools.set_ll!-Tuple{DiffusionMCMCTools.Block,Int64,Any}","page":"Block","title":"DiffusionMCMCTools.set_ll!","text":"set_ll!(b::Block, i::Int, v)\n\nSet the internal log-likelihood history field b.ll_history[i] with a value v\n\n\n\n\n\n","category":"method"},{"location":"manual/block/#DiffusionMCMCTools.save_ll!-Tuple{DiffusionMCMCTools.Block,Int64}","page":"Block","title":"DiffusionMCMCTools.save_ll!","text":"save_ll!(b::Block, i::Int)\n\nCommit the current log-likelihood field ll to history b.ll_history at index i.\n\n\n\n\n\n","category":"method"},{"location":"manual/block/#GuidedProposals.recompute_guiding_term!-Tuple{DiffusionMCMCTools.Block}","page":"Block","title":"GuidedProposals.recompute_guiding_term!","text":"GP.recompute_guiding_term!(b::Block)\n\nRecompute the guiding term.\n\n\n\n\n\n","category":"method"},{"location":"manual/block/#DiffusionMCMCTools.find_W_for_X!-Tuple{DiffusionMCMCTools.Block}","page":"Block","title":"DiffusionMCMCTools.find_W_for_X!","text":"find_W_for_X!(b::Block)\n\nCompute the Wiener process b.WW that is needed for obtaining path b.XX under the law stored in b.\n\n\n\n\n\n","category":"method"},{"location":"manual/block/#GuidedProposals.loglikhd-Tuple{DiffusionMCMCTools.Block}","page":"Block","title":"GuidedProposals.loglikhd","text":"GP.loglikhd(b::Block)\n\nCompute the log-likelihood evaluated at a sampled path.\n\n\n\n\n\n","category":"method"},{"location":"manual/block/#DiffusionMCMCTools.recompute_path!","page":"Block","title":"DiffusionMCMCTools.recompute_path!","text":"recompute_path!(b::Block, WW=b.WW; skip=0)\n\nRecompute the path b.XX for a given wiener process WW.\n\n\n\n\n\n","category":"function"},{"location":"manual/biblock/#BiBlock-1","page":"BiBlock","title":"BiBlock","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"","category":"page"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"A composite unit that represents a block. It can be used for sampling on a block in a setting of smoothing or inference.","category":"page"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"DiffusionMCMCTools.BiBlock","category":"page"},{"location":"manual/biblock/#DiffusionMCMCTools.BiBlock","page":"BiBlock","title":"DiffusionMCMCTools.BiBlock","text":"mutable struct BiBlock{L,TGP,TGPl,TW,TWn,TX}\n    b::Block{L,TGP,TGPl,TW,TWn,TX}\n    b°::Block{L,TGP,TGPl,TW,TWn,TX}\n    ρ::Float64\n    accpt_history::Vector{Bool}\nend\n\nComposite unit that allows for sampling of a single block. It provides two Blocks: one proposal b°, one accepted b that can be used for smoothing or inference problems. ρ is a memory parameter of the preconditioned Crank-Nicolson scheme and accpt_history stores the history of accept/reject decisions (useful for MCMC).\n\nfunction BiBlock(\n    sp::SamplingPair,\n    range::UnitRange{Int64},\n    ρ=0.0,\n    last_block=false,\n    ll_hist_len=0\n)\n\nBase constructor.\n\n\n\n\n\n","category":"type"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"There are many functions implemented for it.","category":"page"},{"location":"manual/biblock/#Imputation-of-paths-1","page":"BiBlock","title":"Imputation of paths","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"","category":"page"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"DiffusionMCMCTools.draw_proposal_path!(bb::DiffusionMCMCTools.BiBlock)","category":"page"},{"location":"manual/biblock/#DiffusionMCMCTools.draw_proposal_path!-Tuple{DiffusionMCMCTools.BiBlock}","page":"BiBlock","title":"DiffusionMCMCTools.draw_proposal_path!","text":"draw_proposal_path!(bb::BiBlock)\n\nSample a proposal path, compute log-likelihood along the way. Assumes bb.b.XX[1].x[1] is a starting point. Uses preconditioned Crank-Nicolson scheme with memory parameter set as bb.ρ.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#Accept/reject-decision-in-an-MCMC-setting-1","page":"BiBlock","title":"Accept/reject decision in an MCMC setting","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"","category":"page"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"DiffusionMCMCTools.accept_reject_proposal_path!(bb::DiffusionMCMCTools.BiBlock, mcmciter)","category":"page"},{"location":"manual/biblock/#DiffusionMCMCTools.accept_reject_proposal_path!-Tuple{DiffusionMCMCTools.BiBlock,Any}","page":"BiBlock","title":"DiffusionMCMCTools.accept_reject_proposal_path!","text":"accept_reject_proposal_path!(bb::BiBlock, mcmciter)\n\nAccept/reject decision of the Metropolis-Hastings algorithm for the step of path imputation.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#Adjustments-made-after-the-accept-reject-decision-(regardless-of-what-it-was)-1","page":"BiBlock","title":"Adjustments made after the accept-reject decision (regardless of what it was)","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"","category":"page"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"DiffusionMCMCTools.set_accepted!(bb::DiffusionMCMCTools.BiBlock, i::Int, v)","category":"page"},{"location":"manual/biblock/#DiffusionMCMCTools.set_accepted!-Tuple{DiffusionMCMCTools.BiBlock,Int64,Any}","page":"BiBlock","title":"DiffusionMCMCTools.set_accepted!","text":"set_accepted!(bb::BiBlock, i::Int, v)\n\nCommit the accept/reject decision v to acceptance history of BiBlock b at the position i.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#Adjustments-to-the-containers-in-case-of-**acceptance**-of-proposals:-1","page":"BiBlock","title":"Adjustments to the containers in case of acceptance of proposals:","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"","category":"page"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"DiffusionMCMCTools.swap_paths!(bb::DiffusionMCMCTools.BiBlock)\nDiffusionMCMCTools.swap_XX!(bb::DiffusionMCMCTools.BiBlock)\nDiffusionMCMCTools.swap_WW!(bb::DiffusionMCMCTools.BiBlock)\nDiffusionMCMCTools.swap_PP!(bb::DiffusionMCMCTools.BiBlock)","category":"page"},{"location":"manual/biblock/#DiffusionMCMCTools.swap_paths!-Tuple{DiffusionMCMCTools.BiBlock}","page":"BiBlock","title":"DiffusionMCMCTools.swap_paths!","text":"swap_paths!(bb::BiBlock)\n\nSwap XX and WW containers between proposal-acceptance pair.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#DiffusionMCMCTools.swap_XX!-Tuple{DiffusionMCMCTools.BiBlock}","page":"BiBlock","title":"DiffusionMCMCTools.swap_XX!","text":"swap_XX!(bb::BiBlock)\n\nSwap XX containers between proposal-acceptance pair.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#DiffusionMCMCTools.swap_WW!-Tuple{DiffusionMCMCTools.BiBlock}","page":"BiBlock","title":"DiffusionMCMCTools.swap_WW!","text":"swap_WW!(bb::BiBlock)\n\nSwap WW containers between proposal-acceptance pair.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#DiffusionMCMCTools.swap_PP!-Tuple{DiffusionMCMCTools.BiBlock}","page":"BiBlock","title":"DiffusionMCMCTools.swap_PP!","text":"swap_PP!(bb::BiBlock)\n\nSwap PP containers (including PP_last) between proposal-acceptance pair.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#Setting-up-a-block-1","page":"BiBlock","title":"Setting up a block","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"","category":"page"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"DiffusionMCMCTools.set_obs!(bb::DiffusionMCMCTools.BiBlock)\nDiffusionMCMCTools.recompute_guiding_term!(bb::DiffusionMCMCTools.BiBlock)\nDiffusionMCMCTools.find_W_for_X!(bb::DiffusionMCMCTools.BiBlock)","category":"page"},{"location":"manual/biblock/#GuidedProposals.set_obs!-Tuple{DiffusionMCMCTools.BiBlock}","page":"BiBlock","title":"GuidedProposals.set_obs!","text":"GP.set_obs!(bb::BiBlock)\n\nFreeze an artificial observation at the terminal point of the block. For a terminal block nothing is done.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#GuidedProposals.recompute_guiding_term!-Tuple{DiffusionMCMCTools.BiBlock}","page":"BiBlock","title":"GuidedProposals.recompute_guiding_term!","text":"GP.recompute_guiding_term!(bb::BiBlock)\n\nRecompute the guiding terms of both the proposal and the accepted laws.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#DiffusionMCMCTools.find_W_for_X!-Tuple{DiffusionMCMCTools.BiBlock}","page":"BiBlock","title":"DiffusionMCMCTools.find_W_for_X!","text":"find_W_for_X!(bb::BiBlock)\n\nFind the Wiener process bb.b.WW that reconstructs path bb.b.XX under the accepted law bb.b.PP (possibly including bb.b.P_last).\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#Utility-1","page":"BiBlock","title":"Utility","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"","category":"page"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"DiffusionMCMCTools.ll_of_accepted(bb::DiffusionMCMCTools.BiBlock, i)","category":"page"},{"location":"manual/biblock/#DiffusionMCMCTools.ll_of_accepted-Tuple{DiffusionMCMCTools.BiBlock,Any}","page":"BiBlock","title":"DiffusionMCMCTools.ll_of_accepted","text":"ll_of_accepted(bb::BiBlock, i)\n\nReturn the log-likelihood of the path that was accepted at the ith iteration.\n\n\n\n\n\n","category":"method"},{"location":"manual/sampling_unit/#The-smallest-sampling-unit:-SamplingUnit-1","page":"SamplingUnit","title":"The smallest sampling unit: SamplingUnit","text":"","category":"section"},{"location":"manual/sampling_unit/#","page":"SamplingUnit","title":"SamplingUnit","text":"","category":"page"},{"location":"manual/sampling_unit/#","page":"SamplingUnit","title":"SamplingUnit","text":"The struct","category":"page"},{"location":"manual/sampling_unit/#","page":"SamplingUnit","title":"SamplingUnit","text":"DiffusionMCMCTools.SamplingUnit","category":"page"},{"location":"manual/sampling_unit/#DiffusionMCMCTools.SamplingUnit","page":"SamplingUnit","title":"DiffusionMCMCTools.SamplingUnit","text":"struct SamplingUnit{TGP,TGPb,TW,TWn,TX}\n    PP::Vector{TGP}\n    PPb::Vector{TGPb}\n    WW::Vector{TW}\n    Wnr::TWn\n    XX::Vector{TX}\nend\n\nSmallest composite unit with containers needed for sampling of conditioned diffusions via Guided Proposals.\n\nFields\n\n\n\nPP: a vector of GuidProp\nPPb: a vector of GuidProp that can be used in a blocking schemes as        GuidProps on terminal subintervals\nWW: a vector of containers for sampled Wiener process\nWnr: a flag for sampling Wiener processes\nXX: a vector of containers for a sampled process\nSamplingUnit(       auxlaws, recording, x0prior, tts, args;       auxlawsblocking=auxlaws, artificialnoise=1e-11,       solverchoiceblocking=args   )\n\nBase constructor.\n\nArguments\n\n\n\naux_laws:\nrecording:\nx0_prior:\ntts:\nargs:\naux_laws_blocking:\nartificial_noise:\nsolver_choice_blocking:\n\n\n\n\n\n","category":"type"},{"location":"manual/sampling_unit/#","page":"SamplingUnit","title":"SamplingUnit","text":"is the main building block of all remaining units implemented in this package. It has a couple of methods implemented for it:","category":"page"},{"location":"manual/sampling_unit/#","page":"SamplingUnit","title":"SamplingUnit","text":"DiffusionMCMCTools.recompute_guiding_term!(u::DiffusionMCMCTools.SamplingUnit)\nDiffusionMCMCTools.loglikhd(u::DiffusionMCMCTools.SamplingUnit)\nDiffusionMCMCTools.draw_proposal_path!(u::DiffusionMCMCTools.SamplingUnit)","category":"page"},{"location":"manual/sampling_unit/#GuidedProposals.recompute_guiding_term!-Tuple{DiffusionMCMCTools.SamplingUnit}","page":"SamplingUnit","title":"GuidedProposals.recompute_guiding_term!","text":"GP.recompute_guiding_term!(u::SamplingUnit)\n\nRecompute the guiding term assuming u.PP is a vector with guided proposal laws\n\n\n\n\n\n","category":"method"},{"location":"manual/sampling_unit/#GuidedProposals.loglikhd-Tuple{DiffusionMCMCTools.SamplingUnit}","page":"SamplingUnit","title":"GuidedProposals.loglikhd","text":"GP.loglikhd(u::SamplingUnit)\n\nReturn log-likelihood evaluated at a sampled path\n\n\n\n\n\n","category":"method"},{"location":"manual/sampling_unit/#DiffusionMCMCTools.draw_proposal_path!-Tuple{DiffusionMCMCTools.SamplingUnit}","page":"SamplingUnit","title":"DiffusionMCMCTools.draw_proposal_path!","text":"draw_proposal_path!(u::SamplingUnit)\n\nSample a proposal path, compute log-likelihood along the way. Assumes u.XX[1].x[1] is a starting point. No preconditioned Crank-Nicolson scheme is used.\n\n\n\n\n\n","category":"method"},{"location":"manual/sampling_unit/#","page":"SamplingUnit","title":"SamplingUnit","text":"However, because it does not contain proposal-accepted pair it is rarely used on its own for sampling. Instead, it most often appears as a member of other struct.","category":"page"},{"location":"manual/sampling_pair/#A-pairing-of-two-SamplingUnits-1","page":"SamplingPair","title":"A pairing of two SamplingUnits","text":"","category":"section"},{"location":"manual/sampling_pair/#","page":"SamplingPair","title":"SamplingPair","text":"","category":"page"},{"location":"manual/sampling_pair/#","page":"SamplingPair","title":"SamplingPair","text":"Defines all main containers for an entire single recording for a smoothing or inference problem.","category":"page"},{"location":"manual/sampling_pair/#","page":"SamplingPair","title":"SamplingPair","text":"DiffusionMCMCTools.SamplingPair","category":"page"},{"location":"manual/sampling_pair/#DiffusionMCMCTools.SamplingPair","page":"SamplingPair","title":"DiffusionMCMCTools.SamplingPair","text":"struct SamplingPair{TGP,TGPb,TW,TWn,TX}\n    u::SamplingUnit{TGP,TGPb,TW,TWn,TX}\n    u°::SamplingUnit{TGP,TGPb,TW,TWn,TX}\nend\n\nA pairing of two SamplingUnits and can be used for smoothing or inference problems.\n\nSamplingPair(\n    aux_laws, recording, x0_prior, tts, args;\n    aux_laws_blocking=aux_laws, artificial_noise=1e-11,\n    solver_choice_blocking=args\n)\n\nBase constructor.\n\nArguments\n\n\n\naux_laws:\nrecording:\nx0_prior:\ntts:\nargs:\naux_laws_blocking:\nartificial_noise:\nsolver_choice_blocking:\n\n\n\n\n\n","category":"type"},{"location":"manual/sampling_pair/#","page":"SamplingPair","title":"SamplingPair","text":"note: Note\nIn practice all sampling is done with a BiBlock that looks at sections of a SamplingPair and never through SamplingPair directly. Even when no blocking is needed, it should still be done by defining a BiBlock that simply looks at the entire SamplingPair.","category":"page"},{"location":"#DiffusionMCMCTools-1","page":"Home","title":"DiffusionMCMCTools","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Utility package for performing MCMC sampling for diffusion processes.","category":"page"}]
}
