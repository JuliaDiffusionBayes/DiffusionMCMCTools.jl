var documenterSearchIndex = {"docs":
[{"location":"module_index/#","page":"Index","title":"Index","text":"CurrentModule = DiffusionMCMCTools","category":"page"},{"location":"module_index/#DiffusionMCMCTools-1","page":"Index","title":"DiffusionMCMCTools","text":"","category":"section"},{"location":"module_index/#","page":"Index","title":"Index","text":"","category":"page"},{"location":"module_index/#","page":"Index","title":"Index","text":"Modules = [DiffusionMCMCTools]","category":"page"},{"location":"module_index/#DiffusionMCMCTools.accept_reject_proposal_path!-Tuple{BlockEnsemble,Any}","page":"Index","title":"DiffusionMCMCTools.accept_reject_proposal_path!","text":"accept_reject_proposal_path!(be::BlockEnsemble, mcmciter)\n\nCall accept_reject_proposal_path! separately for each recording.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#DiffusionMCMCTools.accpt_rate-Tuple{BlockEnsemble,Any}","page":"Index","title":"DiffusionMCMCTools.accpt_rate","text":"accpt_rate(be::BlockEnsemble, range)\n\nCompute the acceptance rate over the range of MCMC accept/reject history for each block for each recording.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#DiffusionMCMCTools.draw_proposal_path!-Tuple{BlockEnsemble}","page":"Index","title":"DiffusionMCMCTools.draw_proposal_path!","text":"draw_proposal_path!(be::BlockEnsemble)\n\nCall draw_proposal_path! separately for each recording\n\n\n\n\n\n","category":"method"},{"location":"module_index/#DiffusionMCMCTools.fetch_ll-Tuple{BlockEnsemble}","page":"Index","title":"DiffusionMCMCTools.fetch_ll","text":"fetch_ll(be::BlockEnsemble)\n\nRetreive the log-likelihood for all accepted paths\n\nwarning: Warning\nThe function uses only internal fields ll for this computation, which means that for the call to this function to make sense the log-likelihood must have been previously computed and stored in the field ll. If it hasn't been done, then you must first call loglikhd!(be).\n\n\n\n\n\n","category":"method"},{"location":"module_index/#DiffusionMCMCTools.fetch_ll°-Tuple{BlockEnsemble}","page":"Index","title":"DiffusionMCMCTools.fetch_ll°","text":"fetch_ll°(be::BlockEnsemble)\n\nRetreive the log-likelihood for all proposed paths\n\nwarning: Warning\nThe function uses only internal fields ll for this computation, which means that for the call to this function to make sense the log-likelihood must have been previously computed and stored in the field ll. If it hasn't been done, then you must first call loglikhd°!(be).\n\n\n\n\n\n","category":"method"},{"location":"module_index/#DiffusionMCMCTools.find_W_for_X!-Tuple{BlockCollection}","page":"Index","title":"DiffusionMCMCTools.find_W_for_X!","text":"find_W_for_X!(bc::BlockCollection)\n\nFor each block find the Wiener process bb.b.WW that reconstructs the path bb.b.XX under the accepted law bb.b.PP (possibly including bb.b.P_last).\n\n\n\n\n\n","category":"method"},{"location":"module_index/#DiffusionMCMCTools.find_W_for_X!-Tuple{BlockEnsemble}","page":"Index","title":"DiffusionMCMCTools.find_W_for_X!","text":"find_W_for_X!(be::BlockEnsemble)\n\nCall find_W_for_X! separately for each recording.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#DiffusionMCMCTools.ll_of_accepted-Tuple{BlockEnsemble,Any}","page":"Index","title":"DiffusionMCMCTools.ll_of_accepted","text":"ll_of_accepted(be::BlockEnsemble, i)\n\nReturn an array of log-likelihoods (one for each block in each recording) of the paths that were accepted at the ith iteration.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#DiffusionMCMCTools.loglikhd!-Tuple{BlockEnsemble}","page":"Index","title":"DiffusionMCMCTools.loglikhd!","text":"loglikhd!(be::BlockEnsemble)\n\nCall loglikhd! separately for each recording.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#DiffusionMCMCTools.loglikhd°!-Tuple{BlockEnsemble}","page":"Index","title":"DiffusionMCMCTools.loglikhd°!","text":"loglikhd°!(be::BlockEnsemble)\n\nCall loglikhd°! separately for each recording.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#DiffusionMCMCTools.save_ll!-Tuple{BlockEnsemble,Int64}","page":"Index","title":"DiffusionMCMCTools.save_ll!","text":"save_ll!(be::BlockEnsemble, i::Int)\n\nCall save_ll! separately for each recording.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#DiffusionMCMCTools.set_proposal_law!","page":"Index","title":"DiffusionMCMCTools.set_proposal_law!","text":"set_proposal_law!(\n    be::BlockEnsemble,\n    θ°,\n    pnames,\n    critical_change=GP.is_critical_update(bc, pnames);\n    skip=0\n)\n\nCall set_proposal_law! separately for each recording.\n\n\n\n\n\n","category":"function"},{"location":"module_index/#DiffusionMCMCTools.set_proposal_law!","page":"Index","title":"DiffusionMCMCTools.set_proposal_law!","text":"set_proposal_law!(\n    bb::BiBlock,\n    θ°,\n    pnames,\n    critical_change=GP.is_critical_update(bb, pnames);\n    skip=0\n)\n\nSet the parameters in bb.b°.PP and bb.b°.P_last to θ° and make sure that all other parameters are shared with bb.b.PP and bb.b.P_last. Recompute the guiding term if needed, and then, compute the proposal trajectory bb.b°.XX for the proposal point θ°.\n\n\n\n\n\n","category":"function"},{"location":"module_index/#DiffusionMCMCTools.swap_PP!-Tuple{BlockEnsemble}","page":"Index","title":"DiffusionMCMCTools.swap_PP!","text":"swap_PP!(be::BlockEnsemble)\n\nCall swap_PP! separately for each recording.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#DiffusionMCMCTools.swap_WW!-Tuple{BlockEnsemble}","page":"Index","title":"DiffusionMCMCTools.swap_WW!","text":"swap_WW!(be::BlockEnsemble)\n\nCall swap_WW! separately for each recording.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#DiffusionMCMCTools.swap_XX!-Tuple{BlockEnsemble}","page":"Index","title":"DiffusionMCMCTools.swap_XX!","text":"swap_XX!(be::BlockEnsemble)\n\nCall swap_XX! separately for each recording.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#DiffusionMCMCTools.swap_ll!-Tuple{BlockEnsemble}","page":"Index","title":"DiffusionMCMCTools.swap_ll!","text":"swap_ll!(be::BlockEnsemble)\n\nCall swap_ll! separately for each recording.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#DiffusionMCMCTools.swap_paths!-Tuple{BlockEnsemble}","page":"Index","title":"DiffusionMCMCTools.swap_paths!","text":"swap_paths!(be::BlockEnsemble)\n\nCall swap_paths! separately for each recording.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#DiffusionDefinition.set_parameters!","page":"Index","title":"DiffusionDefinition.set_parameters!","text":"DD.set_parameters!(\n    bb::BiBlock,\n    θ°,\n    pnames,\n    critical_change=is_critical_update(bb, pnames)\n)\n\nSet the parameters in bb.b°.PP and bb.b°.P_last to θ° and make sure that all other parameters are shared with bb.b.PP and bb.b.P_last.\n\n\n\n\n\n","category":"function"},{"location":"module_index/#DiffusionMCMCTools._eql_PP!-NTuple{4,Any}","page":"Index","title":"DiffusionMCMCTools._eql_PP!","text":"_eql_PP!(PP, PP°, var_p_names, var_p_aux_names)\n\nGo through all GuidProp structs in  PP and PP° and make sure that the parameters listed in var_p_names and var_p_aux_names agree. Equalize them if they do not. var_p_names should list all parameter names from the target law and var_p_aux_names should list all parameters from the auxiliary law.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#DiffusionMCMCTools.find_var_aux_names_not_in_MCMC_update-Tuple{Any,Any}","page":"Index","title":"DiffusionMCMCTools.find_var_aux_names_not_in_MCMC_update","text":"find_var_aux_names_not_in_MCMC_update(composite_names_in_updt, PP)\n\nParse through all PP and for each element look through variable names of P_aux and remove all those names that already feature in composite_names_in_updt.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#DiffusionMCMCTools.find_var_names_not_in_MCMC_update-Tuple{Any,Any}","page":"Index","title":"DiffusionMCMCTools.find_var_names_not_in_MCMC_update","text":"find_var_names_not_in_MCMC_update(composite_names_in_updt, PP)\n\nParse through all variable names of P_target and remove all those names that already feature in composite_names_in_updt.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#DiffusionMCMCTools.find_θ_aux_names_for_MCMC_update-Tuple{Any,Any}","page":"Index","title":"DiffusionMCMCTools.find_θ_aux_names_for_MCMC_update","text":"find_θ_aux_names_for_MCMC_update(θ_names_for_MCMC_update, PP)\n\nParse through PP and for each GuidProp struct enter the auxiliary law P_aux and pick out names from θ_names_for_MCMC_update that are relevant to this P_aux law.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#DiffusionMCMCTools.find_θ_names_for_MCMC_update-Tuple{Any,Any}","page":"Index","title":"DiffusionMCMCTools.find_θ_names_for_MCMC_update","text":"find_θ_names_for_MCMC_update(θnames, pdep)\n\nParse through θnames i.e. a list of all parameter names that are relevant for a given MCMC update and pick out only those that are relevant for a given diffusion law. All information about the relevant parameters of the law should be stored inside pdep. Return a list of relevant parameter names in a format: idx-of-θ-to-relevant-value => name-of-param-inside-P_target-struct.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#DiffusionMCMCTools.find_θ_obs_idx_for_MCMC_update-Tuple{Any,Any}","page":"Index","title":"DiffusionMCMCTools.find_θ_obs_idx_for_MCMC_update","text":"find_θ_obs_idx_for_MCMC_update(θnames, odeps)\n\nParse through θnames i.e. a list of all parameter names that are relevant for a given MCMC update and for each observation pick out only those that are relevant for it. All information about the relevant parameters of the observations should be stored inside odeps. Return a list of relevant parameter names in a format: idx-of-θ-to-relevant-value => idx-of-obs-inside-obs.θ.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#DiffusionMCMCTools.init_paths!-NTuple{5,Any}","page":"Index","title":"DiffusionMCMCTools.init_paths!","text":"init_paths!(P, WW, Wnr, XX, x0_prior)\n\nSample paths of guided proposals without using the preconditioned Crank–Nicolson scheme.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.equalize_law_params!-Tuple{BiBlock,Any}","page":"Index","title":"GuidedProposals.equalize_law_params!","text":"GP.equalize_law_params!(bb::BiBlock, pnames)\n\nMake sure that in the corresponding pairs of GuidProp structs of both bb.b and bb.b°, the variable parameters of each law are the same. If not, then set the ones in bb.b° to be the same as the ones in bb.b.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.equalize_obs_params!-Tuple{BiBlock}","page":"Index","title":"GuidedProposals.equalize_obs_params!","text":"GP.equalize_obs_params!(bb::BiBlock)\n\nMake sure that in the corresponding pairs of GuidProp structs of both bb.b and bb.b°, the parameters θ of the obs fields are the same. If not, then set the ones in bb.b° to be the same as the ones in bb.b.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.is_critical_update-Tuple{BiBlock,Any}","page":"Index","title":"GuidedProposals.is_critical_update","text":"is_critical_update(bb::BiBlock, pnames)\n\nVerify whether the update characterized by a list of parameter names stored in pnames is critical in a sense of prompting for recomputation of the guiding term.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.is_critical_update-Tuple{BlockCollection,Any}","page":"Index","title":"GuidedProposals.is_critical_update","text":"is_critical_update(bb::BlockCollection, pnames)\n\nFor each block in the collection verify whether the update characterized by a list of parameter names stored in pnames is critical in a sense of prompting for recomputation of the guiding term.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.is_critical_update-Tuple{BlockEnsemble,Any}","page":"Index","title":"GuidedProposals.is_critical_update","text":"is_critical_update(be::BlockEnsemble, pnames)\n\nCall is_critical_update separately for each recording.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.recompute_guiding_term!-Tuple{BlockCollection}","page":"Index","title":"GuidedProposals.recompute_guiding_term!","text":"GP.recompute_guiding_term!(bc::BlockCollection, [::Val{:_only}])\n\nFor each block in the collection recompute the guiding terms of both the proposal and the accepted laws. If an additional flag Val(:P_only) is passed, then recomputes the guiding term on accepted law only. If Val(:P°_only), then recomputes for the proposal law only.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.recompute_guiding_term!-Tuple{BlockEnsemble}","page":"Index","title":"GuidedProposals.recompute_guiding_term!","text":"GP.recompute_guiding_term!(be::BlockEnsemble, [::Val{:_only}])\n\nCall recompute_guiding_term! separately for each recording.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#GuidedProposals.set_obs!-Tuple{BlockEnsemble}","page":"Index","title":"GuidedProposals.set_obs!","text":"GP.set_obs!(be::BlockEnsemble)\n\nCall save_ll! separately for each recording.\n\n\n\n\n\n","category":"method"},{"location":"manual/block/#Block-1","page":"Block","title":"Block","text":"","category":"section"},{"location":"manual/block/#","page":"Block","title":"Block","text":"","category":"page"},{"location":"manual/block/#","page":"Block","title":"Block","text":"A smallest unit that is needed for blocking.","category":"page"},{"location":"manual/block/#","page":"Block","title":"Block","text":"DiffusionMCMCTools.Block","category":"page"},{"location":"manual/block/#DiffusionMCMCTools.Block","page":"Block","title":"DiffusionMCMCTools.Block","text":"mutable struct Block{L,TGP,TGPl,TW,TWn,TX}\n    PP::TVIEW{TGP}\n    P_last::TVIEW{TGPl} # view into a single element\n    WW::TVIEW{TW}\n    Wnr::TWn\n    XX::TVIEW{TX}\n    ll::Float64\n    ll_history::Vector{Float64}\nend\n\nThe smallest \"containerless\" unit that provides a view into SamplingUnit restricted to a range i:j of a block. L is an important flag that indicates whether it is a terminal block or not.\n\nFields\n\n\n\nPP: a vector of views into relevant GuidProp\nP_last: a view into a single (or none) GuidProp corresponding to the           terminal sub-interval.\nWW: a vector of views into containers for sampled Wiener process\nWnr: a flag for sampling Wiener processes\nXX: a vector of views into containers for a sampled process\nll: a placeholder for computed log-likelihood\nll_history: a history of computed log-likelihoods (useful for MCMC)\n\nfunction Block(\n    u::SamplingUnit,\n    range::UnitRange{Int64},\n    last_block=false,\n    ll_hist_len=0\n)\n\nBase constructor.\n\n\n\n\n\n","category":"type"},{"location":"manual/block/#","page":"Block","title":"Block","text":"It is rarely used on its own. Instead, it is used mainly as a building block of other, composite units. Nevertheless, there are a couple of useful functions implemented for it:","category":"page"},{"location":"manual/block/#","page":"Block","title":"Block","text":"DiffusionMCMCTools.set_ll!(b::DiffusionMCMCTools.Block, i::Int, v)\nDiffusionMCMCTools.save_ll!(b::DiffusionMCMCTools.Block, i::Int)\nDiffusionMCMCTools.recompute_guiding_term!(b::DiffusionMCMCTools.Block)\nDiffusionMCMCTools.find_W_for_X!(b::DiffusionMCMCTools.Block)\nDiffusionMCMCTools.loglikhd(b::DiffusionMCMCTools.Block)\nDiffusionMCMCTools.loglikhd!(b::DiffusionMCMCTools.Block)\nDiffusionMCMCTools.recompute_path!(b::DiffusionMCMCTools.Block, WW=b.WW; skip=0)","category":"page"},{"location":"manual/block/#DiffusionMCMCTools.set_ll!-Tuple{Block,Int64,Any}","page":"Block","title":"DiffusionMCMCTools.set_ll!","text":"set_ll!(b::Block, i::Int, v)\n\nSet the internal log-likelihood history field b.ll_history[i] with a value v\n\n\n\n\n\n","category":"method"},{"location":"manual/block/#DiffusionMCMCTools.save_ll!-Tuple{Block,Int64}","page":"Block","title":"DiffusionMCMCTools.save_ll!","text":"save_ll!(b::Block, i::Int)\n\nCommit the current log-likelihood field ll to history b.ll_history at index i.\n\n\n\n\n\n","category":"method"},{"location":"manual/block/#GuidedProposals.recompute_guiding_term!-Tuple{Block}","page":"Block","title":"GuidedProposals.recompute_guiding_term!","text":"GP.recompute_guiding_term!(b::Block)\n\nRecompute the guiding term.\n\n\n\n\n\n","category":"method"},{"location":"manual/block/#DiffusionMCMCTools.find_W_for_X!-Tuple{Block}","page":"Block","title":"DiffusionMCMCTools.find_W_for_X!","text":"find_W_for_X!(b::Block)\n\nCompute the Wiener process b.WW that is needed for obtaining path b.XX under the law stored in b.\n\n\n\n\n\n","category":"method"},{"location":"manual/block/#GuidedProposals.loglikhd-Tuple{Block}","page":"Block","title":"GuidedProposals.loglikhd","text":"GP.loglikhd(b::Block)\n\nCompute the log-likelihood evaluated at a sampled path.\n\n\n\n\n\n","category":"method"},{"location":"manual/block/#DiffusionMCMCTools.loglikhd!-Tuple{Block}","page":"Block","title":"DiffusionMCMCTools.loglikhd!","text":"loglikhd!(b::Block)\n\nCompute the log-likelihood evaluated at a sampled path and store the result in an internal field ll.\n\n\n\n\n\n","category":"method"},{"location":"manual/block/#DiffusionMCMCTools.recompute_path!","page":"Block","title":"DiffusionMCMCTools.recompute_path!","text":"recompute_path!(b::Block, WW=b.WW; skip=0)\n\nRecompute the path b.XX for a given wiener process WW.\n\n\n\n\n\n","category":"function"},{"location":"manual/block_collection/#BlockCollection-1","page":"BlockCollection","title":"BlockCollection","text":"","category":"section"},{"location":"manual/block_collection/#","page":"BlockCollection","title":"BlockCollection","text":"","category":"page"},{"location":"manual/block_collection/#","page":"BlockCollection","title":"BlockCollection","text":"DiffusionMCMCTools.BlockCollection","category":"page"},{"location":"manual/block_collection/#DiffusionMCMCTools.BlockCollection","page":"BlockCollection","title":"DiffusionMCMCTools.BlockCollection","text":"struct BlockCollection{TGP,TGPl,TW,TWn,TX}\n    blocks::Vector{BiBlock{_L,TGP,TGPl,TW,TWn,TX} where _L}\nend\n\nGathers all blocks relevant for an entire single recording.\n\nBlockCollection(\n    sp::SamplingPair{TGP,TGPl,TW,TWn,TX},\n    ranges,\n    ρρ=0.0,\n    ll_hist_len=0\n) where {TGP,TGPl,TW,TWn,TX}\n\nBase constructor.\n\n\n\n\n\n","category":"type"},{"location":"manual/block_collection/#Imputation-1","page":"BlockCollection","title":"Imputation","text":"","category":"section"},{"location":"manual/block_collection/#","page":"BlockCollection","title":"BlockCollection","text":"DiffusionMCMCTools.draw_proposal_path!(bc::DiffusionMCMCTools.BlockCollection)","category":"page"},{"location":"manual/block_collection/#DiffusionMCMCTools.draw_proposal_path!-Tuple{BlockCollection}","page":"BlockCollection","title":"DiffusionMCMCTools.draw_proposal_path!","text":"draw_proposal_path!(bc::BlockCollection)\n\nSample proposal paths on each block, compute log-likelihoods along the way. Assumes bc.blocks[i].b.XX[1].x[1] are starting points for each block. Uses the preconditioned Crank-Nicolson scheme.\n\n\n\n\n\n","category":"method"},{"location":"manual/block_collection/#Accept/reject-decision-1","page":"BlockCollection","title":"Accept/reject decision","text":"","category":"section"},{"location":"manual/block_collection/#","page":"BlockCollection","title":"BlockCollection","text":"DiffusionMCMCTools.accept_reject_proposal_path!(bb::DiffusionMCMCTools.BlockCollection, mcmciter)","category":"page"},{"location":"manual/block_collection/#DiffusionMCMCTools.accept_reject_proposal_path!-Tuple{BlockCollection,Any}","page":"BlockCollection","title":"DiffusionMCMCTools.accept_reject_proposal_path!","text":"accept_reject_proposal_path!(bc::BlockCollection, mcmciter)\n\nAccept/reject decision of the Metropolis-Hastings algorithm for the step of path imputation, done separately for each block.\n\n\n\n\n\n","category":"method"},{"location":"manual/block_collection/#Swaps-1","page":"BlockCollection","title":"Swaps","text":"","category":"section"},{"location":"manual/block_collection/#","page":"BlockCollection","title":"BlockCollection","text":"DiffusionMCMCTools.swap_paths!(bc::DiffusionMCMCTools.BlockCollection)\nDiffusionMCMCTools.swap_XX!(bc::DiffusionMCMCTools.BlockCollection)\nDiffusionMCMCTools.swap_WW!(bc::DiffusionMCMCTools.BlockCollection)\nDiffusionMCMCTools.swap_PP!(bc::DiffusionMCMCTools.BlockCollection)\nDiffusionMCMCTools.swap_ll!(bc::DiffusionMCMCTools.BlockCollection)","category":"page"},{"location":"manual/block_collection/#DiffusionMCMCTools.swap_paths!-Tuple{BlockCollection}","page":"BlockCollection","title":"DiffusionMCMCTools.swap_paths!","text":"swap_paths!(bc::BlockCollection)\n\nFor each block in the collection swap XX and WW containers between proposal-acceptance pair.\n\n\n\n\n\n","category":"method"},{"location":"manual/block_collection/#DiffusionMCMCTools.swap_XX!-Tuple{BlockCollection}","page":"BlockCollection","title":"DiffusionMCMCTools.swap_XX!","text":"swap_XX!(bc::BlockCollection)\n\nFor each block in the collection swap XX containers between proposal-acceptance pair.\n\n\n\n\n\n","category":"method"},{"location":"manual/block_collection/#DiffusionMCMCTools.swap_WW!-Tuple{BlockCollection}","page":"BlockCollection","title":"DiffusionMCMCTools.swap_WW!","text":"swap_WW!(bc::BlockCollection)\n\nFor each block in the collection swap WW containers between proposal-acceptance pair.\n\n\n\n\n\n","category":"method"},{"location":"manual/block_collection/#DiffusionMCMCTools.swap_PP!-Tuple{BlockCollection}","page":"BlockCollection","title":"DiffusionMCMCTools.swap_PP!","text":"swap_PP!(bc::BlockCollection)\n\nFor each block in the collection swap PP containers between proposal-acceptance pair.\n\n\n\n\n\n","category":"method"},{"location":"manual/block_collection/#DiffusionMCMCTools.swap_ll!-Tuple{BlockCollection}","page":"BlockCollection","title":"DiffusionMCMCTools.swap_ll!","text":"swap_ll!(bc::BlockCollection)\n\nFor each block in the collection swap ll fields between proposal-acceptance pair.\n\n\n\n\n\n","category":"method"},{"location":"manual/block_collection/#Setting-up-a-block-1","page":"BlockCollection","title":"Setting up a block","text":"","category":"section"},{"location":"manual/block_collection/#","page":"BlockCollection","title":"BlockCollection","text":"DiffusionMCMCTools.set_obs!(bc::DiffusionMCMCTools.BlockCollection)","category":"page"},{"location":"manual/block_collection/#GuidedProposals.set_obs!-Tuple{BlockCollection}","page":"BlockCollection","title":"GuidedProposals.set_obs!","text":"GP.set_obs!(bc::BlockCollection)\n\nFreeze an artificial observation at the terminal point of each block. For a terminal block nothing is done.\n\n\n\n\n\n","category":"method"},{"location":"manual/block_collection/#utility-1","page":"BlockCollection","title":"utility","text":"","category":"section"},{"location":"manual/block_collection/#","page":"BlockCollection","title":"BlockCollection","text":"DiffusionMCMCTools.loglikhd!(bc::DiffusionMCMCTools.BlockCollection)\nDiffusionMCMCTools.loglikhd°!(bc::DiffusionMCMCTools.BlockCollection)\nDiffusionMCMCTools.fetch_ll(bc::DiffusionMCMCTools.BlockCollection)\nDiffusionMCMCTools.fetch_ll°(bc::DiffusionMCMCTools.BlockCollection)\nDiffusionMCMCTools.save_ll!(bc::DiffusionMCMCTools.BlockCollection, i::Int)\nDiffusionMCMCTools.ll_of_accepted(bb::DiffusionMCMCTools.BlockCollection, i)\nDiffusionMCMCTools.accpt_rate(bb::DiffusionMCMCTools.BlockCollection, range)","category":"page"},{"location":"manual/block_collection/#DiffusionMCMCTools.loglikhd!-Tuple{BlockCollection}","page":"BlockCollection","title":"DiffusionMCMCTools.loglikhd!","text":"loglikhd!(bc::BlockCollection)\n\nFor each BiBlock in a collection compute the log-likelihood for the accepted block, evaluated at a sampled path and store the result in internal fields ll.\n\n\n\n\n\n","category":"method"},{"location":"manual/block_collection/#DiffusionMCMCTools.loglikhd°!-Tuple{BlockCollection}","page":"BlockCollection","title":"DiffusionMCMCTools.loglikhd°!","text":"loglikhd°!(bc::BlockCollection)\n\nFor each BiBlock in a collection compute the log-likelihood for the proposal block, evaluated at a sampled path and store the result in internal fields ll.\n\n\n\n\n\n","category":"method"},{"location":"manual/block_collection/#DiffusionMCMCTools.fetch_ll-Tuple{BlockCollection}","page":"BlockCollection","title":"DiffusionMCMCTools.fetch_ll","text":"fetch_ll(bc::BlockCollection)\n\nRetreive the log-likelihood for the entire accepted path.\n\nwarning: Warning\nThe function uses only internal fields ll for this computation, which means that for the call to this function to make sense the log-likelihood must have been previously computed and stored in the field ll. If it hasn't been done, then you must first call loglikhd!(bc).\n\n\n\n\n\n","category":"method"},{"location":"manual/block_collection/#DiffusionMCMCTools.fetch_ll°-Tuple{BlockCollection}","page":"BlockCollection","title":"DiffusionMCMCTools.fetch_ll°","text":"fetch_ll°(bc::BlockCollection)\n\nRetreive the log-likelihood for the entire proposed path.\n\nwarning: Warning\nThe function uses only internal fields ll for this computation, which means that for the call to this function to make sense the log-likelihood must have been previously computed and stored in the field ll. If it hasn't been done, then you must first call loglikhd°!(bc).\n\n\n\n\n\n","category":"method"},{"location":"manual/block_collection/#DiffusionMCMCTools.save_ll!-Tuple{BlockCollection,Int64}","page":"BlockCollection","title":"DiffusionMCMCTools.save_ll!","text":"save_ll!(bc::BlockCollection, i::Int)\n\nFor each block in the collection commit the current proposal and accepted log-likelihood fields ll to history, at index i.\n\n\n\n\n\n","category":"method"},{"location":"manual/block_collection/#DiffusionMCMCTools.ll_of_accepted-Tuple{BlockCollection,Any}","page":"BlockCollection","title":"DiffusionMCMCTools.ll_of_accepted","text":"ll_of_accepted(bb::BlockCollection, i)\n\nReturn an array of log-likelihoods (one for each block) of the paths that were accepted at the ith iteration.\n\n\n\n\n\n","category":"method"},{"location":"manual/block_collection/#DiffusionMCMCTools.accpt_rate-Tuple{BlockCollection,Any}","page":"BlockCollection","title":"DiffusionMCMCTools.accpt_rate","text":"accpt_rate(bb::BlockCollection, range)\n\nCompute the acceptance rate over the range of MCMC accept/reject history for each block in the collection.\n\n\n\n\n\n","category":"method"},{"location":"manual/block_collection/#Setting-parameters-1","page":"BlockCollection","title":"Setting parameters","text":"","category":"section"},{"location":"manual/block_collection/#","page":"BlockCollection","title":"BlockCollection","text":"DiffusionMCMCTools.set_proposal_law!(\n    bc::DiffusionMCMCTools.BlockCollection,\n    θ°,\n    pnames,\n    critical_change=GP.is_critical_update(bc, pnames);\n    skip=0\n)","category":"page"},{"location":"manual/block_collection/#DiffusionMCMCTools.set_proposal_law!","page":"BlockCollection","title":"DiffusionMCMCTools.set_proposal_law!","text":"set_proposal_law!(\n    bc::BlockCollection,\n    θ°,\n    pnames,\n    critical_change=GP.is_critical_update(bc, pnames);\n    skip=0\n)\n\nFor each block in the collection set the parameters in bb.b°.PP and bb.b°.P_last to θ° and make sure that all other parameters are shared with bb.b.PP and bb.b.P_last. Recompute the guiding term if needed, and then, compute the proposal trajectory bb.b°.XX for the proposal point θ°.\n\n\n\n\n\n","category":"function"},{"location":"manual/block_collection/#Example-1","page":"BlockCollection","title":"Example","text":"","category":"section"},{"location":"manual/block_collection/#The-algorithm-1","page":"BlockCollection","title":"The algorithm","text":"","category":"section"},{"location":"manual/block_collection/#","page":"BlockCollection","title":"BlockCollection","text":"all_obs = AllObservations()\nadd_recording!(all_obs, build_recording(P, data, 0.0, KnownStartingPt(y1)))\nDD.var_parameter_names(::FitzHughNagumo) = (:γ,)\nall_obs, _ = initialize(all_obs)\n\ncustomkernel(θ, scale=0.1) = θ .+ 2.0*scale*(rand()-0.5)\n\n\nfunction accept_reject_proposal_param!(bc, mcmciter, θ, θ°)\n    accepted = rand(Exponential(1.0)) > -(fetch_ll°(bc)-fetch_ll(bc))\n    accepted && swap_XX!(bc)\n    accepted && swap_PP!(bc)\n    save_ll!(bc, mcmciter)\n    accepted && swap_ll!(bc)\n    accepted, copy(accepted ? θ° : θ)\nend\n\nfunction simple_inference(AuxLaw, all_obs, dt, _θ; ϵ=0.3, ρ=0.5, num_steps=10^4)\n    # making sure that things are in order...\n    _pname = collect(keys(_θ))\n    # for simplicity restrict to inference for a single param\n    @assert length(_pname) == 1\n    pname = first(_pname)\n    θ = collect(values(_θ))\n\n    # setting the initial guess θ inside the recording\n    OBS.set_parameters!(all_obs, _θ)\n    @assert num_recordings(all_obs) == 1\n    recording = first(all_obs.recordings)\n\n    # setting up containers\n    num_obs = length(recording.obs)\n    tts = OBS.setup_time_grids(recording, dt, standard_guid_prop_time_transf)\n    sp = SamplingPair(AuxLaw, recording, tts)\n    bc = BlockCollection(sp, [1:num_obs], ρ, num_steps)\n    name_struct = ParamNamesRecording(\n        bc, _pname, first(all_obs.param_depend_rev),\n        first(all_obs.obs_depend_rev)\n    )\n\n    loglikhd!(bc)\n    paths = []\n\n    θθ = [θ]\n    a_h = Bool[]\n    crit_change = [true]\n\n    for i in 1:num_steps\n        draw_proposal_path!(bc)\n        accept_reject_proposal_path!(bc, i)\n\n        θ° = customkernel(θ, ϵ)\n        set_proposal_law!(bc, θ°, name_struct, crit_change)\n\n        accpt, θ = accept_reject_proposal_param!(bc, i, θ, θ°)\n        push!(θθ, θ)\n        push!(a_h, accpt)\n\n        # progress message\n        if i % 100 == 0\n            println(\n                \"$i. ll=$(ll_of_accepted(bc, i)), \",\n                \"imp a-r: \",\n                \" $(accpt_rate(bc, (i-99):i)), \",\n                \"updt a-r: \",\n                \"$(sum(a_h[(i-99):i])/100).\"\n            )\n        end\n\n        # save intermediate path for plotting\n        i % 400 == 0 && append!(paths, [deepcopy(sp.u.XX)])\n    end\n    paths, θθ\nend","category":"page"},{"location":"manual/block_collection/#Result-1","page":"BlockCollection","title":"Result","text":"","category":"section"},{"location":"manual/block_collection/#","page":"BlockCollection","title":"BlockCollection","text":"using OrderedCollections\n\nθ = OrderedDict(:REC1_γ=>1.5)\n\nDD.var_parameter_names(::FitzHughNagumo) = (:γ,)\nDD.var_parameter_names(::FitzHughNagumoAux) = (:γ,)\n\n@load_diffusion FitzHughNagumoAux\npaths, θθ = simple_inference(\n    FitzHughNagumoAux, all_obs, 0.001, θ; ϵ=0.3, ρ=0.96, num_steps=10^4\n)","category":"page"},{"location":"manual/block_collection/#Example-of-inference-with-blocking-1","page":"BlockCollection","title":"Example of inference with blocking","text":"","category":"section"},{"location":"manual/block_collection/#","page":"BlockCollection","title":"BlockCollection","text":"function accept_reject_proposal_param!(bc::BlockCollection, mcmciter, θ, θ°)\n    accepted = rand(Exponential(1.0)) > -(fetch_ll°(bc) - fetch_ll(bc))\n    accepted && swap_XX!(bc)\n    accepted && swap_PP!(bc)\n    save_ll!(bc, mcmciter)\n    accepted && swap_ll!(bc)\n    accepted, copy(accepted ? θ° : θ)\nend\n\n\nfunction simple_inference_with_blocking(\n        AuxLaw, all_obs, dt, AuxLawBlocking, block_layout, _θ;\n        ϵ=0.3, ρ=0.5, num_steps=10^4\n    )\n    # making sure that things are in order...\n    _pname = collect(keys(_θ))\n    # for simplicity restrict to inference for a single param\n    @assert length(_pname) == 1\n    pname = first(_pname)\n    θ = collect(values(_θ))\n\n    # setting the initial guess θ inside the recording\n    OBS.set_parameters!(all_obs, _θ)\n    @assert num_recordings(all_obs) == 1\n    recording = first(all_obs.recordings)\n\n    # setting up containers\n    tts = OBS.setup_time_grids(recording, dt, standard_guid_prop_time_transf)\n    sp = SamplingPair(AuxLaw, recording, tts)\n    blocks = [\n        BlockCollection(sp, block_ranges, ρ, num_steps)\n        for block_ranges in block_layout\n    ]\n    name_struct = [\n        ParamNamesRecording(\n            bc, _pname, first(all_obs.param_depend_rev),\n            first(all_obs.obs_depend_rev)\n        ) for bc in blocks\n    ]\n\n    paths = []\n\n    θθ = [θ]\n    a_h = Bool[]\n    crit_change = [fill(true, length(bc.blocks)) for bc in blocks]\n\n    # MCMC\n    for i in 1:num_steps\n        for bc in blocks\n            GP.set_obs!(bc)\n            recompute_guiding_term!(bc, Val(:P_only))\n            find_W_for_X!(bc)\n            loglikhd!(bc)\n            draw_proposal_path!(bc)\n            accept_reject_proposal_path!(bc, i)\n\n            # progress message\n            if i % 100 == 0\n                println(\n                    \"$i. ll=$(ll_of_accepted(bc, i)), acceptance rate: \",\n                    \"$( accpt_rate(bc, (i-99):i) )\"\n                )\n            end\n        end\n\n        θ° = customkernel(θ, ϵ)\n\n        bc = blocks[end]\n        set_proposal_law!(bc, θ°, name_struct[end], crit_change[end])\n        recompute_guiding_term!(bc, Val(:P°_only))\n\n        accpt, θ = accept_reject_proposal_param!(bc, i, θ, θ°)\n        push!(θθ, θ)\n        push!(a_h, accpt)\n\n        if i % 100 == 0\n            println(\n                \"$i. updt a-r: \",\n                \"$(sum(a_h[(i-99):i])/100).\"\n            )\n        end\n\n        # save intermediate path for plotting\n        i % 400 == 0 && append!(paths, [deepcopy(sp.u.XX)])\n    end\n    paths, θθ\nend","category":"page"},{"location":"manual/param_names_collections/#Containers-for-parameter-names-1","page":"Containers for parameter names","title":"Containers for parameter names","text":"","category":"section"},{"location":"manual/param_names_collections/#","page":"Containers for parameter names","title":"Containers for parameter names","text":"","category":"page"},{"location":"manual/param_names_collections/#","page":"Containers for parameter names","title":"Containers for parameter names","text":"DiffusionMCMCTools.ParamNamesUnit\nDiffusionMCMCTools.ParamNamesBlock\nDiffusionMCMCTools.ParamNamesRecording\nDiffusionMCMCTools.ParamNamesAllObs","category":"page"},{"location":"manual/param_names_collections/#DiffusionMCMCTools.ParamNamesUnit","page":"Containers for parameter names","title":"DiffusionMCMCTools.ParamNamesUnit","text":"struct ParamNamesUnit{N1,N2}\n    var::NTuple{N1,Symbol}\n    var_aux::Vector{Tuple{Vararg{Symbol,_N} where _N}}\n    updt::NTuple{N2,Pair{Int64,Symbol}}\n    updt_aux::Vector{Tuple{Vararg{Pair{Int64,Symbol},_N} where _N}}\n    updt_obs::Vector{Tuple{Vararg{Pair{Int64,Int64},_N} where _N}}\nend\n\nSmallest unit storing information about the names of the parameters that are supposed to be updated at a given step of the MCMC algorithm. It is pertinent to a single block of a single recording only, and in particular, only to a single collection of laws, out of:\n\nPP, i.e. those relevant to a given block\nP_last, i.e. the artificial law of the block associated with the last obs\nP_excl, i.e. the last, missed out PP, missed out due to use of P_last\nPPb, i.e. the collection of all remaining artificial laws that are not        P_last\n\nIt stores lists of parameters that are supposed to be updated at various stages of the call to a function set_proposal_law!, which sets the proposal parameter θ° inside the proposal laws.\n\nFields\n\nvar: names of P_target that are checked and—if need be—equalized between        proposal and accepted laws\nvar_aux: names of P_aux that are checked and—if need be—equalized between            proposal and accepted laws\nupdt: list of params of P_target that are being updated at a given MCMC         step; listed as pairs: idx-of-θ-to-relevant-value =>         name-of-param-inside-P_target-struct\nupdt_aux: as above, but for P_aux\nupdt_obs: list of params of obs (i.e. terminal observation for each guid             prop) that are being updated at a given MCMC step; listed as             pairs: idx-of-θ-to-relevant-value => idx-of-obs-inside-obs.θ\n\nParamNamesUnit(\n    PP::AbstractArray{<:GuidProp}, θnames::Vector{Symbol}, pdep, odeps\n)\n\nBase constructor.\n\nArguments\n\nPP:\nθnames:\npdep:\nodeps:\n\n\n\n\n\n","category":"type"},{"location":"manual/param_names_collections/#DiffusionMCMCTools.ParamNamesBlock","page":"Containers for parameter names","title":"DiffusionMCMCTools.ParamNamesBlock","text":"struct ParamNamesBlock{N1,N2}\n    PP::ParamNamesUnit{N1,N2}\n    P_last::ParamNamesUnit{N1,N2}\n    P_excl::ParamNamesUnit{N1,N2}\n    Pb_excl::ParamNamesUnit{N1,N2}\nend\n\nStores information relevant for a Block about the names of the parameters that are supposed to be updated at a given step of the MCMC algorithm. It stores lists of parameters that are supposed to be updated at various stages of the call to a function set_proposal_law!, which sets the proposal parameter θ° inside the proposal laws.\n\nFields\n\nPP, i.e. those relevant to a given block\nP_last, i.e. the artificial law of the block associated with the last obs\nP_excl, i.e. the last, missed out PP, missed out due to use of P_last\nPb_excl, i.e. the collection of all remaining artificial laws that are not            P_last\nParamNamesBlock(b::Block, θnames, pdep, odeps)\n\nBase constructor.\n\nArguments\n\nb::Block:\nθnames:\npdep:\nodeps:\n\n\n\n\n\n","category":"type"},{"location":"manual/param_names_collections/#DiffusionMCMCTools.ParamNamesRecording","page":"Containers for parameter names","title":"DiffusionMCMCTools.ParamNamesRecording","text":"struct ParamNamesRecording{N1,N2}\n    blocks::Vector{ParamNamesBlock{N1,N2}}\nend\n\nStores information relevant for an entire, single recording about the names of the parameters that are supposed to be updated at a given step of the MCMC algorithm. It stores lists of parameters that are supposed to be updated at various stages of the call to a function set_proposal_law!, which sets the proposal parameter θ° inside the proposal laws.\n\nParamNamesRecording(rb::BlockCollection, θnames, pdep, odeps)\n\nBase constructor.\n\n\n\n\n\n","category":"type"},{"location":"manual/param_names_collections/#DiffusionMCMCTools.ParamNamesAllObs","page":"Containers for parameter names","title":"DiffusionMCMCTools.ParamNamesAllObs","text":"struct ParamNamesAllObs{T}\n    recordings::Vector{T}\nend\n\nStores information relevant for multiple recordings about the names of the parameters that are supposed to be updated at a given step of the MCMC algorithm. It stores lists of parameters that are supposed to be updated at various stages of the call to a function set_proposal_law!, which sets the proposal parameter θ° inside the proposal laws.\n\nParamNamesAllObs(be::BlockEnsemble, θnames, all_obs)\n\nBase constructor.\n\n\n\n\n\n","category":"type"},{"location":"manual/param_names_collections/#Example-1","page":"Containers for parameter names","title":"Example","text":"","category":"section"},{"location":"manual/param_names_collections/#The-algorithm-1","page":"Containers for parameter names","title":"The algorithm","text":"","category":"section"},{"location":"manual/param_names_collections/#","page":"Containers for parameter names","title":"Containers for parameter names","text":"all_obs = AllObservations()\nadd_recording!(all_obs, build_recording(P, data, 0.0, KnownStartingPt(y1)))\nDD.var_parameter_names(::FitzHughNagumo) = (:γ,)\nall_obs, _ = initialize(all_obs)\n\ncustomkernel(θ, scale=0.1) = θ .+ 2.0*scale*(rand()-0.5)\n\n#=\n    NOTE we no longer need to hand-craft the `_build_struct` and\n    `simple_name_structure` functions. These will be substituted with a\n    struct `ParamNamesRecording`\n=#\n\nfunction accept_reject_proposal_param!(bb, mcmciter, θ, θ°)\n    accepted = rand(Exponential(1.0)) > -(bb.b°.ll - bb.b.ll)\n    accepted && swap_XX!(bb)\n    accepted && swap_PP!(bb)\n    save_ll!(bb.b, mcmciter)\n    save_ll!(bb.b°, mcmciter)\n    accepted && swap_ll!(bb)\n    accepted, copy(accepted ? θ° : θ)\nend\n\nfunction simple_inference(AuxLaw, all_obs, dt, _θ; ϵ=0.3, ρ=0.5, num_steps=10^4)\n    # making sure that things are in order...\n    _pname = collect(keys(_θ))\n    # for simplicity restrict to inference for a single param\n    @assert length(_pname) == 1\n    pname = first(_pname)\n    θ = collect(values(_θ))\n\n    # setting the initial guess θ inside the recording\n    OBS.set_parameters!(all_obs, _θ)\n    @assert num_recordings(all_obs) == 1\n    recording = first(all_obs.recordings)\n\n    # setting up containers\n    num_obs = length(recording.obs)\n    tts = OBS.setup_time_grids(recording, dt, standard_guid_prop_time_transf)\n    sp = SamplingPair(AuxLaw, recording, tts)\n    bb = BiBlock(sp, 1:num_obs, ρ, true, num_steps)\n    name_struct = ParamNamesBlock(\n        bb.b, _pname, first(all_obs.param_depend_rev),\n        first(all_obs.obs_depend_rev)\n    )\n\n    loglikhd!(bb)\n    paths = []\n\n    θθ = [θ]\n    a_h = Bool[]\n\n    for i in 1:num_steps\n        draw_proposal_path!(bb)\n        accept_reject_proposal_path!(bb, i)\n\n        θ° = customkernel(θ, ϵ)\n        set_proposal_law!(bb, θ°, name_struct, true)\n\n        accpt, θ = accept_reject_proposal_param!(bb, i, θ, θ°)\n        push!(θθ, θ)\n        push!(a_h, accpt)\n\n        # progress message\n        if i % 100 == 0\n            println(\n                \"$i. ll=$(ll_of_accepted(bb, i)), \",\n                \"imp a-r: \",\n                \" $(accpt_rate(bb, (i-99):i)), \",\n                \"updt a-r: \",\n                \"$(sum(a_h[(i-99):i])/100).\"\n            )\n        end\n\n        # save intermediate path for plotting\n        i % 400 == 0 && append!(paths, [deepcopy(sp.u.XX)])\n    end\n    paths, θθ\nend","category":"page"},{"location":"manual/param_names_collections/#Result-1","page":"Containers for parameter names","title":"Result","text":"","category":"section"},{"location":"manual/param_names_collections/#","page":"Containers for parameter names","title":"Containers for parameter names","text":"using OrderedCollections\n\nθ = OrderedDict(:REC1_γ=>1.5)\n\nDD.var_parameter_names(::FitzHughNagumo) = (:γ,)\nDD.var_parameter_names(::FitzHughNagumoAux) = (:γ,)\n\n@load_diffusion FitzHughNagumoAux\npaths, θθ = simple_inference(\n    FitzHughNagumoAux, all_obs, 0.001, θ; ϵ=0.3, ρ=0.96, num_steps=10^4\n)","category":"page"},{"location":"manual/biblock/#BiBlock-1","page":"BiBlock","title":"BiBlock","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"","category":"page"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"A composite unit that represents a block. It can be used for sampling on a block in a setting of smoothing or inference.","category":"page"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"DiffusionMCMCTools.BiBlock","category":"page"},{"location":"manual/biblock/#DiffusionMCMCTools.BiBlock","page":"BiBlock","title":"DiffusionMCMCTools.BiBlock","text":"mutable struct BiBlock{L,TGP,TGPl,TW,TWn,TX}\n    b::Block{L,TGP,TGPl,TW,TWn,TX}\n    b°::Block{L,TGP,TGPl,TW,TWn,TX}\n    ρ::Float64\n    accpt_history::Vector{Bool}\nend\n\nComposite unit that allows for sampling of a single block. It provides two Blocks: one proposal b°, one accepted b that can be used for smoothing or inference problems. ρ is a memory parameter of the preconditioned Crank-Nicolson scheme and accpt_history stores the history of accept/reject decisions (useful for MCMC).\n\nfunction BiBlock(\n    sp::SamplingPair,\n    range::UnitRange{Int64},\n    ρ=0.0,\n    last_block=false,\n    ll_hist_len=0\n)\n\nBase constructor.\n\n\n\n\n\n","category":"type"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"There are many functions implemented for it.","category":"page"},{"location":"manual/biblock/#Imputation-of-paths-1","page":"BiBlock","title":"Imputation of paths","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"","category":"page"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"DiffusionMCMCTools.draw_proposal_path!(bb::DiffusionMCMCTools.BiBlock)","category":"page"},{"location":"manual/biblock/#DiffusionMCMCTools.draw_proposal_path!-Tuple{BiBlock}","page":"BiBlock","title":"DiffusionMCMCTools.draw_proposal_path!","text":"draw_proposal_path!(bb::BiBlock)\n\nSample a proposal path, compute log-likelihood along the way. Assumes bb.b.XX[1].x[1] is a starting point. Uses preconditioned Crank-Nicolson scheme with memory parameter set as bb.ρ.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#Accept/reject-decision-in-an-MCMC-setting-1","page":"BiBlock","title":"Accept/reject decision in an MCMC setting","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"","category":"page"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"DiffusionMCMCTools.accept_reject_proposal_path!(bb::DiffusionMCMCTools.BiBlock, mcmciter)","category":"page"},{"location":"manual/biblock/#DiffusionMCMCTools.accept_reject_proposal_path!-Tuple{BiBlock,Any}","page":"BiBlock","title":"DiffusionMCMCTools.accept_reject_proposal_path!","text":"accept_reject_proposal_path!(bb::BiBlock, mcmciter)\n\nAccept/reject decision of the Metropolis-Hastings algorithm for the step of path imputation.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#Adjustments-made-after-the-accept-reject-decision-(regardless-of-what-it-was)-1","page":"BiBlock","title":"Adjustments made after the accept-reject decision (regardless of what it was)","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"","category":"page"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"DiffusionMCMCTools.set_accepted!(bb::DiffusionMCMCTools.BiBlock, i::Int, v)","category":"page"},{"location":"manual/biblock/#DiffusionMCMCTools.set_accepted!-Tuple{BiBlock,Int64,Any}","page":"BiBlock","title":"DiffusionMCMCTools.set_accepted!","text":"set_accepted!(bb::BiBlock, i::Int, v)\n\nCommit the accept/reject decision v to acceptance history of BiBlock b at the position i.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#Adjustments-to-the-containers-in-case-of-**acceptance**-of-proposals:-1","page":"BiBlock","title":"Adjustments to the containers in case of acceptance of proposals:","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"","category":"page"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"DiffusionMCMCTools.swap_paths!(bb::DiffusionMCMCTools.BiBlock)\nDiffusionMCMCTools.swap_XX!(bb::DiffusionMCMCTools.BiBlock)\nDiffusionMCMCTools.swap_WW!(bb::DiffusionMCMCTools.BiBlock)\nDiffusionMCMCTools.swap_PP!(bb::DiffusionMCMCTools.BiBlock)\nDiffusionMCMCTools.swap_ll!(bb::DiffusionMCMCTools.BiBlock)","category":"page"},{"location":"manual/biblock/#DiffusionMCMCTools.swap_paths!-Tuple{BiBlock}","page":"BiBlock","title":"DiffusionMCMCTools.swap_paths!","text":"swap_paths!(bb::BiBlock)\n\nSwap XX and WW containers between proposal-acceptance pair.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#DiffusionMCMCTools.swap_XX!-Tuple{BiBlock}","page":"BiBlock","title":"DiffusionMCMCTools.swap_XX!","text":"swap_XX!(bb::BiBlock)\n\nSwap XX containers between proposal-acceptance pair.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#DiffusionMCMCTools.swap_WW!-Tuple{BiBlock}","page":"BiBlock","title":"DiffusionMCMCTools.swap_WW!","text":"swap_WW!(bb::BiBlock)\n\nSwap WW containers between proposal-acceptance pair.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#DiffusionMCMCTools.swap_PP!-Tuple{BiBlock}","page":"BiBlock","title":"DiffusionMCMCTools.swap_PP!","text":"swap_PP!(bb::BiBlock)\n\nSwap PP containers (including PP_last) between proposal-acceptance pair.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#DiffusionMCMCTools.swap_ll!-Tuple{BiBlock}","page":"BiBlock","title":"DiffusionMCMCTools.swap_ll!","text":"swap_ll!(bb::BiBlock)\n\nSwap ll containers between proposal-acceptance pair.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#Setting-up-a-block-1","page":"BiBlock","title":"Setting up a block","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"","category":"page"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"DiffusionMCMCTools.set_obs!(bb::DiffusionMCMCTools.BiBlock)\nDiffusionMCMCTools.recompute_guiding_term!(bb::DiffusionMCMCTools.BiBlock)\nDiffusionMCMCTools.find_W_for_X!(bb::DiffusionMCMCTools.BiBlock)","category":"page"},{"location":"manual/biblock/#GuidedProposals.set_obs!-Tuple{BiBlock}","page":"BiBlock","title":"GuidedProposals.set_obs!","text":"GP.set_obs!(bb::BiBlock)\n\nFreeze an artificial observation at the terminal point of the block. For a terminal block nothing is done.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#GuidedProposals.recompute_guiding_term!-Tuple{BiBlock}","page":"BiBlock","title":"GuidedProposals.recompute_guiding_term!","text":"GP.recompute_guiding_term!(bb::BiBlock)\n\nRecompute the guiding terms of both the proposal and the accepted laws.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#DiffusionMCMCTools.find_W_for_X!-Tuple{BiBlock}","page":"BiBlock","title":"DiffusionMCMCTools.find_W_for_X!","text":"find_W_for_X!(bb::BiBlock)\n\nFind the Wiener process bb.b.WW that reconstructs path bb.b.XX under the accepted law bb.b.PP (possibly including bb.b.P_last).\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#Setting-parameters-1","page":"BiBlock","title":"Setting parameters","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"","category":"page"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"DiffusionMCMCTools.set_proposal_law!(\n    bb::DiffusionMCMCTools.BiBlock,\n    θ°,\n    pnames,\n    critical_change=DiffusionMCMCTools.is_critical_update(bb, pnames),\n    skip=0\n)\n","category":"page"},{"location":"manual/biblock/#Utility-1","page":"BiBlock","title":"Utility","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"","category":"page"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"DiffusionMCMCTools.ll_of_accepted(bb::DiffusionMCMCTools.BiBlock, i)\nDiffusionMCMCTools.accpt_rate(bb::DiffusionMCMCTools.BiBlock, range)\nDiffusionMCMCTools.loglikhd!(bb::DiffusionMCMCTools.BiBlock)\nDiffusionMCMCTools.loglikhd°!(bb::DiffusionMCMCTools.BiBlock)\nDiffusionMCMCTools.save_ll!(bb::DiffusionMCMCTools.BiBlock, i::Int)","category":"page"},{"location":"manual/biblock/#DiffusionMCMCTools.ll_of_accepted-Tuple{BiBlock,Any}","page":"BiBlock","title":"DiffusionMCMCTools.ll_of_accepted","text":"ll_of_accepted(bb::BiBlock, i)\n\nReturn the log-likelihood of the path that was accepted at the ith iteration.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#DiffusionMCMCTools.accpt_rate-Tuple{BiBlock,Any}","page":"BiBlock","title":"DiffusionMCMCTools.accpt_rate","text":"accpt_rate(bb::BiBlock, range)\n\nCompute the acceptance rate over the range of MCMC accept/reject history.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#DiffusionMCMCTools.loglikhd!-Tuple{BiBlock}","page":"BiBlock","title":"DiffusionMCMCTools.loglikhd!","text":"loglikhd!(b::BiBlock)\n\nCompute the log-likelihood for the accepted block, evaluated at a sampled path and store the result in an internal field ll.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#DiffusionMCMCTools.loglikhd°!-Tuple{BiBlock}","page":"BiBlock","title":"DiffusionMCMCTools.loglikhd°!","text":"loglikhd°!(b::BiBlock)\n\nCompute the log-likelihood for the proposal block, evaluated at a sampled path and store the result in an internal field ll.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#DiffusionMCMCTools.save_ll!-Tuple{BiBlock,Int64}","page":"BiBlock","title":"DiffusionMCMCTools.save_ll!","text":"save_ll!(bb::BiBlock, i::Int)\n\nCommit the current proposal and accepted log-likelihood fields ll to history, at index i.\n\n\n\n\n\n","category":"method"},{"location":"manual/biblock/#Example:-smoothing-with-no-blocking-1","page":"BiBlock","title":"Example: smoothing with no blocking","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"","category":"page"},{"location":"manual/biblock/#Set-up-1","page":"BiBlock","title":"Set-up","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"using GuidedProposals, DiffusionDefinition, ObservationSchemes, DiffusionMCMCTools\nconst GP = GuidedProposals\nconst DD = DiffusionDefinition\nconst OBS = ObservationSchemes\nconst dMCMCt = DiffusionMCMCTools\n\nusing StaticArrays, Random, Plots\n\n# seed used for this tutorial\nRandom.seed!(100)\n\n@load_diffusion FitzHughNagumo\nθ = [0.1, -0.8, 1.5, 0.0, 0.3]\nP = FitzHughNagumo(θ...)\ntt, y1 = 0.0:0.0001:10.0, @SVector [-0.9, -1.0]\nX = rand(P, tt, y1)\nobs_scheme = ObsScheme(\n    LinearGsnObs(\n        0.0, (@SVector [0.0]);\n        L=(@SMatrix [1.0 0.0]),\n        Σ=(@SMatrix [0.01])\n    )\n)\ndata = collect(obs_scheme, X, 1000)\nrecording = build_recording(P, data, 0.0, KnownStartingPt(y1))\n\nplot(X, Val(:vs_time), size=(800, 300))\nscatter!(map(x->x.t, data), map(x->x.obs[1], data), label=\"data\")","category":"page"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"(Image: data)","category":"page"},{"location":"manual/biblock/#The-algorithm-1","page":"BiBlock","title":"The algorithm","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"function simple_smoothing(AuxLaw, recording, dt; ρ=0.5, num_steps=10^4)\n    tts = OBS.setup_time_grids(recording, dt, standard_guid_prop_time_transf)\n    # this object contains containers\n    sp = SamplingPair(AuxLaw, recording, tts)\n    # and this has pointers to containers and facilitates actual sampling\n    bb = BiBlock(sp, 1:length(recording.obs), ρ, true, num_steps)\n    loglikhd!(bb)\n    paths = []\n\n    # MCMC\n    for i in 1:num_steps\n        # impute a path\n        draw_proposal_path!(bb)\n        # Metropolis–Hastings accept/reject step\n        accept_reject_proposal_path!(bb, i)\n\n        # progress message\n        if i % 100 == 0\n            println(\n                \"$i. ll=$(ll_of_accepted(bb, i)), acceptance rate: \",\n                \"$(sum(bb.accpt_history[(i-99):i])/100)\"\n            )\n        end\n\n        # save intermediate path for plotting\n        i % 400 == 0 && append!(paths, [deepcopy(bb.b.XX)])\n    end\n    paths\nend\n\n@load_diffusion FitzHughNagumoAux\npaths = simple_smoothing(\n    FitzHughNagumoAux, recording, 0.001; ρ=0.96, num_steps=10^4\n)","category":"page"},{"location":"manual/biblock/#Results-1","page":"BiBlock","title":"Results","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"function glue_paths(XX)\n    XX_glued = trajectory(\n        glue_containers( map(x->x.t, XX) ),\n        glue_containers( map(x->x.x, XX) ),\n    )\nend\n\nfunction glue_containers(xs)\n    glued_xs = collect(Iterators.flatten(map(x->x[1:end-1], xs)))\n    append!(glued_xs, [xs[end][end]])\n    glued_xs\nend\n\nconvenient_paths = glue_paths.(paths)\n\ncol = [\"#581845\", \"#900C3F\", \"#C70039\", \"#FF5733\", \"#FFC300\"]\n\np = plot(size=(1000, 500))\nfor path in convenient_paths\n\tplot!(p, path, Val(:vs_time), alpha=0.4, label=\"\", color=[col[3] col[1]])\nend\nplot!(X, Val(:vs_time), color=[col[5] col[4]], linewidth=[3 0.5], label=[\"underlying X₁\" \"underlying X₂\"])\nscatter!(p, map(x->x.t, data), map(x->x.obs[1], data), label=\"data\", markercolor=col[5])\ndisplay(p)","category":"page"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"(Image: smoothing)","category":"page"},{"location":"manual/biblock/#Example:-smoothing-with-blocking-1","page":"BiBlock","title":"Example: smoothing with blocking","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"","category":"page"},{"location":"manual/biblock/#Set-up-2","page":"BiBlock","title":"Set-up","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"Same as above","category":"page"},{"location":"manual/biblock/#The-algorithm-2","page":"BiBlock","title":"The algorithm","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"function simple_smoothing_with_blocking(\n        AuxLaw, recording, dt, AuxLawBlocking, block_layout;\n        ρ=0.5, num_steps=10^4\n    )\n    tts = OBS.setup_time_grids(recording, dt, standard_guid_prop_time_transf)\n    # this object contains containers\n    sp = SamplingPair(AuxLaw, recording, tts)\n    # and this has pointers to containers and facilitates actual sampling\n    blocks = [\n        [\n            BiBlock(sp, br, ρ, i==length(block_ranges), num_steps)\n            for (i,br) in enumerate(block_ranges)\n        ] for block_ranges in block_layout\n    ]\n\n    paths = []\n\n    N = length(blocks)\n    # MCMC\n    for i in 1:num_steps\n        for B in blocks\n            # freeze terminal points of blocks to be artificial observations\n            GP.set_obs!.(B)\n            # recompute the guiding term only on the \"accepted\" laws `bb.b.PP`\n            (bb->recompute_guiding_term!(bb.b)).(B)\n            # recompute the Wiener path\n            find_W_for_X!.(B)\n            # re-evaluate the log-likelihood\n            loglikhd!.(B)\n            # impute a path\n            draw_proposal_path!.(B)\n            # Metropolis–Hastings accept/reject step\n            accept_reject_proposal_path!.(B, i)\n\n            # progress message\n            if i % 100 == 0\n                println(\n                    \"$i. ll=$(ll_of_accepted.(B, i)), acceptance rate: \",\n                    \"$( map(bb->accpt_rate(bb, (i-99):i), B) )\"\n                )\n            end\n        end\n\n        # save intermediate path for plotting\n        i % 400 == 0 && append!(paths, [deepcopy(sp.u.XX)])\n    end\n    paths\nend","category":"page"},{"location":"manual/biblock/#Results-2","page":"BiBlock","title":"Results","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"@inline DD.nonhypo(x, P::FitzHughNagumo) = x[SVector{1,Int64}(2)]\n@inline DD.nonhypo_σ(t::Float64, x, P::FitzHughNagumo) = SMatrix{1,1,Float64}(P.σ)\npaths = simple_smoothing_with_blocking(\n    FitzHughNagumoAux, recording, 0.001, FitzHughNagumoAux,\n    [[1:25,26:75,76:100],[1:50, 51:100]];\n    ρ=0.96, num_steps=10^4\n)","category":"page"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"Same plotting routines as above yield: (Image: smoothing_with_blocking_results)","category":"page"},{"location":"manual/biblock/#Example:-inference-with-no-blocking-1","page":"BiBlock","title":"Example: inference with no blocking","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"","category":"page"},{"location":"manual/biblock/#Set-up-3","page":"BiBlock","title":"Set up","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"Same as before","category":"page"},{"location":"manual/biblock/#The-algorithm-3","page":"BiBlock","title":"The algorithm","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"customkernel(θ, scale=0.1) = θ .+ 2.0*scale*(rand()-0.5)\n\n#=\n    NOTE: this will appear to be completely unnecessary and coming out of the\n    blue if you are not considering more complicated settings of mixed effect\n    models. Looking up ahead into the definition of ... should be helpful if\n    you want to understand what the function below is aiming to do.\n\n    In here, we are just creating the most basic struture that is needed for\n    setting parameters. It can be much more complex if blocking, multiple\n    updates and/or mixed effect models were used.\n=#\n#↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓\n_build_struct(N, args...) = (\n    var = tuple(),\n    var_aux = fill(tuple(), N),\n    updt = tuple(args...),\n    updt_aux = fill(tuple(args...), N),\n    updt_obs = fill(tuple(), N),\n)\n\nfunction simple_name_structure(pname::Symbol, num_obs)\n    pnames = (\n        PP = _build_struct(num_obs, (1=>pname)),\n        P_last = _build_struct(0), # was num_obs\n        P_excl = _build_struct(0),\n        Pb_excl = _build_struct(num_obs, (1=>pname)),\n    )\nend\n#↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑\n\nfunction accept_reject_proposal_param!(bb, mcmciter, θ, θ°)\n    accepted = rand(Exponential(1.0)) > -(bb.b°.ll - bb.b.ll)\n    accepted && swap_XX!(bb)\n    accepted && swap_PP!(bb)\n    save_ll!(bb, mcmciter)\n    accepted && swap_ll!(bb)\n    accepted, copy(accepted ? θ° : θ)\nend\n\nfunction simple_inference(AuxLaw, recording, dt, _θ; ϵ=0.3, ρ=0.5, num_steps=10^4)\n    # making sure that things are in order...\n    _pname = collect(keys(_θ))\n    # for simplicity restrict to inference for a single param\n    @assert length(_pname) == 1\n    pname = first(_pname)\n    θ = collect(values(_θ))\n\n    # setting the initial guess θ inside the recording\n    OBS.set_parameters!(recording, _θ)\n\n    # setting up containers\n    num_obs = length(recording.obs)\n    tts = OBS.setup_time_grids(recording, dt, standard_guid_prop_time_transf)\n    sp = SamplingPair(AuxLaw, recording, tts)\n    bb = BiBlock(sp, 1:num_obs, ρ, true, num_steps)\n    name_struct = simple_name_structure(pname, num_obs)\n\n    loglikhd!(bb)\n    paths = []\n\n    θθ = [θ]\n    a_h = Bool[]\n\n    for i in 1:num_steps\n        draw_proposal_path!(bb)\n        accept_reject_proposal_path!(bb, i)\n\n        θ° = customkernel(θ, ϵ)\n        set_proposal_law!(bb, θ°, name_struct, true)\n\n        accpt, θ = accept_reject_proposal_param!(bb, i, θ, θ°)\n        push!(θθ, θ)\n        push!(a_h, accpt)\n\n        # progress message\n        if i % 100 == 0\n            println(\n                \"$i. ll=$(ll_of_accepted(bb, i)), \",\n                \"imp a-r: \",\n                \" $(accpt_rate(bb, (i-99):i)), \",\n                \"updt a-r: \",\n                \"$(sum(a_h[(i-99):i])/100).\"\n            )\n        end\n\n        # save intermediate path for plotting\n        i % 400 == 0 && append!(paths, [deepcopy(sp.u.XX)])\n    end\n    paths, θθ\nend","category":"page"},{"location":"manual/biblock/#Results-3","page":"BiBlock","title":"Results","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"plot(getindex.(θθ, 1))","category":"page"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"(Image: inference_chain)","category":"page"},{"location":"manual/biblock/#Example:-inference-with-blocking-1","page":"BiBlock","title":"Example: inference with blocking","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"","category":"page"},{"location":"manual/biblock/#Set-up-4","page":"BiBlock","title":"Set up","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"Same as before","category":"page"},{"location":"manual/biblock/#The-algorithm-4","page":"BiBlock","title":"The algorithm","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"#↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓\nfunction simple_name_structure_not_last(pname::Symbol, num_obs)\n    pnames = (\n        PP = _build_struct(num_obs-1, (1=>pname)),\n        P_last = _build_struct(1, (1=>pname)),\n        P_excl = _build_struct(1, (1=>pname)),\n        Pb_excl = _build_struct(num_obs-1, (1=>pname)),\n    )\nend\n\nfunction simple_name_structure_blocking(pname::Symbol, block_layout)\n    map(block_layout) do block_set\n        map(enumerate(block_set)) do (i, block)\n            (\n                i == length(block_set) ?\n                simple_name_structure(pname, length(block)) :\n                simple_name_structure_not_last(pname, length(block))\n            )\n        end\n    end\nend\n#↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑\n\nfunction accept_reject_proposal_param!(B::AbstractArray{<:BiBlock}, mcmciter, θ, θ°)\n    accepted = rand(Exponential(1.0)) > mapreduce(bb->-(bb.b°.ll - bb.b.ll),+,B)\n    accepted && swap_XX!.(B)\n    accepted && swap_PP!.(B)\n    (bb->save_ll!(bb.b, mcmciter)).(B)\n    (bb->save_ll!(bb.b°, mcmciter)).(B)\n    accepted && swap_ll!.(B)\n    accepted, copy(accepted ? θ° : θ)\nend\n\n\nfunction simple_inference_with_blocking(\n        AuxLaw, recording, dt, AuxLawBlocking, block_layout, _θ;\n        ϵ=0.3, ρ=0.5, num_steps=10^4\n    )\n    # making sure that things are in order...\n    _pname = collect(keys(_θ))\n    # for simplicity restrict to inference for a single param\n    @assert length(_pname) == 1\n    pname = first(_pname)\n    θ = collect(values(_θ))\n\n    # setting the initial guess θ inside the recording\n    OBS.set_parameters!(recording, _θ)\n\n    # setting up containers\n    tts = OBS.setup_time_grids(recording, dt, standard_guid_prop_time_transf)\n    sp = SamplingPair(AuxLaw, recording, tts)\n    blocks = [\n        [\n            BiBlock(sp, br, ρ, i==length(block_ranges), num_steps)\n            for (i,br) in enumerate(block_ranges)\n        ] for block_ranges in block_layout\n    ]\n    name_struct = simple_name_structure_blocking(pname, block_layout)\n\n    paths = []\n\n    θθ = [θ]\n    a_h = Bool[]\n\n    # MCMC\n    for i in 1:num_steps\n        for B in blocks\n            GP.set_obs!.(B)\n            (bb->recompute_guiding_term!(bb.b)).(B)\n            find_W_for_X!.(B)\n            loglikhd!.(B)\n            draw_proposal_path!.(B)\n            accept_reject_proposal_path!.(B, i)\n\n            # progress message\n            if i % 100 == 0\n                println(\n                    \"$i. ll=$(ll_of_accepted.(B, i)), acceptance rate: \",\n                    \"$( map(bb->accpt_rate(bb, (i-99):i), B) )\"\n                )\n            end\n        end\n\n        θ° = customkernel(θ, ϵ)\n\n        B = blocks[end]\n        for (idx, bb) in enumerate(B)\n            set_proposal_law!(bb, θ°, name_struct[end][idx], true)\n        end\n        (bb->recompute_guiding_term!(bb.b°)).(B)\n\n        accpt, θ = accept_reject_proposal_param!(B, i, θ, θ°)\n        push!(θθ, θ)\n        push!(a_h, accpt)\n\n        if i % 100 == 0\n            println(\n                \"$i. updt a-r: \",\n                \"$(sum(a_h[(i-99):i])/100).\"\n            )\n        end\n\n        # save intermediate path for plotting\n        i % 400 == 0 && append!(paths, [deepcopy(sp.u.XX)])\n    end\n    paths, θθ\nend","category":"page"},{"location":"manual/biblock/#The-results-1","page":"BiBlock","title":"The results","text":"","category":"section"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"using OrderedCollections\n\nθ = OrderedDict(:γ=>1.5)\n\nDD.var_parameter_names(::FitzHughNagumo) = (:γ,)\nDD.var_parameter_names(::FitzHughNagumoAux) = (:γ,)\n\n@load_diffusion FitzHughNagumoAux\npaths, θθ = simple_inference_with_blocking(\n    FitzHughNagumoAux, recording, 0.001, FitzHughNagumoAux,\n    [[1:25,26:75,76:100],[1:50, 51:100]], θ; ϵ=0.3, ρ=0.96, num_steps=10^4\n)\n\nplot(getindex.(θθ, 1))","category":"page"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"(Image: inference_with_blocking_chain)","category":"page"},{"location":"manual/biblock/#","page":"BiBlock","title":"BiBlock","text":"note: Note\nAs you can see above, BiBlock is the fundamental building block that is used for creating inference and smoothing algorithms. However, as the complexity of these algorithms grow it is useful to use some macro structures that operate on or are defined for multiple BiBlocks. This is precisely what the remaining tools defined in this package are for. Otherwise put, they aim to facilitate writing snippets of code as above in a much more compact and convenient way.","category":"page"},{"location":"manual/sampling_unit/#The-smallest-sampling-unit:-SamplingUnit-1","page":"SamplingUnit","title":"The smallest sampling unit: SamplingUnit","text":"","category":"section"},{"location":"manual/sampling_unit/#","page":"SamplingUnit","title":"SamplingUnit","text":"","category":"page"},{"location":"manual/sampling_unit/#","page":"SamplingUnit","title":"SamplingUnit","text":"The struct","category":"page"},{"location":"manual/sampling_unit/#","page":"SamplingUnit","title":"SamplingUnit","text":"DiffusionMCMCTools.SamplingUnit","category":"page"},{"location":"manual/sampling_unit/#DiffusionMCMCTools.SamplingUnit","page":"SamplingUnit","title":"DiffusionMCMCTools.SamplingUnit","text":"struct SamplingUnit{TGP,TGPb,TW,TWn,TX}\n    PP::Vector{TGP}\n    PPb::Vector{TGPb}\n    WW::Vector{TW}\n    Wnr::TWn\n    XX::Vector{TX}\nend\n\nSmallest composite unit with containers needed for sampling of conditioned diffusions via Guided Proposals.\n\nFields\n\n\n\nPP: a vector of GuidProp\nPPb: a vector of GuidProp that can be used in a blocking schemes as        GuidProps on terminal subintervals\nWW: a vector of containers for sampled Wiener process\nWnr: a flag for sampling Wiener processes\nXX: a vector of containers for a sampled process\nSamplingUnit(       auxlaws, recording, tts, args=tuple();       auxlawsblocking=auxlaws, artificialnoise=1e-11,       solverchoice_blocking=args   )\n\nBase constructor.\n\nArguments\n\n\n\naux_laws:\nrecording:\ntts:\nargs:\naux_laws_blocking:\nartificial_noise:\nsolver_choice_blocking:\n\n\n\n\n\n","category":"type"},{"location":"manual/sampling_unit/#","page":"SamplingUnit","title":"SamplingUnit","text":"is the main building block of all remaining units implemented in this package. It has a couple of methods implemented for it:","category":"page"},{"location":"manual/sampling_unit/#","page":"SamplingUnit","title":"SamplingUnit","text":"DiffusionMCMCTools.recompute_guiding_term!(u::DiffusionMCMCTools.SamplingUnit)\nDiffusionMCMCTools.loglikhd(u::DiffusionMCMCTools.SamplingUnit)\nDiffusionMCMCTools.draw_proposal_path!(u::DiffusionMCMCTools.SamplingUnit)","category":"page"},{"location":"manual/sampling_unit/#GuidedProposals.recompute_guiding_term!-Tuple{SamplingUnit}","page":"SamplingUnit","title":"GuidedProposals.recompute_guiding_term!","text":"GP.recompute_guiding_term!(u::SamplingUnit)\n\nRecompute the guiding term assuming u.PP is a vector with guided proposal laws\n\n\n\n\n\n","category":"method"},{"location":"manual/sampling_unit/#GuidedProposals.loglikhd-Tuple{SamplingUnit}","page":"SamplingUnit","title":"GuidedProposals.loglikhd","text":"GP.loglikhd(u::SamplingUnit)\n\nReturn log-likelihood evaluated at a sampled path\n\n\n\n\n\n","category":"method"},{"location":"manual/sampling_unit/#DiffusionMCMCTools.draw_proposal_path!-Tuple{SamplingUnit}","page":"SamplingUnit","title":"DiffusionMCMCTools.draw_proposal_path!","text":"draw_proposal_path!(u::SamplingUnit)\n\nSample a proposal path, compute log-likelihood along the way. Assumes u.XX[1].x[1] is a starting point. No preconditioned Crank-Nicolson scheme is used.\n\n\n\n\n\n","category":"method"},{"location":"manual/sampling_unit/#","page":"SamplingUnit","title":"SamplingUnit","text":"However, because it does not contain proposal-accepted pair it is rarely used on its own for sampling. Instead, it most often appears as a member of other struct.","category":"page"},{"location":"manual/sampling_pair/#A-pairing-of-two-SamplingUnits-1","page":"SamplingPair","title":"A pairing of two SamplingUnits","text":"","category":"section"},{"location":"manual/sampling_pair/#","page":"SamplingPair","title":"SamplingPair","text":"","category":"page"},{"location":"manual/sampling_pair/#","page":"SamplingPair","title":"SamplingPair","text":"Defines all main containers for an entire single recording for a smoothing or inference problem.","category":"page"},{"location":"manual/sampling_pair/#","page":"SamplingPair","title":"SamplingPair","text":"DiffusionMCMCTools.SamplingPair","category":"page"},{"location":"manual/sampling_pair/#DiffusionMCMCTools.SamplingPair","page":"SamplingPair","title":"DiffusionMCMCTools.SamplingPair","text":"struct SamplingPair{TGP,TGPb,TW,TWn,TX}\n    u::SamplingUnit{TGP,TGPb,TW,TWn,TX}\n    u°::SamplingUnit{TGP,TGPb,TW,TWn,TX}\nend\n\nA pairing of two SamplingUnits, can be used for smoothing or inference problems.\n\nSamplingPair(\n    aux_laws, recording, tts, args=tuple();\n    aux_laws_blocking=aux_laws, artificial_noise=1e-11,\n    solver_choice_blocking=args\n)\n\nBase constructor.\n\nArguments\n\n\n\naux_laws:\nrecording:\ntts:\nargs:\naux_laws_blocking:\nartificial_noise:\nsolver_choice_blocking:\n\n\n\n\n\n","category":"type"},{"location":"manual/sampling_pair/#","page":"SamplingPair","title":"SamplingPair","text":"note: Note\nIn practice all sampling is done with a BiBlock that looks at sections of a SamplingPair and never through SamplingPair directly. Even when no blocking is needed, it should still be done by defining a BiBlock that simply looks at the entire SamplingPair.","category":"page"},{"location":"#DiffusionMCMCTools-1","page":"Home","title":"DiffusionMCMCTools","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Utility package for performing MCMC sampling for diffusion processes.","category":"page"},{"location":"manual/block_ensemble/#BlockEnsemble-1","page":"BlockEnsemble","title":"BlockEnsemble","text":"","category":"section"},{"location":"manual/block_ensemble/#","page":"BlockEnsemble","title":"BlockEnsemble","text":"","category":"page"},{"location":"manual/block_ensemble/#","page":"BlockEnsemble","title":"BlockEnsemble","text":"DiffusionMCMCTools.BlockEnsemble","category":"page"},{"location":"manual/block_ensemble/#DiffusionMCMCTools.BlockEnsemble","page":"BlockEnsemble","title":"DiffusionMCMCTools.BlockEnsemble","text":"struct BlockEnsemble{T}\n    recordings::Vector{T}\nend\n\nGathers all blocks relevant for an entire single recording.\n\nBlockEnsemble(\n    se::SamplingEnsemble,\n    ranges,\n    ρρ=0.0,\n    ll_hist_len=0\n)\n\nBase constructor.\n\n\n\n\n\n","category":"type"},{"location":"manual/block_ensemble/#Example-1","page":"BlockEnsemble","title":"Example","text":"","category":"section"},{"location":"manual/block_ensemble/#Set-up-1","page":"BlockEnsemble","title":"Set up","text":"","category":"section"},{"location":"manual/block_ensemble/#","page":"BlockEnsemble","title":"BlockEnsemble","text":"using GuidedProposals, DiffusionDefinition, ObservationSchemes, DiffusionMCMCTools\nconst GP = GuidedProposals\nconst DD = DiffusionDefinition\nconst OBS = ObservationSchemes\nconst dMCMCt = DiffusionMCMCTools\n\nusing StaticArrays, Random, Plots, Distributions\n\n# seed used for this tutorial\nRandom.seed!(100)\n\n@load_diffusion FitzHughNagumo\nθ = [0.1, -0.8, 1.5, 0.0, 0.3]\nP = FitzHughNagumo(θ...)\ntt, y1 = 0.0:0.0001:10.0, @SVector [-0.9, -1.0]\nnum_recs = 2\nXs = [rand(P, tt, y1) for i in 1:num_recs]\nobs_scheme = ObsScheme(\n    LinearGsnObs(\n        0.0, (@SVector [0.0]);\n        L=(@SMatrix [1.0 0.0]),\n        Σ=(@SMatrix [0.01])\n    )\n)\ndata = [collect(obs_scheme, Xs[i], 1000) for i in 1:num_recs]\n\nall_obs = AllObservations()\nadd_recordings!(\n    all_obs,\n    [build_recording(P, data[i], 0.0, KnownStartingPt(y1)) for i in 1:num_recs]\n)\nadd_dependency!(\n    all_obs,\n    Dict(\n        :γ_shared => [(1, :γ), (2, :γ)],\n    )\n)\nDD.var_parameter_names(::FitzHughNagumo) = (:γ,)\nall_obs, _ = initialize(all_obs)\n\n\n\nps = [plot(Xs[i], Val(:vs_time)) for i in 1:num_recs]\n[scatter!(ps[i], map(x->x.t, data[i]), map(x->x.obs[1], data[i]), label=\"data\") for i in 1:num_recs]\nplot(ps..., layout=(num_recs,1), size=(800, 300*num_recs))","category":"page"},{"location":"manual/block_ensemble/#","page":"BlockEnsemble","title":"BlockEnsemble","text":"(Image: inference_data)","category":"page"},{"location":"manual/block_ensemble/#The-algorithm-1","page":"BlockEnsemble","title":"The algorithm","text":"","category":"section"},{"location":"manual/block_ensemble/#","page":"BlockEnsemble","title":"BlockEnsemble","text":"customkernel(θ, scale=0.1) = θ .+ 2.0*scale*(rand()-0.5)\n\nfunction accept_reject_proposal_param!(bc, mcmciter, θ, θ°)\n    accepted = rand(Exponential(1.0)) > -(fetch_ll°(bc)-fetch_ll(bc))\n    accepted && swap_XX!(bc)\n    accepted && swap_PP!(bc)\n    save_ll!(bc, mcmciter)\n    accepted && swap_ll!(bc)\n    accepted, copy(accepted ? θ° : θ)\nend\n\nfunction simple_inference(AuxLaw, all_obs, dt, _θ; ϵ=0.3, ρ=0.5, num_steps=10^4)\n    # making sure that things are in order...\n    _pname = collect(keys(_θ))\n    # for simplicity restrict to inference for a single param\n    @assert length(_pname) == 1\n    pname = first(_pname)\n    θ = collect(values(_θ))\n\n    # setting the initial guess θ inside the recording\n    OBS.set_parameters!(all_obs, _θ)\n\n    # setting up containers\n    tts = OBS.setup_time_grids(all_obs, dt, standard_guid_prop_time_transf)\n    se = SamplingEnsemble(AuxLaw, all_obs.recordings, tts)\n    be = BlockEnsemble(\n        se,\n        collect([[1:length(rec.obs)] for rec in all_obs.recordings]),\n        ρ,\n        num_steps\n    )\n    name_struct = ParamNamesAllObs(be, _pname, all_obs)\n\n    loglikhd!(be)\n    paths = []\n\n    θθ = [θ]\n    a_h = Bool[]\n    crit_change = collect([[true] for rec in se.recordings])\n\n    for i in 1:num_steps\n        draw_proposal_path!(be)\n        accept_reject_proposal_path!(be, i)\n\n        θ° = customkernel(θ, ϵ)\n        set_proposal_law!(be, θ°, name_struct, crit_change)\n\n        accpt, θ = accept_reject_proposal_param!(be, i, θ, θ°)\n        push!(θθ, θ)\n        push!(a_h, accpt)\n\n        # progress message\n        if i % 100 == 0\n            println(\n                \"$i. ll=$(ll_of_accepted(be, i)), \",\n                \"imp a-r: \",\n                \" $(accpt_rate(be, (i-99):i)), \",\n                \"updt a-r: \",\n                \"$(sum(a_h[(i-99):i])/100).\"\n            )\n        end\n\n        # save intermediate path for plotting\n        i % 400 == 0 && append!(\n            paths,\n            [[deepcopy(rec.u.XX) for rec in se.recordings]]\n        )\n    end\n    paths, θθ\nend","category":"page"},{"location":"manual/block_ensemble/#Results-1","page":"BlockEnsemble","title":"Results","text":"","category":"section"},{"location":"manual/block_ensemble/#","page":"BlockEnsemble","title":"BlockEnsemble","text":"using OrderedCollections\n\nθ = OrderedDict(:γ_shared=>1.5)\n@load_diffusion FitzHughNagumoAux\nDD.var_parameter_names(::FitzHughNagumo) = (:γ,)\nDD.var_parameter_names(::FitzHughNagumoAux) = (:γ,)\npaths, θθ = simple_inference(\n    FitzHughNagumoAux, all_obs, 0.001, θ; ϵ=0.3, ρ=0.96, num_steps=10^4\n)\n\nplot(getindex.(θθ, 1))","category":"page"},{"location":"manual/block_ensemble/#","page":"BlockEnsemble","title":"BlockEnsemble","text":"(Image: inference_chain)","category":"page"},{"location":"manual/block_ensemble/#","page":"BlockEnsemble","title":"BlockEnsemble","text":"function glue_paths(XX)\n    XX_glued = trajectory(\n        glue_containers( map(x->x.t, XX) ),\n        glue_containers( map(x->x.x, XX) ),\n    )\nend\n\nfunction glue_containers(xs)\n    glued_xs = collect(Iterators.flatten(map(x->x[1:end-1], xs)))\n    append!(glued_xs, [xs[end][end]])\n    glued_xs\nend\n\nconvenient_paths = [glue_paths.(getindex.(paths, i)) for i in 1:num_recs]\n\ncol = [\"#581845\", \"#900C3F\", \"#C70039\", \"#FF5733\", \"#FFC300\"]\n\np = collect([plot() for i in 1:num_recs])\nfor i in 1:num_recs\n    for path in convenient_paths[i]\n    \tplot!(p[i], path, Val(:vs_time), alpha=0.4, label=\"\", color=[col[3] col[1]])\n    end\n    plot!(p[i], Xs[i], Val(:vs_time), color=[col[5] col[4]], linewidth=[3 0.5], label=[\"underlying X₁\" \"underlying X₂\"])\n    scatter!(p[i], map(x->x.t, data[i]), map(x->x.obs[1], data[i]), label=\"data\", markercolor=col[5])\nend\nplot(p..., layout=(num_recs, 1), size=(1000, 500*num_recs))","category":"page"},{"location":"manual/block_ensemble/#","page":"BlockEnsemble","title":"BlockEnsemble","text":"(Image: inference_smoothed_paths)","category":"page"},{"location":"manual/sampling_ensemble/#SamplingEnsemble-1","page":"SamplingEnsemble","title":"SamplingEnsemble","text":"","category":"section"},{"location":"manual/sampling_ensemble/#","page":"SamplingEnsemble","title":"SamplingEnsemble","text":"","category":"page"},{"location":"manual/sampling_ensemble/#","page":"SamplingEnsemble","title":"SamplingEnsemble","text":"DiffusionMCMCTools.SamplingEnsemble","category":"page"},{"location":"manual/sampling_ensemble/#DiffusionMCMCTools.SamplingEnsemble","page":"SamplingEnsemble","title":"DiffusionMCMCTools.SamplingEnsemble","text":"struct SamplingEnsemble{T}\n    recordings::Vector{T}\nend\n\nA collection of SamplingPairs, can be used for smoothing or inference problems.\n\nSamplingEnsemble(\n    aux_laws, recordings, tts, args=tuple();\n    aux_laws_blocking=aux_laws, artificial_noise=1e-11,\n    solver_choice_blocking=args\n)\n\nBase constructor.\n\n\n\n\n\n","category":"type"}]
}
