<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>BiBlock · DiffusionMCMCTools.jl</title><link rel="canonical" href="https://JuliaDiffusionBayes.github.io/DiffusionMCMCTools.jl/manual/biblock/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">DiffusionMCMCTools.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">User manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../sampling_unit/">SamplingUnit</a></li><li><a class="tocitem" href="../block/">Block</a></li><li><a class="tocitem" href="../sampling_pair/">SamplingPair</a></li><li class="is-active"><a class="tocitem" href>BiBlock</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Example:-smoothing-with-no-blocking-1"><span>Example: smoothing with no blocking</span></a></li><li><a class="tocitem" href="#Set-up-1"><span>Set-up</span></a></li><li><a class="tocitem" href="#The-algorithm-1"><span>The algorithm</span></a></li><li><a class="tocitem" href="#Results-1"><span>Results</span></a></li><li class="toplevel"><a class="tocitem" href="#Example:-smoothing-with-blocking-1"><span>Example: smoothing with blocking</span></a></li><li><a class="tocitem" href="#Set-up-2"><span>Set-up</span></a></li><li><a class="tocitem" href="#The-algorithm-2"><span>The algorithm</span></a></li><li><a class="tocitem" href="#Results-2"><span>Results</span></a></li><li class="toplevel"><a class="tocitem" href="#Example:-inference-with-no-blocking-1"><span>Example: inference with no blocking</span></a></li><li><a class="tocitem" href="#Set-up-3"><span>Set up</span></a></li><li><a class="tocitem" href="#The-algorithm-3"><span>The algorithm</span></a></li><li><a class="tocitem" href="#Results-3"><span>Results</span></a></li><li class="toplevel"><a class="tocitem" href="#Example:-inference-with-blocking-1"><span>Example: inference with blocking</span></a></li><li><a class="tocitem" href="#Set-up-4"><span>Set up</span></a></li><li><a class="tocitem" href="#The-algorithm-4"><span>The algorithm</span></a></li><li><a class="tocitem" href="#The-results-1"><span>The results</span></a></li></ul></li><li><a class="tocitem" href="../param_names_collections/">Containers for parameter names</a></li><li><a class="tocitem" href="../block_collection/">BlockCollection</a></li><li><a class="tocitem" href="../sampling_ensemble/">SamplingEnsemble</a></li><li><a class="tocitem" href="../block_ensemble/">BlockEnsemble</a></li></ul></li><li><a class="tocitem" href="../../module_index/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User manual</a></li><li class="is-active"><a href>BiBlock</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>BiBlock</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDiffusionBayes/DiffusionMCMCTools.jl/blob/master/docs/src/manual/biblock.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="BiBlock-1"><a class="docs-heading-anchor" href="#BiBlock-1">BiBlock</a><a class="docs-heading-anchor-permalink" href="#BiBlock-1" title="Permalink"></a></h1><hr/><p>A composite unit that represents a block. It can be used for sampling on a block in a setting of smoothing or inference.</p><article class="docstring"><header><a class="docstring-binding" id="DiffusionMCMCTools.BiBlock" href="#DiffusionMCMCTools.BiBlock"><code>DiffusionMCMCTools.BiBlock</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct BiBlock{L,TGP,TGPl,TW,TWn,TX}
    b::Block{L,TGP,TGPl,TW,TWn,TX}
    b°::Block{L,TGP,TGPl,TW,TWn,TX}
    ρ::Float64
    accpt_history::Vector{Bool}
end</code></pre><p>Composite unit that allows for sampling of a single block. It provides two <code>Block</code>s: one proposal <code>b°</code>, one accepted <code>b</code> that can be used for smoothing or inference problems. <code>ρ</code> is a memory parameter of the preconditioned Crank-Nicolson scheme and <code>accpt_history</code> stores the history of accept/reject decisions (useful for MCMC).</p><pre><code class="language-none">function BiBlock(
    sp::SamplingPair,
    range::UnitRange{Int64},
    ρ=0.0,
    last_block=false,
    ll_hist_len=0
)</code></pre><p>Base constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiffusionBayes/DiffusionMCMCTools.jl/blob/31324438e716083f7327bd7b853bf46dec71d76d/src/biblock.jl#LL19-L42">source</a></section></article><p>There are many functions implemented for it.</p><h4 id="Imputation-of-paths-1"><a class="docs-heading-anchor" href="#Imputation-of-paths-1">Imputation of paths</a><a class="docs-heading-anchor-permalink" href="#Imputation-of-paths-1" title="Permalink"></a></h4><hr/><article class="docstring"><header><a class="docstring-binding" id="DiffusionMCMCTools.draw_proposal_path!-Tuple{BiBlock}" href="#DiffusionMCMCTools.draw_proposal_path!-Tuple{BiBlock}"><code>DiffusionMCMCTools.draw_proposal_path!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">draw_proposal_path!(bb::BiBlock)</code></pre><p>Sample a proposal path, compute log-likelihood along the way. Assumes <code>bb.b.XX[1].x[1]</code> is a starting point. Uses preconditioned Crank-Nicolson scheme with memory parameter set as <code>bb.ρ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiffusionBayes/DiffusionMCMCTools.jl/blob/31324438e716083f7327bd7b853bf46dec71d76d/src/biblock.jl#LL71-L77">source</a></section></article><h4 id="Accept/reject-decision-in-an-MCMC-setting-1"><a class="docs-heading-anchor" href="#Accept/reject-decision-in-an-MCMC-setting-1">Accept/reject decision in an MCMC setting</a><a class="docs-heading-anchor-permalink" href="#Accept/reject-decision-in-an-MCMC-setting-1" title="Permalink"></a></h4><hr/><article class="docstring"><header><a class="docstring-binding" id="DiffusionMCMCTools.accept_reject_proposal_path!-Tuple{BiBlock,Any}" href="#DiffusionMCMCTools.accept_reject_proposal_path!-Tuple{BiBlock,Any}"><code>DiffusionMCMCTools.accept_reject_proposal_path!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">accept_reject_proposal_path!(bb::BiBlock, mcmciter)</code></pre><p>Accept/reject decision of the Metropolis-Hastings algorithm for the step of path imputation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiffusionBayes/DiffusionMCMCTools.jl/blob/31324438e716083f7327bd7b853bf46dec71d76d/src/biblock.jl#LL115-L120">source</a></section></article><h4 id="Adjustments-made-after-the-accept-reject-decision-(regardless-of-what-it-was)-1"><a class="docs-heading-anchor" href="#Adjustments-made-after-the-accept-reject-decision-(regardless-of-what-it-was)-1">Adjustments made after the accept-reject decision (regardless of what it was)</a><a class="docs-heading-anchor-permalink" href="#Adjustments-made-after-the-accept-reject-decision-(regardless-of-what-it-was)-1" title="Permalink"></a></h4><hr/><article class="docstring"><header><a class="docstring-binding" id="DiffusionMCMCTools.set_accepted!-Tuple{BiBlock,Int64,Any}" href="#DiffusionMCMCTools.set_accepted!-Tuple{BiBlock,Int64,Any}"><code>DiffusionMCMCTools.set_accepted!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_accepted!(bb::BiBlock, i::Int, v)</code></pre><p>Commit the accept/reject decision <code>v</code> to acceptance history of BiBlock <code>b</code> at the position <code>i</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiffusionBayes/DiffusionMCMCTools.jl/blob/31324438e716083f7327bd7b853bf46dec71d76d/src/biblock.jl#LL129-L134">source</a></section></article><h4 id="Adjustments-to-the-containers-in-case-of-**acceptance**-of-proposals:-1"><a class="docs-heading-anchor" href="#Adjustments-to-the-containers-in-case-of-**acceptance**-of-proposals:-1">Adjustments to the containers in case of <strong>acceptance</strong> of proposals:</a><a class="docs-heading-anchor-permalink" href="#Adjustments-to-the-containers-in-case-of-**acceptance**-of-proposals:-1" title="Permalink"></a></h4><hr/><article class="docstring"><header><a class="docstring-binding" id="DiffusionMCMCTools.swap_paths!-Tuple{BiBlock}" href="#DiffusionMCMCTools.swap_paths!-Tuple{BiBlock}"><code>DiffusionMCMCTools.swap_paths!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">swap_paths!(bb::BiBlock)</code></pre><p>Swap <code>XX</code> and <code>WW</code> containers between proposal-acceptance pair.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiffusionBayes/DiffusionMCMCTools.jl/blob/31324438e716083f7327bd7b853bf46dec71d76d/src/biblock.jl#LL143-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffusionMCMCTools.swap_XX!-Tuple{BiBlock}" href="#DiffusionMCMCTools.swap_XX!-Tuple{BiBlock}"><code>DiffusionMCMCTools.swap_XX!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">swap_XX!(bb::BiBlock)</code></pre><p>Swap <code>XX</code> containers between proposal-acceptance pair.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiffusionBayes/DiffusionMCMCTools.jl/blob/31324438e716083f7327bd7b853bf46dec71d76d/src/biblock.jl#LL153-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffusionMCMCTools.swap_WW!-Tuple{BiBlock}" href="#DiffusionMCMCTools.swap_WW!-Tuple{BiBlock}"><code>DiffusionMCMCTools.swap_WW!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">swap_WW!(bb::BiBlock)</code></pre><p>Swap <code>WW</code> containers between proposal-acceptance pair.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiffusionBayes/DiffusionMCMCTools.jl/blob/31324438e716083f7327bd7b853bf46dec71d76d/src/biblock.jl#LL164-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffusionMCMCTools.swap_PP!-Tuple{BiBlock}" href="#DiffusionMCMCTools.swap_PP!-Tuple{BiBlock}"><code>DiffusionMCMCTools.swap_PP!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">swap_PP!(bb::BiBlock)</code></pre><p>Swap <code>PP</code> containers (including PP_last) between proposal-acceptance pair.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiffusionBayes/DiffusionMCMCTools.jl/blob/31324438e716083f7327bd7b853bf46dec71d76d/src/biblock.jl#LL175-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffusionMCMCTools.swap_ll!-Tuple{BiBlock}" href="#DiffusionMCMCTools.swap_ll!-Tuple{BiBlock}"><code>DiffusionMCMCTools.swap_ll!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">swap_ll!(bb::BiBlock)</code></pre><p>Swap <code>ll</code> containers between proposal-acceptance pair.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiffusionBayes/DiffusionMCMCTools.jl/blob/31324438e716083f7327bd7b853bf46dec71d76d/src/biblock.jl#LL202-L206">source</a></section></article><h4 id="Setting-up-a-block-1"><a class="docs-heading-anchor" href="#Setting-up-a-block-1">Setting up a block</a><a class="docs-heading-anchor-permalink" href="#Setting-up-a-block-1" title="Permalink"></a></h4><hr/><article class="docstring"><header><a class="docstring-binding" id="GuidedProposals.set_obs!-Tuple{BiBlock}" href="#GuidedProposals.set_obs!-Tuple{BiBlock}"><code>GuidedProposals.set_obs!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">GP.set_obs!(bb::BiBlock)</code></pre><p>Freeze an artificial observation at the terminal point of the block. For a terminal block nothing is done.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiffusionBayes/DiffusionMCMCTools.jl/blob/31324438e716083f7327bd7b853bf46dec71d76d/src/biblock.jl#LL267-L272">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GuidedProposals.recompute_guiding_term!-Tuple{BiBlock}" href="#GuidedProposals.recompute_guiding_term!-Tuple{BiBlock}"><code>GuidedProposals.recompute_guiding_term!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">GP.recompute_guiding_term!(bb::BiBlock)</code></pre><p>Recompute the guiding terms of both the proposal and the accepted laws.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiffusionBayes/DiffusionMCMCTools.jl/blob/31324438e716083f7327bd7b853bf46dec71d76d/src/biblock.jl#LL283-L287">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffusionMCMCTools.find_W_for_X!-Tuple{BiBlock}" href="#DiffusionMCMCTools.find_W_for_X!-Tuple{BiBlock}"><code>DiffusionMCMCTools.find_W_for_X!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">find_W_for_X!(bb::BiBlock)</code></pre><p>Find the Wiener process <code>bb.b.WW</code> that reconstructs path <code>bb.b.XX</code> under the accepted law <code>bb.b.PP</code> (possibly including <code>bb.b.P_last</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiffusionBayes/DiffusionMCMCTools.jl/blob/31324438e716083f7327bd7b853bf46dec71d76d/src/biblock.jl#LL294-L299">source</a></section></article><h4 id="Setting-parameters-1"><a class="docs-heading-anchor" href="#Setting-parameters-1">Setting parameters</a><a class="docs-heading-anchor-permalink" href="#Setting-parameters-1" title="Permalink"></a></h4><hr/><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>DiffusionMCMCTools.set_proposal_law!(     bb::DiffusionMCMCTools.BiBlock,     θ°,     pnames,     critical_change=DiffusionMCMCTools.is_critical_update(bb, pnames),     skip=0 )</code>. Check Documenter&#39;s build log for details.</p></div></div><h4 id="Utility-1"><a class="docs-heading-anchor" href="#Utility-1">Utility</a><a class="docs-heading-anchor-permalink" href="#Utility-1" title="Permalink"></a></h4><hr/><article class="docstring"><header><a class="docstring-binding" id="DiffusionMCMCTools.ll_of_accepted-Tuple{BiBlock,Any}" href="#DiffusionMCMCTools.ll_of_accepted-Tuple{BiBlock,Any}"><code>DiffusionMCMCTools.ll_of_accepted</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ll_of_accepted(bb::BiBlock, i)</code></pre><p>Return the log-likelihood of the path that was accepted at the <code>i</code>th iteration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiffusionBayes/DiffusionMCMCTools.jl/blob/31324438e716083f7327bd7b853bf46dec71d76d/src/biblock.jl#LL217-L221">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffusionMCMCTools.accpt_rate-Tuple{BiBlock,Any}" href="#DiffusionMCMCTools.accpt_rate-Tuple{BiBlock,Any}"><code>DiffusionMCMCTools.accpt_rate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">accpt_rate(bb::BiBlock, range)</code></pre><p>Compute the acceptance rate over the <code>range</code> of MCMC accept/reject history.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiffusionBayes/DiffusionMCMCTools.jl/blob/31324438e716083f7327bd7b853bf46dec71d76d/src/biblock.jl#LL227-L231">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffusionMCMCTools.loglikhd!-Tuple{BiBlock}" href="#DiffusionMCMCTools.loglikhd!-Tuple{BiBlock}"><code>DiffusionMCMCTools.loglikhd!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">loglikhd!(b::BiBlock)</code></pre><p>Compute the log-likelihood for the accepted block, evaluated at a sampled path and store the result in an internal field <code>ll</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiffusionBayes/DiffusionMCMCTools.jl/blob/31324438e716083f7327bd7b853bf46dec71d76d/src/biblock.jl#LL234-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffusionMCMCTools.loglikhd°!-Tuple{BiBlock}" href="#DiffusionMCMCTools.loglikhd°!-Tuple{BiBlock}"><code>DiffusionMCMCTools.loglikhd°!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">loglikhd°!(b::BiBlock)</code></pre><p>Compute the log-likelihood for the proposal block, evaluated at a sampled path and store the result in an internal field <code>ll</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiffusionBayes/DiffusionMCMCTools.jl/blob/31324438e716083f7327bd7b853bf46dec71d76d/src/biblock.jl#LL242-L247">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffusionMCMCTools.save_ll!-Tuple{BiBlock,Int64}" href="#DiffusionMCMCTools.save_ll!-Tuple{BiBlock,Int64}"><code>DiffusionMCMCTools.save_ll!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">save_ll!(bb::BiBlock, i::Int)</code></pre><p>Commit the current proposal and accepted log-likelihood fields <code>ll</code> to history, at index <code>i</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiffusionBayes/DiffusionMCMCTools.jl/blob/31324438e716083f7327bd7b853bf46dec71d76d/src/biblock.jl#LL250-L255">source</a></section></article><h1 id="Example:-smoothing-with-no-blocking-1"><a class="docs-heading-anchor" href="#Example:-smoothing-with-no-blocking-1">Example: smoothing with no blocking</a><a class="docs-heading-anchor-permalink" href="#Example:-smoothing-with-no-blocking-1" title="Permalink"></a></h1><hr/><h2 id="Set-up-1"><a class="docs-heading-anchor" href="#Set-up-1">Set-up</a><a class="docs-heading-anchor-permalink" href="#Set-up-1" title="Permalink"></a></h2><pre><code class="language-julia">using GuidedProposals, DiffusionDefinition, ObservationSchemes, DiffusionMCMCTools
const GP = GuidedProposals
const DD = DiffusionDefinition
const OBS = ObservationSchemes
const dMCMCt = DiffusionMCMCTools

using StaticArrays, Random, Plots

# seed used for this tutorial
Random.seed!(100)

@load_diffusion FitzHughNagumo
θ = [0.1, -0.8, 1.5, 0.0, 0.3]
P = FitzHughNagumo(θ...)
tt, y1 = 0.0:0.0001:10.0, @SVector [-0.9, -1.0]
X = rand(P, tt, y1)
obs_scheme = ObsScheme(
    LinearGsnObs(
        0.0, (@SVector [0.0]);
        L=(@SMatrix [1.0 0.0]),
        Σ=(@SMatrix [0.01])
    )
)
data = collect(obs_scheme, X, 1000)
recording = build_recording(P, data, 0.0, KnownStartingPt(y1))

plot(X, Val(:vs_time), size=(800, 300))
scatter!(map(x-&gt;x.t, data), map(x-&gt;x.obs[1], data), label=&quot;data&quot;)</code></pre><p><img src="../../assets/biblock/data.png" alt="data"/></p><h2 id="The-algorithm-1"><a class="docs-heading-anchor" href="#The-algorithm-1">The algorithm</a><a class="docs-heading-anchor-permalink" href="#The-algorithm-1" title="Permalink"></a></h2><pre><code class="language-julia">function simple_smoothing(AuxLaw, recording, dt; ρ=0.5, num_steps=10^4)
    tts = OBS.setup_time_grids(recording, dt, standard_guid_prop_time_transf)
    # this object contains containers
    sp = SamplingPair(AuxLaw, recording, tts)
    # and this has pointers to containers and facilitates actual sampling
    bb = BiBlock(sp, 1:length(recording.obs), ρ, true, num_steps)
    loglikhd!(bb)
    paths = []

    # MCMC
    for i in 1:num_steps
        # impute a path
        draw_proposal_path!(bb)
        # Metropolis–Hastings accept/reject step
        accept_reject_proposal_path!(bb, i)

        # progress message
        if i % 100 == 0
            println(
                &quot;$i. ll=$(ll_of_accepted(bb, i)), acceptance rate: &quot;,
                &quot;$(sum(bb.accpt_history[(i-99):i])/100)&quot;
            )
        end

        # save intermediate path for plotting
        i % 400 == 0 &amp;&amp; append!(paths, [deepcopy(bb.b.XX)])
    end
    paths
end

@load_diffusion FitzHughNagumoAux
paths = simple_smoothing(
    FitzHughNagumoAux, recording, 0.001; ρ=0.96, num_steps=10^4
)</code></pre><h2 id="Results-1"><a class="docs-heading-anchor" href="#Results-1">Results</a><a class="docs-heading-anchor-permalink" href="#Results-1" title="Permalink"></a></h2><pre><code class="language-julia">function glue_paths(XX)
    XX_glued = trajectory(
        glue_containers( map(x-&gt;x.t, XX) ),
        glue_containers( map(x-&gt;x.x, XX) ),
    )
end

function glue_containers(xs)
    glued_xs = collect(Iterators.flatten(map(x-&gt;x[1:end-1], xs)))
    append!(glued_xs, [xs[end][end]])
    glued_xs
end

convenient_paths = glue_paths.(paths)

col = [&quot;#581845&quot;, &quot;#900C3F&quot;, &quot;#C70039&quot;, &quot;#FF5733&quot;, &quot;#FFC300&quot;]

p = plot(size=(1000, 500))
for path in convenient_paths
	plot!(p, path, Val(:vs_time), alpha=0.4, label=&quot;&quot;, color=[col[3] col[1]])
end
plot!(X, Val(:vs_time), color=[col[5] col[4]], linewidth=[3 0.5], label=[&quot;underlying X₁&quot; &quot;underlying X₂&quot;])
scatter!(p, map(x-&gt;x.t, data), map(x-&gt;x.obs[1], data), label=&quot;data&quot;, markercolor=col[5])
display(p)</code></pre><p><img src="../../assets/biblock/smoothing_results.png" alt="smoothing"/></p><h1 id="Example:-smoothing-with-blocking-1"><a class="docs-heading-anchor" href="#Example:-smoothing-with-blocking-1">Example: smoothing with blocking</a><a class="docs-heading-anchor-permalink" href="#Example:-smoothing-with-blocking-1" title="Permalink"></a></h1><hr/><h2 id="Set-up-2"><a class="docs-heading-anchor" href="#Set-up-2">Set-up</a><a class="docs-heading-anchor-permalink" href="#Set-up-2" title="Permalink"></a></h2><p>Same as above</p><h2 id="The-algorithm-2"><a class="docs-heading-anchor" href="#The-algorithm-2">The algorithm</a><a class="docs-heading-anchor-permalink" href="#The-algorithm-2" title="Permalink"></a></h2><pre><code class="language-julia">function simple_smoothing_with_blocking(
        AuxLaw, recording, dt, AuxLawBlocking, block_layout;
        ρ=0.5, num_steps=10^4
    )
    tts = OBS.setup_time_grids(recording, dt, standard_guid_prop_time_transf)
    # this object contains containers
    sp = SamplingPair(AuxLaw, recording, tts)
    # and this has pointers to containers and facilitates actual sampling
    blocks = [
        [
            BiBlock(sp, br, ρ, i==length(block_ranges), num_steps)
            for (i,br) in enumerate(block_ranges)
        ] for block_ranges in block_layout
    ]

    paths = []

    N = length(blocks)
    # MCMC
    for i in 1:num_steps
        for B in blocks
            # freeze terminal points of blocks to be artificial observations
            GP.set_obs!.(B)
            # recompute the guiding term only on the &quot;accepted&quot; laws `bb.b.PP`
            (bb-&gt;recompute_guiding_term!(bb.b)).(B)
            # recompute the Wiener path
            find_W_for_X!.(B)
            # re-evaluate the log-likelihood
            loglikhd!.(B)
            # impute a path
            draw_proposal_path!.(B)
            # Metropolis–Hastings accept/reject step
            accept_reject_proposal_path!.(B, i)

            # progress message
            if i % 100 == 0
                println(
                    &quot;$i. ll=$(ll_of_accepted.(B, i)), acceptance rate: &quot;,
                    &quot;$( map(bb-&gt;accpt_rate(bb, (i-99):i), B) )&quot;
                )
            end
        end

        # save intermediate path for plotting
        i % 400 == 0 &amp;&amp; append!(paths, [deepcopy(sp.u.XX)])
    end
    paths
end</code></pre><h2 id="Results-2"><a class="docs-heading-anchor" href="#Results-2">Results</a><a class="docs-heading-anchor-permalink" href="#Results-2" title="Permalink"></a></h2><pre><code class="language-julia">@inline DD.nonhypo(x, P::FitzHughNagumo) = x[SVector{1,Int64}(2)]
@inline DD.nonhypo_σ(t::Float64, x, P::FitzHughNagumo) = SMatrix{1,1,Float64}(P.σ)
paths = simple_smoothing_with_blocking(
    FitzHughNagumoAux, recording, 0.001, FitzHughNagumoAux,
    [[1:25,26:75,76:100],[1:50, 51:100]];
    ρ=0.96, num_steps=10^4
)</code></pre><p>Same plotting routines as above yield: <img src="../../assets/biblock/smoothing_with_blocking_results.png" alt="smoothing_with_blocking_results"/></p><h1 id="Example:-inference-with-no-blocking-1"><a class="docs-heading-anchor" href="#Example:-inference-with-no-blocking-1">Example: inference with no blocking</a><a class="docs-heading-anchor-permalink" href="#Example:-inference-with-no-blocking-1" title="Permalink"></a></h1><hr/><h2 id="Set-up-3"><a class="docs-heading-anchor" href="#Set-up-3">Set up</a><a class="docs-heading-anchor-permalink" href="#Set-up-3" title="Permalink"></a></h2><p>Same as before</p><h2 id="The-algorithm-3"><a class="docs-heading-anchor" href="#The-algorithm-3">The algorithm</a><a class="docs-heading-anchor-permalink" href="#The-algorithm-3" title="Permalink"></a></h2><pre><code class="language-julia">customkernel(θ, scale=0.1) = θ .+ 2.0*scale*(rand()-0.5)

#=
    NOTE: this will appear to be completely unnecessary and coming out of the
    blue if you are not considering more complicated settings of mixed effect
    models. Looking up ahead into the definition of ... should be helpful if
    you want to understand what the function below is aiming to do.

    In here, we are just creating the most basic struture that is needed for
    setting parameters. It can be much more complex if blocking, multiple
    updates and/or mixed effect models were used.
=#
#↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓
_build_struct(N, args...) = (
    var = tuple(),
    var_aux = fill(tuple(), N),
    updt = tuple(args...),
    updt_aux = fill(tuple(args...), N),
    updt_obs = fill(tuple(), N),
)

function simple_name_structure(pname::Symbol, num_obs)
    pnames = (
        PP = _build_struct(num_obs, (1=&gt;pname)),
        P_last = _build_struct(0), # was num_obs
        P_excl = _build_struct(0),
        Pb_excl = _build_struct(num_obs, (1=&gt;pname)),
    )
end
#↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑

function accept_reject_proposal_param!(bb, mcmciter, θ, θ°)
    accepted = rand(Exponential(1.0)) &gt; -(bb.b°.ll - bb.b.ll)
    accepted &amp;&amp; swap_XX!(bb)
    accepted &amp;&amp; swap_PP!(bb)
    save_ll!(bb, mcmciter)
    accepted &amp;&amp; swap_ll!(bb)
    accepted, copy(accepted ? θ° : θ)
end

function simple_inference(AuxLaw, recording, dt, _θ; ϵ=0.3, ρ=0.5, num_steps=10^4)
    # making sure that things are in order...
    _pname = collect(keys(_θ))
    # for simplicity restrict to inference for a single param
    @assert length(_pname) == 1
    pname = first(_pname)
    θ = collect(values(_θ))

    # setting the initial guess θ inside the recording
    OBS.set_parameters!(recording, _θ)

    # setting up containers
    num_obs = length(recording.obs)
    tts = OBS.setup_time_grids(recording, dt, standard_guid_prop_time_transf)
    sp = SamplingPair(AuxLaw, recording, tts)
    bb = BiBlock(sp, 1:num_obs, ρ, true, num_steps)
    name_struct = simple_name_structure(pname, num_obs)

    loglikhd!(bb)
    paths = []

    θθ = [θ]
    a_h = Bool[]

    for i in 1:num_steps
        draw_proposal_path!(bb)
        accept_reject_proposal_path!(bb, i)

        θ° = customkernel(θ, ϵ)
        set_proposal_law!(bb, θ°, name_struct, true)

        accpt, θ = accept_reject_proposal_param!(bb, i, θ, θ°)
        push!(θθ, θ)
        push!(a_h, accpt)

        # progress message
        if i % 100 == 0
            println(
                &quot;$i. ll=$(ll_of_accepted(bb, i)), &quot;,
                &quot;imp a-r: &quot;,
                &quot; $(accpt_rate(bb, (i-99):i)), &quot;,
                &quot;updt a-r: &quot;,
                &quot;$(sum(a_h[(i-99):i])/100).&quot;
            )
        end

        # save intermediate path for plotting
        i % 400 == 0 &amp;&amp; append!(paths, [deepcopy(sp.u.XX)])
    end
    paths, θθ
end</code></pre><h2 id="Results-3"><a class="docs-heading-anchor" href="#Results-3">Results</a><a class="docs-heading-anchor-permalink" href="#Results-3" title="Permalink"></a></h2><pre><code class="language-julia">plot(getindex.(θθ, 1))</code></pre><p><img src="../../assets/biblock/inference_chain.png" alt="inference_chain"/></p><h1 id="Example:-inference-with-blocking-1"><a class="docs-heading-anchor" href="#Example:-inference-with-blocking-1">Example: inference with blocking</a><a class="docs-heading-anchor-permalink" href="#Example:-inference-with-blocking-1" title="Permalink"></a></h1><hr/><h2 id="Set-up-4"><a class="docs-heading-anchor" href="#Set-up-4">Set up</a><a class="docs-heading-anchor-permalink" href="#Set-up-4" title="Permalink"></a></h2><p>Same as before</p><h2 id="The-algorithm-4"><a class="docs-heading-anchor" href="#The-algorithm-4">The algorithm</a><a class="docs-heading-anchor-permalink" href="#The-algorithm-4" title="Permalink"></a></h2><pre><code class="language-julia">#↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓
function simple_name_structure_not_last(pname::Symbol, num_obs)
    pnames = (
        PP = _build_struct(num_obs-1, (1=&gt;pname)),
        P_last = _build_struct(1, (1=&gt;pname)),
        P_excl = _build_struct(1, (1=&gt;pname)),
        Pb_excl = _build_struct(num_obs-1, (1=&gt;pname)),
    )
end

function simple_name_structure_blocking(pname::Symbol, block_layout)
    map(block_layout) do block_set
        map(enumerate(block_set)) do (i, block)
            (
                i == length(block_set) ?
                simple_name_structure(pname, length(block)) :
                simple_name_structure_not_last(pname, length(block))
            )
        end
    end
end
#↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑

function accept_reject_proposal_param!(B::AbstractArray{&lt;:BiBlock}, mcmciter, θ, θ°)
    accepted = rand(Exponential(1.0)) &gt; mapreduce(bb-&gt;-(bb.b°.ll - bb.b.ll),+,B)
    accepted &amp;&amp; swap_XX!.(B)
    accepted &amp;&amp; swap_PP!.(B)
    (bb-&gt;save_ll!(bb.b, mcmciter)).(B)
    (bb-&gt;save_ll!(bb.b°, mcmciter)).(B)
    accepted &amp;&amp; swap_ll!.(B)
    accepted, copy(accepted ? θ° : θ)
end


function simple_inference_with_blocking(
        AuxLaw, recording, dt, AuxLawBlocking, block_layout, _θ;
        ϵ=0.3, ρ=0.5, num_steps=10^4
    )
    # making sure that things are in order...
    _pname = collect(keys(_θ))
    # for simplicity restrict to inference for a single param
    @assert length(_pname) == 1
    pname = first(_pname)
    θ = collect(values(_θ))

    # setting the initial guess θ inside the recording
    OBS.set_parameters!(recording, _θ)

    # setting up containers
    tts = OBS.setup_time_grids(recording, dt, standard_guid_prop_time_transf)
    sp = SamplingPair(AuxLaw, recording, tts)
    blocks = [
        [
            BiBlock(sp, br, ρ, i==length(block_ranges), num_steps)
            for (i,br) in enumerate(block_ranges)
        ] for block_ranges in block_layout
    ]
    name_struct = simple_name_structure_blocking(pname, block_layout)

    paths = []

    θθ = [θ]
    a_h = Bool[]

    # MCMC
    for i in 1:num_steps
        for B in blocks
            GP.set_obs!.(B)
            (bb-&gt;recompute_guiding_term!(bb.b)).(B)
            find_W_for_X!.(B)
            loglikhd!.(B)
            draw_proposal_path!.(B)
            accept_reject_proposal_path!.(B, i)

            # progress message
            if i % 100 == 0
                println(
                    &quot;$i. ll=$(ll_of_accepted.(B, i)), acceptance rate: &quot;,
                    &quot;$( map(bb-&gt;accpt_rate(bb, (i-99):i), B) )&quot;
                )
            end
        end

        θ° = customkernel(θ, ϵ)

        B = blocks[end]
        for (idx, bb) in enumerate(B)
            set_proposal_law!(bb, θ°, name_struct[end][idx], true)
        end
        (bb-&gt;recompute_guiding_term!(bb.b°)).(B)

        accpt, θ = accept_reject_proposal_param!(B, i, θ, θ°)
        push!(θθ, θ)
        push!(a_h, accpt)

        if i % 100 == 0
            println(
                &quot;$i. updt a-r: &quot;,
                &quot;$(sum(a_h[(i-99):i])/100).&quot;
            )
        end

        # save intermediate path for plotting
        i % 400 == 0 &amp;&amp; append!(paths, [deepcopy(sp.u.XX)])
    end
    paths, θθ
end</code></pre><h2 id="The-results-1"><a class="docs-heading-anchor" href="#The-results-1">The results</a><a class="docs-heading-anchor-permalink" href="#The-results-1" title="Permalink"></a></h2><pre><code class="language-julia">using OrderedCollections

θ = OrderedDict(:γ=&gt;1.5)

DD.var_parameter_names(::FitzHughNagumo) = (:γ,)
DD.var_parameter_names(::FitzHughNagumoAux) = (:γ,)

@load_diffusion FitzHughNagumoAux
paths, θθ = simple_inference_with_blocking(
    FitzHughNagumoAux, recording, 0.001, FitzHughNagumoAux,
    [[1:25,26:75,76:100],[1:50, 51:100]], θ; ϵ=0.3, ρ=0.96, num_steps=10^4
)

plot(getindex.(θθ, 1))</code></pre><p><img src="../../assets/biblock/inference_with_blocking_results.png" alt="inference_with_blocking_chain"/></p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>As you can see above, <code>BiBlock</code> is the fundamental building block that is used for creating inference and smoothing algorithms. However, as the complexity of these algorithms grow it is useful to use some <code>macro structures</code> that operate on or are defined for multiple <code>BiBlock</code>s. This is precisely what the remaining tools defined in this package are for. Otherwise put, they aim to facilitate writing snippets of code as above in a much more compact and convenient way.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../sampling_pair/">« SamplingPair</a><a class="docs-footer-nextpage" href="../param_names_collections/">Containers for parameter names »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 29 June 2020 16:02">Monday 29 June 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
